<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>pywrapcp API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<style type="text/css">
a:link { color: #46641e; text-decoration: none}
.ident { color: #46641e }
</style>
<link rel="icon" href="https://developers.google.com/optimization/images/orLogo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pywrapcp</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info &lt; (2, 7, 0):
    raise RuntimeError(&#34;Python 2.7 or later required&#34;)

# Import the low-level C/C++ module
if __package__ or &#34;.&#34; in __name__:
    from . import _pywrapcp
else:
    import _pywrapcp

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = &#34;proxy of &#34; + self.this.__repr__()
    except __builtin__.Exception:
        strthis = &#34;&#34;
    return &#34;&lt;%s.%s; %s &gt;&#34; % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == &#34;thisown&#34;:
            self.this.own(value)
        elif name == &#34;this&#34;:
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError(&#34;You cannot add instance attributes to %s&#34; % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError(&#34;You cannot add class attributes to %s&#34; % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    &#34;&#34;&#34;Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass&#34;&#34;&#34;
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    &#34;&#34;&#34;Meta class to enforce nondynamic attributes (no new attributes) for a class&#34;&#34;&#34;
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class DefaultPhaseParameters(object):
    r&#34;&#34;&#34; This struct holds all parameters for the default search. DefaultPhaseParameters is only used by Solver::MakeDefaultPhase methods. Note this is for advanced users only.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr
    CHOOSE_MAX_SUM_IMPACT = _pywrapcp.DefaultPhaseParameters_CHOOSE_MAX_SUM_IMPACT
    CHOOSE_MAX_AVERAGE_IMPACT = _pywrapcp.DefaultPhaseParameters_CHOOSE_MAX_AVERAGE_IMPACT
    CHOOSE_MAX_VALUE_IMPACT = _pywrapcp.DefaultPhaseParameters_CHOOSE_MAX_VALUE_IMPACT
    SELECT_MIN_IMPACT = _pywrapcp.DefaultPhaseParameters_SELECT_MIN_IMPACT
    SELECT_MAX_IMPACT = _pywrapcp.DefaultPhaseParameters_SELECT_MAX_IMPACT
    NONE = _pywrapcp.DefaultPhaseParameters_NONE
    NORMAL = _pywrapcp.DefaultPhaseParameters_NORMAL
    VERBOSE = _pywrapcp.DefaultPhaseParameters_VERBOSE
    var_selection_schema = property(_pywrapcp.DefaultPhaseParameters_var_selection_schema_get, _pywrapcp.DefaultPhaseParameters_var_selection_schema_set, doc=r&#34;&#34;&#34; This parameter describes how the next variable to instantiate will be chosen.&#34;&#34;&#34;)
    value_selection_schema = property(_pywrapcp.DefaultPhaseParameters_value_selection_schema_get, _pywrapcp.DefaultPhaseParameters_value_selection_schema_set, doc=r&#34;&#34;&#34; This parameter describes which value to select for a given var.&#34;&#34;&#34;)
    initialization_splits = property(_pywrapcp.DefaultPhaseParameters_initialization_splits_get, _pywrapcp.DefaultPhaseParameters_initialization_splits_set, doc=r&#34;&#34;&#34; Maximum number of intervals that the initialization of impacts will scan per variable.&#34;&#34;&#34;)
    run_all_heuristics = property(_pywrapcp.DefaultPhaseParameters_run_all_heuristics_get, _pywrapcp.DefaultPhaseParameters_run_all_heuristics_set, doc=r&#34;&#34;&#34; The default phase will run heuristics periodically. This parameter indicates if we should run all heuristics, or a randomly selected one.&#34;&#34;&#34;)
    heuristic_period = property(_pywrapcp.DefaultPhaseParameters_heuristic_period_get, _pywrapcp.DefaultPhaseParameters_heuristic_period_set, doc=r&#34;&#34;&#34; The distance in nodes between each run of the heuristics. A negative or null value will mean that we will not run heuristics at all.&#34;&#34;&#34;)
    heuristic_num_failures_limit = property(_pywrapcp.DefaultPhaseParameters_heuristic_num_failures_limit_get, _pywrapcp.DefaultPhaseParameters_heuristic_num_failures_limit_set, doc=r&#34;&#34;&#34; The failure limit for each heuristic that we run.&#34;&#34;&#34;)
    persistent_impact = property(_pywrapcp.DefaultPhaseParameters_persistent_impact_get, _pywrapcp.DefaultPhaseParameters_persistent_impact_set, doc=r&#34;&#34;&#34; Whether to keep the impact from the first search for other searches, or to recompute the impact for each new search.&#34;&#34;&#34;)
    random_seed = property(_pywrapcp.DefaultPhaseParameters_random_seed_get, _pywrapcp.DefaultPhaseParameters_random_seed_set, doc=r&#34;&#34;&#34; Seed used to initialize the random part in some heuristics.&#34;&#34;&#34;)
    display_level = property(_pywrapcp.DefaultPhaseParameters_display_level_get, _pywrapcp.DefaultPhaseParameters_display_level_set, doc=r&#34;&#34;&#34; This represents the amount of information displayed by the default search. NONE means no display, VERBOSE means extra information.&#34;&#34;&#34;)
    decision_builder = property(_pywrapcp.DefaultPhaseParameters_decision_builder_get, _pywrapcp.DefaultPhaseParameters_decision_builder_set, doc=r&#34;&#34;&#34; When defined, this overrides the default impact based decision builder.&#34;&#34;&#34;)

    def __init__(self):
        _pywrapcp.DefaultPhaseParameters_swiginit(self, _pywrapcp.new_DefaultPhaseParameters())
    __swig_destroy__ = _pywrapcp.delete_DefaultPhaseParameters

# Register DefaultPhaseParameters in _pywrapcp:
_pywrapcp.DefaultPhaseParameters_swigregister(DefaultPhaseParameters)

class Solver(object):
    r&#34;&#34;&#34; Solver Class A solver represents the main computation engine. It implements the entire range of Constraint Programming protocols:   - Reversibility   - Propagation   - Search Usually, Constraint Programming code consists of   - the creation of the Solver,   - the creation of the decision variables of the model,   - the creation of the constraints of the model and their addition to the     solver() through the AddConstraint() method,   - the creation of the main DecisionBuilder class,   - the launch of the solve() method with the decision builder. For the time being, Solver is neither MT_SAFE nor MT_HOT.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr
    INT_VAR_DEFAULT = _pywrapcp.Solver_INT_VAR_DEFAULT
    r&#34;&#34;&#34; The default behavior is CHOOSE_FIRST_UNBOUND.&#34;&#34;&#34;
    INT_VAR_SIMPLE = _pywrapcp.Solver_INT_VAR_SIMPLE
    r&#34;&#34;&#34; The simple selection is CHOOSE_FIRST_UNBOUND.&#34;&#34;&#34;
    CHOOSE_FIRST_UNBOUND = _pywrapcp.Solver_CHOOSE_FIRST_UNBOUND
    r&#34;&#34;&#34; Select the first unbound variable. Variables are considered in the order of the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_RANDOM = _pywrapcp.Solver_CHOOSE_RANDOM
    r&#34;&#34;&#34; Randomly select one of the remaining unbound variables.&#34;&#34;&#34;
    CHOOSE_MIN_SIZE_LOWEST_MIN = _pywrapcp.Solver_CHOOSE_MIN_SIZE_LOWEST_MIN
    r&#34;&#34;&#34; Among unbound variables, select the variable with the smallest size, i.e., the smallest number of possible values. In case of a tie, the selected variables is the one with the lowest min value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_MIN_SIZE_HIGHEST_MIN = _pywrapcp.Solver_CHOOSE_MIN_SIZE_HIGHEST_MIN
    r&#34;&#34;&#34; Among unbound variables, select the variable with the smallest size, i.e., the smallest number of possible values. In case of a tie, the selected variable is the one with the highest min value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_MIN_SIZE_LOWEST_MAX = _pywrapcp.Solver_CHOOSE_MIN_SIZE_LOWEST_MAX
    r&#34;&#34;&#34; Among unbound variables, select the variable with the smallest size, i.e., the smallest number of possible values. In case of a tie, the selected variables is the one with the lowest max value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_MIN_SIZE_HIGHEST_MAX = _pywrapcp.Solver_CHOOSE_MIN_SIZE_HIGHEST_MAX
    r&#34;&#34;&#34; Among unbound variables, select the variable with the smallest size, i.e., the smallest number of possible values. In case of a tie, the selected variable is the one with the highest max value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_LOWEST_MIN = _pywrapcp.Solver_CHOOSE_LOWEST_MIN
    r&#34;&#34;&#34; Among unbound variables, select the variable with the smallest minimal value. In case of a tie, the first one is selected, &#34;first&#34; defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_HIGHEST_MAX = _pywrapcp.Solver_CHOOSE_HIGHEST_MAX
    r&#34;&#34;&#34; Among unbound variables, select the variable with the highest maximal value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_MIN_SIZE = _pywrapcp.Solver_CHOOSE_MIN_SIZE
    r&#34;&#34;&#34; Among unbound variables, select the variable with the smallest size. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_MAX_SIZE = _pywrapcp.Solver_CHOOSE_MAX_SIZE
    r&#34;&#34;&#34; Among unbound variables, select the variable with the highest size. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_MAX_REGRET_ON_MIN = _pywrapcp.Solver_CHOOSE_MAX_REGRET_ON_MIN
    r&#34;&#34;&#34; Among unbound variables, select the variable with the largest gap between the first and the second values of the domain.&#34;&#34;&#34;
    CHOOSE_PATH = _pywrapcp.Solver_CHOOSE_PATH
    r&#34;&#34;&#34; Selects the next unbound variable on a path, the path being defined by the variables: var[i] corresponds to the index of the next of i.&#34;&#34;&#34;
    INT_VALUE_DEFAULT = _pywrapcp.Solver_INT_VALUE_DEFAULT
    r&#34;&#34;&#34; The default behavior is ASSIGN_MIN_VALUE.&#34;&#34;&#34;
    INT_VALUE_SIMPLE = _pywrapcp.Solver_INT_VALUE_SIMPLE
    r&#34;&#34;&#34; The simple selection is ASSIGN_MIN_VALUE.&#34;&#34;&#34;
    ASSIGN_MIN_VALUE = _pywrapcp.Solver_ASSIGN_MIN_VALUE
    r&#34;&#34;&#34; Selects the min value of the selected variable.&#34;&#34;&#34;
    ASSIGN_MAX_VALUE = _pywrapcp.Solver_ASSIGN_MAX_VALUE
    r&#34;&#34;&#34; Selects the max value of the selected variable.&#34;&#34;&#34;
    ASSIGN_RANDOM_VALUE = _pywrapcp.Solver_ASSIGN_RANDOM_VALUE
    r&#34;&#34;&#34; Selects randomly one of the possible values of the selected variable.&#34;&#34;&#34;
    ASSIGN_CENTER_VALUE = _pywrapcp.Solver_ASSIGN_CENTER_VALUE
    r&#34;&#34;&#34; Selects the first possible value which is the closest to the center of the domain of the selected variable. The center is defined as (min + max) / 2.&#34;&#34;&#34;
    SPLIT_LOWER_HALF = _pywrapcp.Solver_SPLIT_LOWER_HALF
    r&#34;&#34;&#34; Split the domain in two around the center, and choose the lower part first.&#34;&#34;&#34;
    SPLIT_UPPER_HALF = _pywrapcp.Solver_SPLIT_UPPER_HALF
    r&#34;&#34;&#34; Split the domain in two around the center, and choose the lower part first.&#34;&#34;&#34;
    SEQUENCE_DEFAULT = _pywrapcp.Solver_SEQUENCE_DEFAULT
    SEQUENCE_SIMPLE = _pywrapcp.Solver_SEQUENCE_SIMPLE
    CHOOSE_MIN_SLACK_RANK_FORWARD = _pywrapcp.Solver_CHOOSE_MIN_SLACK_RANK_FORWARD
    CHOOSE_RANDOM_RANK_FORWARD = _pywrapcp.Solver_CHOOSE_RANDOM_RANK_FORWARD
    INTERVAL_DEFAULT = _pywrapcp.Solver_INTERVAL_DEFAULT
    r&#34;&#34;&#34; The default is INTERVAL_SET_TIMES_FORWARD.&#34;&#34;&#34;
    INTERVAL_SIMPLE = _pywrapcp.Solver_INTERVAL_SIMPLE
    r&#34;&#34;&#34; The simple is INTERVAL_SET_TIMES_FORWARD.&#34;&#34;&#34;
    INTERVAL_SET_TIMES_FORWARD = _pywrapcp.Solver_INTERVAL_SET_TIMES_FORWARD
    r&#34;&#34;&#34; Selects the variable with the lowest starting time of all variables, and fixes its starting time to this lowest value.&#34;&#34;&#34;
    INTERVAL_SET_TIMES_BACKWARD = _pywrapcp.Solver_INTERVAL_SET_TIMES_BACKWARD
    r&#34;&#34;&#34; Selects the variable with the highest ending time of all variables, and fixes the ending time to this highest values.&#34;&#34;&#34;
    TWOOPT = _pywrapcp.Solver_TWOOPT
    r&#34;&#34;&#34; Operator which reverses a sub-chain of a path. It is called TwoOpt because it breaks two arcs on the path; resulting paths are called two-optimal. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (where (1, 5) are first and last nodes of the path and can therefore not be moved):   1 -&gt; [3 -&gt; 2] -&gt; 4  -&gt; 5   1 -&gt; [4 -&gt; 3  -&gt; 2] -&gt; 5   1 -&gt;  2 -&gt; [4 -&gt; 3] -&gt; 5&#34;&#34;&#34;
    OROPT = _pywrapcp.Solver_OROPT
    r&#34;&#34;&#34; Relocate: OROPT and RELOCATE. Operator which moves a sub-chain of a path to another position; the specified chain length is the fixed length of the chains being moved. When this length is 1, the operator simply moves a node to another position. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a chain length of 2 (where (1, 5) are first and last nodes of the path and can therefore not be moved):   1 -&gt;  4 -&gt; [2 -&gt; 3] -&gt; 5   1 -&gt; [3 -&gt; 4] -&gt; 2  -&gt; 5 Using Relocate with chain lengths of 1, 2 and 3 together is equivalent to the OrOpt operator on a path. The OrOpt operator is a limited  version of 3Opt (breaks 3 arcs on a path).&#34;&#34;&#34;
    RELOCATE = _pywrapcp.Solver_RELOCATE
    r&#34;&#34;&#34; Relocate neighborhood with length of 1 (see OROPT comment).&#34;&#34;&#34;
    EXCHANGE = _pywrapcp.Solver_EXCHANGE
    r&#34;&#34;&#34; Operator which exchanges the positions of two nodes. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (where (1, 5) are first and last nodes of the path and can therefore not be moved):   1 -&gt; [3] -&gt; [2] -&gt;  4  -&gt; 5   1 -&gt; [4] -&gt;  3  -&gt; [2] -&gt; 5   1 -&gt;  2  -&gt; [4] -&gt; [3] -&gt; 5&#34;&#34;&#34;
    CROSS = _pywrapcp.Solver_CROSS
    r&#34;&#34;&#34; Operator which cross exchanges the starting chains of 2 paths, including exchanging the whole paths. First and last nodes are not moved. Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8 (where (1, 5) and (6, 8) are first and last nodes of the paths and can therefore not be moved):   1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5  6 -&gt; [2] -&gt; 8   1 -&gt; [7] -&gt; 4 -&gt; 5       6 -&gt; [2 -&gt; 3] -&gt; 8   1 -&gt; [7] -&gt; 5            6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8&#34;&#34;&#34;
    MAKEACTIVE = _pywrapcp.Solver_MAKEACTIVE
    r&#34;&#34;&#34; Operator which inserts an inactive node into a path. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive (where 1 and 4 are first and last nodes of the path) are:   1 -&gt; [5] -&gt;  2  -&gt;  3  -&gt; 4   1 -&gt;  2  -&gt; [5] -&gt;  3  -&gt; 4   1 -&gt;  2  -&gt;  3  -&gt; [5] -&gt; 4&#34;&#34;&#34;
    MAKEINACTIVE = _pywrapcp.Solver_MAKEINACTIVE
    r&#34;&#34;&#34; Operator which makes path nodes inactive. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first and last nodes of the path) are:   1 -&gt; 3 -&gt; 4 with 2 inactive   1 -&gt; 2 -&gt; 4 with 3 inactive&#34;&#34;&#34;
    MAKECHAININACTIVE = _pywrapcp.Solver_MAKECHAININACTIVE
    r&#34;&#34;&#34; Operator which makes a &#34;chain&#34; of path nodes inactive. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first and last nodes of the path) are:   1 -&gt; 3 -&gt; 4 with 2 inactive   1 -&gt; 2 -&gt; 4 with 3 inactive   1 -&gt; 4 with 2 and 3 inactive&#34;&#34;&#34;
    SWAPACTIVE = _pywrapcp.Solver_SWAPACTIVE
    r&#34;&#34;&#34; Operator which replaces an active node by an inactive one. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive (where 1 and 4 are first and last nodes of the path) are:   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive&#34;&#34;&#34;
    EXTENDEDSWAPACTIVE = _pywrapcp.Solver_EXTENDEDSWAPACTIVE
    r&#34;&#34;&#34; Operator which makes an inactive node active and an active one inactive. It is similar to SwapActiveOperator except that it tries to insert the inactive node in all possible positions instead of just the position of the node made inactive. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive (where 1 and 4 are first and last nodes of the path) are:   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive   1 -&gt;  3  -&gt; [5] -&gt; 4 with 2 inactive   1 -&gt; [5] -&gt;  2  -&gt; 4 with 3 inactive   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive&#34;&#34;&#34;
    PATHLNS = _pywrapcp.Solver_PATHLNS
    r&#34;&#34;&#34; Operator which relaxes two sub-chains of three consecutive arcs each. Each sub-chain is defined by a start node and the next three arcs. Those six arcs are relaxed to build a new neighbor. PATHLNS explores all possible pairs of starting nodes and so defines n^2 neighbors, n being the number of nodes. Note that the two sub-chains can be part of the same path; they even may overlap.&#34;&#34;&#34;
    FULLPATHLNS = _pywrapcp.Solver_FULLPATHLNS
    r&#34;&#34;&#34; Operator which relaxes one entire path and all inactive nodes, thus defining num_paths neighbors.&#34;&#34;&#34;
    UNACTIVELNS = _pywrapcp.Solver_UNACTIVELNS
    r&#34;&#34;&#34; Operator which relaxes all inactive nodes and one sub-chain of six consecutive arcs. That way the path can be improved by inserting inactive nodes or swapping arcs.&#34;&#34;&#34;
    INCREMENT = _pywrapcp.Solver_INCREMENT
    r&#34;&#34;&#34; Operator which defines one neighbor per variable. Each neighbor tries to increment by one the value of the corresponding variable. When a new solution is found the neighborhood is rebuilt from scratch, i.e., tries to increment values in the variable order. Consider for instance variables x and y. x is incremented one by one to its max, and when it is not possible to increment x anymore, y is incremented once. If this is a solution, then next neighbor tries to increment x.&#34;&#34;&#34;
    DECREMENT = _pywrapcp.Solver_DECREMENT
    r&#34;&#34;&#34; Operator which defines a neighborhood to decrement values. The behavior is the same as INCREMENT, except values are decremented instead of incremented.&#34;&#34;&#34;
    SIMPLELNS = _pywrapcp.Solver_SIMPLELNS
    r&#34;&#34;&#34; Operator which defines one neighbor per variable. Each neighbor relaxes one variable. When a new solution is found the neighborhood is rebuilt from scratch. Consider for instance variables x and y. First x is relaxed and the solver is looking for the best possible solution (with only x relaxed). Then y is relaxed, and the solver is looking for a new solution. If a new solution is found, then the next variable to be relaxed is x.&#34;&#34;&#34;
    GE = _pywrapcp.Solver_GE
    r&#34;&#34;&#34; Move is accepted when the current objective value &gt;= objective.Min.&#34;&#34;&#34;
    LE = _pywrapcp.Solver_LE
    r&#34;&#34;&#34; Move is accepted when the current objective value &lt;= objective.Max.&#34;&#34;&#34;
    EQ = _pywrapcp.Solver_EQ
    r&#34;&#34;&#34; Move is accepted when the current objective value is in the interval objective.Min .. objective.Max.&#34;&#34;&#34;
    DELAYED_PRIORITY = _pywrapcp.Solver_DELAYED_PRIORITY
    r&#34;&#34;&#34; DELAYED_PRIORITY is the lowest priority: Demons will be processed after VAR_PRIORITY and NORMAL_PRIORITY demons.&#34;&#34;&#34;
    VAR_PRIORITY = _pywrapcp.Solver_VAR_PRIORITY
    r&#34;&#34;&#34; VAR_PRIORITY is between DELAYED_PRIORITY and NORMAL_PRIORITY.&#34;&#34;&#34;
    NORMAL_PRIORITY = _pywrapcp.Solver_NORMAL_PRIORITY
    r&#34;&#34;&#34; NORMAL_PRIORITY is the highest priority: Demons will be processed first.&#34;&#34;&#34;

    def __init__(self, *args):
        _pywrapcp.Solver_swiginit(self, _pywrapcp.new_Solver(*args))

        self.__python_constraints = []



    __swig_destroy__ = _pywrapcp.delete_Solver

    def Parameters(self) -&gt; &#34;operations_research::ConstraintSolverParameters&#34;:
        r&#34;&#34;&#34; Stored Parameters.&#34;&#34;&#34;
        return _pywrapcp.Solver_Parameters(self)

    @staticmethod
    def DefaultSolverParameters() -&gt; &#34;operations_research::ConstraintSolverParameters&#34;:
        r&#34;&#34;&#34; Create a ConstraintSolverParameters proto with all the default values.&#34;&#34;&#34;
        return _pywrapcp.Solver_DefaultSolverParameters()

    def AddConstraint(self, c: &#34;Constraint&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        Adds the constraint &#39;c&#39; to the model. After calling this method, and until there is a backtrack that undoes the addition, any assignment of variables to values must satisfy the given constraint in order to be considered feasible. There are two fairly different use cases: - the most common use case is modeling: the given constraint is really part of the problem that the user is trying to solve. In this use case, AddConstraint is called outside of search (i.e., with.. code-block:: c++

           state() == OUTSIDE_SEARCH). Most users should only use AddConstraint in this way. In this case, the constraint will belong to the model forever: it cannot not be removed by backtracking. - a rarer use case is that &#39;c&#39; is not a real constraint of the model. It may be a constraint generated by a branching decision (a constraint whose goal is to restrict the search space), a symmetry breaking constraint (a constraint that does restrict the search space, but in a way that cannot have an impact on the quality of the solutions in the subtree), or an inferred constraint that, while having no semantic value to the model (it does not restrict the set of solutions), is worth having because we believe it may strengthen the propagation. In these cases, it happens that the constraint is added during the search (i.e., with state() == IN_SEARCH or state() == IN_ROOT_NODE). When a constraint is added during a search, it applies only to the subtree of the search tree rooted at the current node, and will be automatically removed by backtracking. This method does not take ownership of the constraint. If the constraint has been created by any factory method (Solver::MakeXXX), it will automatically be deleted. However, power users who implement their own constraints should do: solver.AddConstraint(solver.RevAlloc(new MyConstraint(...));
        &#34;&#34;&#34;
        return _pywrapcp.Solver_AddConstraint(self, c)

    def Solve(self, *args) -&gt; &#34;bool&#34;:
        return _pywrapcp.Solver_Solve(self, *args)

    def NewSearch(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.Solver_NewSearch(self, *args)

    def NextSolution(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.Solver_NextSolution(self)

    def RestartSearch(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Solver_RestartSearch(self)

    def EndSearch(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Solver_EndSearch(self)

    def SolveAndCommit(self, *args) -&gt; &#34;bool&#34;:
        return _pywrapcp.Solver_SolveAndCommit(self, *args)

    def CheckAssignment(self, solution: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Checks whether the given assignment satisfies all relevant constraints.&#34;&#34;&#34;
        return _pywrapcp.Solver_CheckAssignment(self, solution)

    def CheckConstraint(self, ct: &#34;Constraint&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Checks whether adding this constraint will lead to an immediate failure. It will return false if the model is already inconsistent, or if adding the constraint makes it inconsistent.&#34;&#34;&#34;
        return _pywrapcp.Solver_CheckConstraint(self, ct)

    def Fail(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Abandon the current branch in the search tree. A backtrack will follow.&#34;&#34;&#34;
        return _pywrapcp.Solver_Fail(self)

    @staticmethod
    def MemoryUsage() -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Current memory usage in bytes&#34;&#34;&#34;
        return _pywrapcp.Solver_MemoryUsage()

    def WallTime(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; DEPRECATED: Use Now() instead. Time elapsed, in ms since the creation of the solver.&#34;&#34;&#34;
        return _pywrapcp.Solver_WallTime(self)

    def Branches(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; The number of branches explored since the creation of the solver.&#34;&#34;&#34;
        return _pywrapcp.Solver_Branches(self)

    def Solutions(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; The number of solutions found since the start of the search.&#34;&#34;&#34;
        return _pywrapcp.Solver_Solutions(self)

    def Failures(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; The number of failures encountered since the creation of the solver.&#34;&#34;&#34;
        return _pywrapcp.Solver_Failures(self)

    def AcceptedNeighbors(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; The number of accepted neighbors.&#34;&#34;&#34;
        return _pywrapcp.Solver_AcceptedNeighbors(self)

    def Stamp(self) -&gt; &#34;uint64&#34;:
        r&#34;&#34;&#34; The stamp indicates how many moves in the search tree we have performed. It is useful to detect if we need to update same lazy structures.&#34;&#34;&#34;
        return _pywrapcp.Solver_Stamp(self)

    def FailStamp(self) -&gt; &#34;uint64&#34;:
        r&#34;&#34;&#34; The fail_stamp() is incremented after each backtrack.&#34;&#34;&#34;
        return _pywrapcp.Solver_FailStamp(self)

    def IntVar(self, *args) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        MakeIntVar will create the best range based int var for the bounds given.

        |

        *Overload 2:*
        MakeIntVar will create a variable with the given sparse domain.

        |

        *Overload 3:*
        MakeIntVar will create a variable with the given sparse domain.

        |

        *Overload 4:*
        MakeIntVar will create the best range based int var for the bounds given.

        |

        *Overload 5:*
        MakeIntVar will create a variable with the given sparse domain.

        |

        *Overload 6:*
        MakeIntVar will create a variable with the given sparse domain.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_IntVar(self, *args)

    def BoolVar(self, *args) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        MakeBoolVar will create a variable with a {0, 1} domain.

        |

        *Overload 2:*
        MakeBoolVar will create a variable with a {0, 1} domain.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_BoolVar(self, *args)

    def IntConst(self, *args) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        IntConst will create a constant expression.

        |

        *Overload 2:*
        IntConst will create a constant expression.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_IntConst(self, *args)

    def Sum(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; sum of all vars.&#34;&#34;&#34;
        return _pywrapcp.Solver_Sum(self, vars)

    def ScalProd(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        scalar product

        |

        *Overload 2:*
        scalar product
        &#34;&#34;&#34;
        return _pywrapcp.Solver_ScalProd(self, *args)

    def MonotonicElement(self, values: &#34;operations_research::Solver::IndexEvaluator1&#34;, increasing: &#34;bool&#34;, index: &#34;IntVar&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; Function based element. The constraint takes ownership of the callback.  The callback must be monotonic. It must be able to cope with any possible value in the domain of &#39;index&#39; (potentially negative ones too). Furtermore, monotonicity is not checked. Thus giving a non-monotonic function, or specifying an incorrect increasing parameter will result in undefined behavior.&#34;&#34;&#34;
        return _pywrapcp.Solver_MonotonicElement(self, values, increasing, index)

    def Element(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        values[index]

        |

        *Overload 2:*
        values[index]

        |

        *Overload 3:*
        Function-based element. The constraint takes ownership of the callback. The callback must be able to cope with any possible value in the domain of &#39;index&#39; (potentially negative ones too).

        |

        *Overload 4:*
        2D version of function-based element expression, values(expr1, expr2).

        |

        *Overload 5:*
        vars[expr]
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Element(self, *args)

    def IndexExpression(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; Returns the expression expr such that vars[expr] == value. It assumes that vars are all different.&#34;&#34;&#34;
        return _pywrapcp.Solver_IndexExpression(self, vars, value)

    def Min(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        std::min(vars)

        |

        *Overload 2:*
        std::min (left, right)

        |

        *Overload 3:*
        std::min(expr, value)

        |

        *Overload 4:*
        std::min(expr, value)
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Min(self, *args)

    def Max(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        std::max(vars)

        |

        *Overload 2:*
        std::max(left, right)

        |

        *Overload 3:*
        std::max(expr, value)

        |

        *Overload 4:*
        std::max(expr, value)
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Max(self, *args)

    def ConvexPiecewiseExpr(self, expr: &#34;IntExpr&#34;, early_cost: &#34;int64&#34;, early_date: &#34;int64&#34;, late_date: &#34;int64&#34;, late_cost: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; Convex piecewise function.&#34;&#34;&#34;
        return _pywrapcp.Solver_ConvexPiecewiseExpr(self, expr, early_cost, early_date, late_date, late_cost)

    def SemiContinuousExpr(self, expr: &#34;IntExpr&#34;, fixed_charge: &#34;int64&#34;, step: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; Semi continuous Expression (x &lt;= 0 -&gt; f(x) = 0; x &gt; 0 -&gt; f(x) = ax + b) a &gt;= 0 and b &gt;= 0&#34;&#34;&#34;
        return _pywrapcp.Solver_SemiContinuousExpr(self, expr, fixed_charge, step)

    def ConditionalExpression(self, condition: &#34;IntVar&#34;, expr: &#34;IntExpr&#34;, unperformed_value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; Conditional Expr condition ? expr : unperformed_value&#34;&#34;&#34;
        return _pywrapcp.Solver_ConditionalExpression(self, condition, expr, unperformed_value)

    def TrueConstraint(self) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; This constraint always succeeds.&#34;&#34;&#34;
        return _pywrapcp.Solver_TrueConstraint(self)

    def FalseConstraint(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_FalseConstraint(self, *args)

    def IsEqualCstCt(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;, boolvar: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; boolvar == (var == value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsEqualCstCt(self, var, value, boolvar)

    def IsEqualCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (var == value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsEqualCstVar(self, var, value)

    def IsEqualCt(self, v1: &#34;IntExpr&#34;, v2: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (v1 == v2)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsEqualCt(self, v1, v2, b)

    def IsEqualVar(self, v1: &#34;IntExpr&#34;, v2: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (v1 == v2)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsEqualVar(self, v1, v2)

    def IsDifferentCstCt(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;, boolvar: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; boolvar == (var != value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsDifferentCstCt(self, var, value, boolvar)

    def IsDifferentCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (var != value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsDifferentCstVar(self, var, value)

    def IsDifferentVar(self, v1: &#34;IntExpr&#34;, v2: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (v1 != v2)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsDifferentVar(self, v1, v2)

    def IsDifferentCt(self, v1: &#34;IntExpr&#34;, v2: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (v1 != v2)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsDifferentCt(self, v1, v2, b)

    def IsLessOrEqualCstCt(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;, boolvar: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; boolvar == (var &lt;= value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessOrEqualCstCt(self, var, value, boolvar)

    def IsLessOrEqualCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (var &lt;= value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessOrEqualCstVar(self, var, value)

    def IsLessOrEqualVar(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (left &lt;= right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessOrEqualVar(self, left, right)

    def IsLessOrEqualCt(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (left &lt;= right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessOrEqualCt(self, left, right, b)

    def IsGreaterOrEqualCstCt(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;, boolvar: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; boolvar == (var &gt;= value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterOrEqualCstCt(self, var, value, boolvar)

    def IsGreaterOrEqualCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (var &gt;= value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterOrEqualCstVar(self, var, value)

    def IsGreaterOrEqualVar(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (left &gt;= right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterOrEqualVar(self, left, right)

    def IsGreaterOrEqualCt(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (left &gt;= right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterOrEqualCt(self, left, right, b)

    def IsGreaterCstCt(self, v: &#34;IntExpr&#34;, c: &#34;int64&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (v &gt; c)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterCstCt(self, v, c, b)

    def IsGreaterCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (var &gt; value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterCstVar(self, var, value)

    def IsGreaterVar(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (left &gt; right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterVar(self, left, right)

    def IsGreaterCt(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (left &gt; right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterCt(self, left, right, b)

    def IsLessCstCt(self, v: &#34;IntExpr&#34;, c: &#34;int64&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (v &lt; c)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessCstCt(self, v, c, b)

    def IsLessCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (var &lt; value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessCstVar(self, var, value)

    def IsLessVar(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (left &lt; right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessVar(self, left, right)

    def IsLessCt(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (left &lt; right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessCt(self, left, right, b)

    def SumLessOrEqual(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, cst: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Variation on arrays.&#34;&#34;&#34;
        return _pywrapcp.Solver_SumLessOrEqual(self, vars, cst)

    def SumGreaterOrEqual(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, cst: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_SumGreaterOrEqual(self, vars, cst)

    def SumEquality(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_SumEquality(self, *args)

    def ScalProdEquality(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_ScalProdEquality(self, *args)

    def ScalProdGreaterOrEqual(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_ScalProdGreaterOrEqual(self, *args)

    def ScalProdLessOrEqual(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_ScalProdLessOrEqual(self, *args)

    def MinEquality(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, min_var: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_MinEquality(self, vars, min_var)

    def MaxEquality(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, max_var: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_MaxEquality(self, vars, max_var)

    def ElementEquality(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_ElementEquality(self, *args)

    def AbsEquality(self, var: &#34;IntVar&#34;, abs_var: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates the constraint abs(var) == abs_var.&#34;&#34;&#34;
        return _pywrapcp.Solver_AbsEquality(self, var, abs_var)

    def IndexOfConstraint(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, index: &#34;IntVar&#34;, target: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; This constraint is a special case of the element constraint with an array of integer variables, where the variables are all different and the index variable is constrained such that vars[index] == target.&#34;&#34;&#34;
        return _pywrapcp.Solver_IndexOfConstraint(self, vars, index, target)

    def ConstraintInitialPropagateCallback(self, ct: &#34;Constraint&#34;) -&gt; &#34;operations_research::Demon *&#34;:
        r&#34;&#34;&#34; This method is a specialized case of the MakeConstraintDemon method to call the InitiatePropagate of the constraint &#39;ct&#39;.&#34;&#34;&#34;
        return _pywrapcp.Solver_ConstraintInitialPropagateCallback(self, ct)

    def DelayedConstraintInitialPropagateCallback(self, ct: &#34;Constraint&#34;) -&gt; &#34;operations_research::Demon *&#34;:
        r&#34;&#34;&#34; This method is a specialized case of the MakeConstraintDemon method to call the InitiatePropagate of the constraint &#39;ct&#39; with low priority.&#34;&#34;&#34;
        return _pywrapcp.Solver_DelayedConstraintInitialPropagateCallback(self, ct)

    def ClosureDemon(self, closure: &#34;operations_research::Solver::Closure&#34;) -&gt; &#34;operations_research::Demon *&#34;:
        r&#34;&#34;&#34; Creates a demon from a closure.&#34;&#34;&#34;
        return _pywrapcp.Solver_ClosureDemon(self, closure)

    def BetweenCt(self, expr: &#34;IntExpr&#34;, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; (l &lt;= expr &lt;= u)&#34;&#34;&#34;
        return _pywrapcp.Solver_BetweenCt(self, expr, l, u)

    def IsBetweenCt(self, expr: &#34;IntExpr&#34;, l: &#34;int64&#34;, u: &#34;int64&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (l &lt;= expr &lt;= u)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsBetweenCt(self, expr, l, u, b)

    def IsBetweenVar(self, v: &#34;IntExpr&#34;, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.Solver_IsBetweenVar(self, v, l, u)

    def MemberCt(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_MemberCt(self, *args)

    def NotMemberCt(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        expr not in set.

        |

        *Overload 2:*
        expr should not be in the list of forbidden intervals [start[i]..end[i]].

        |

        *Overload 3:*
        expr should not be in the list of forbidden intervals [start[i]..end[i]].
        &#34;&#34;&#34;
        return _pywrapcp.Solver_NotMemberCt(self, *args)

    def IsMemberCt(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_IsMemberCt(self, *args)

    def IsMemberVar(self, *args) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.Solver_IsMemberVar(self, *args)

    def Count(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        |{i | vars[i] == value}| == max_count

        |

        *Overload 2:*
        |{i | vars[i] == value}| == max_count
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Count(self, *args)

    def Distribute(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]

        |

        *Overload 2:*
        Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]

        |

        *Overload 3:*
        Aggregated version of count:  |{i | v[i] == j}| == cards[j]

        |

        *Overload 4:*
        Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1: card_min &lt;= |{i | v[i] == j}| &lt;= card_max

        |

        *Overload 5:*
        Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:    card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]

        |

        *Overload 6:*
        Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:    card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]

        |

        *Overload 7:*
        Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:    card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]

        |

        *Overload 8:*
        Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:    card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Distribute(self, *args)

    def Deviation(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, deviation_var: &#34;IntVar&#34;, total_sum: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Deviation constraint: sum_i |n * vars[i] - total_sum| &lt;= deviation_var and sum_i vars[i] == total_sum n = #vars&#34;&#34;&#34;
        return _pywrapcp.Solver_Deviation(self, vars, deviation_var, total_sum)

    def AllDifferent(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        All variables are pairwise different. This corresponds to the stronger version of the propagation algorithm.

        |

        *Overload 2:*
        All variables are pairwise different.  If &#39;stronger_propagation&#39; is true, stronger, and potentially slower propagation will occur. This API will be deprecated in the future.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_AllDifferent(self, *args)

    def AllDifferentExcept(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, escape_value: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; All variables are pairwise different, unless they are assigned to the escape value.&#34;&#34;&#34;
        return _pywrapcp.Solver_AllDifferentExcept(self, vars, escape_value)

    def SortingConstraint(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, sorted: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates a constraint binding the arrays of variables &#34;vars&#34; and &#34;sorted_vars&#34;: sorted_vars[0] must be equal to the minimum of all variables in vars, and so on: the value of sorted_vars[i] must be equal to the i-th value of variables invars. This constraint propagates in both directions: from &#34;vars&#34; to &#34;sorted_vars&#34; and vice-versa. Behind the scenes, this constraint maintains that:   - sorted is always increasing.   - whatever the values of vars, there exists a permutation that     injects its values into the sorted variables. For more info, please have a look at:   https://mpi-inf.mpg.de/~mehlhorn/ftp/Mehlhorn-Thiel.pdf&#34;&#34;&#34;
        return _pywrapcp.Solver_SortingConstraint(self, vars, sorted)

    def LexicalLess(self, left: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, right: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates a constraint that enforces that left is lexicographically less than right.&#34;&#34;&#34;
        return _pywrapcp.Solver_LexicalLess(self, left, right)

    def LexicalLessOrEqual(self, left: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, right: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates a constraint that enforces that left is lexicographically less than or equal to right.&#34;&#34;&#34;
        return _pywrapcp.Solver_LexicalLessOrEqual(self, left, right)

    def InversePermutationConstraint(self, left: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, right: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates a constraint that enforces that &#39;left&#39; and &#39;right&#39; both represent permutations of [0..left.size()-1], and that &#39;right&#39; is the inverse permutation of &#39;left&#39;, i.e. for all i in [0..left.size()-1], right[left[i]] = i.&#34;&#34;&#34;
        return _pywrapcp.Solver_InversePermutationConstraint(self, left, right)

    def NullIntersect(self, first_vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, second_vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates a constraint that states that all variables in the first vector are different from all variables in the second group. Thus the set of values in the first vector does not intersect with the set of values in the second vector.&#34;&#34;&#34;
        return _pywrapcp.Solver_NullIntersect(self, first_vars, second_vars)

    def NullIntersectExcept(self, first_vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, second_vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, escape_value: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates a constraint that states that all variables in the first vector are different from all variables from the second group, unless they are assigned to the escape value. Thus the set of values in the first vector minus the escape value does not intersect with the set of values in the second vector.&#34;&#34;&#34;
        return _pywrapcp.Solver_NullIntersectExcept(self, first_vars, second_vars, escape_value)

    def Circuit(self, nexts: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Force the &#34;nexts&#34; variable to create a complete Hamiltonian path.&#34;&#34;&#34;
        return _pywrapcp.Solver_Circuit(self, nexts)

    def SubCircuit(self, nexts: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Force the &#34;nexts&#34; variable to create a complete Hamiltonian path for those that do not loop upon themselves.&#34;&#34;&#34;
        return _pywrapcp.Solver_SubCircuit(self, nexts)

    def DelayedPathCumul(self, nexts: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, active: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, cumuls: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, transits: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Delayed version of the same constraint: propagation on the nexts variables is delayed until all constraints have propagated.&#34;&#34;&#34;
        return _pywrapcp.Solver_DelayedPathCumul(self, nexts, active, cumuls, transits)

    def PathCumul(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Creates a constraint which accumulates values along a path such that: cumuls[next[i]] = cumuls[i] + transits[i]. Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem.

        |

        *Overload 2:*
        Creates a constraint which accumulates values along a path such that: cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]). Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem. Ownership of transit_evaluator is taken and it must be a repeatable callback.

        |

        *Overload 3:*
        Creates a constraint which accumulates values along a path such that: cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]) + slacks[i]. Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem. Ownership of transit_evaluator is taken and it must be a repeatable callback.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_PathCumul(self, *args)

    def AllowedAssignments(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This method creates a constraint where the graph of the relation between the variables is given in extension. There are &#39;arity&#39; variables involved in the relation and the graph is given by a integer tuple set.

        |

        *Overload 2:*
        Compatibility layer for Python API.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_AllowedAssignments(self, *args)

    def TransitionConstraint(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_TransitionConstraint(self, *args)

    def NonOverlappingBoxesConstraint(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_NonOverlappingBoxesConstraint(self, *args)

    def Pack(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, number_of_bins: &#34;int&#34;) -&gt; &#34;operations_research::Pack *&#34;:
        r&#34;&#34;&#34; This constraint packs all variables onto &#39;number_of_bins&#39; variables.  For any given variable, a value of &#39;number_of_bins&#39; indicates that the variable is not assigned to any bin. Dimensions, i.e., cumulative constraints on this packing, can be added directly from the pack class.&#34;&#34;&#34;
        return _pywrapcp.Solver_Pack(self, vars, number_of_bins)

    def FixedDurationIntervalVar(self, *args) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Creates an interval var with a fixed duration. The duration must be greater than 0. If optional is true, then the interval can be performed or unperformed. If optional is false, then the interval is always performed.

        |

        *Overload 2:*
        Creates a performed interval var with a fixed duration. The duration must be greater than 0.

        |

        *Overload 3:*
        Creates an interval var with a fixed duration, and performed_variable. The duration must be greater than 0.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_FixedDurationIntervalVar(self, *args)

    def FixedInterval(self, start: &#34;int64&#34;, duration: &#34;int64&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates a fixed and performed interval.&#34;&#34;&#34;
        return _pywrapcp.Solver_FixedInterval(self, start, duration, name)

    def IntervalVar(self, start_min: &#34;int64&#34;, start_max: &#34;int64&#34;, duration_min: &#34;int64&#34;, duration_max: &#34;int64&#34;, end_min: &#34;int64&#34;, end_max: &#34;int64&#34;, optional: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates an interval var by specifying the bounds on start, duration, and end.&#34;&#34;&#34;
        return _pywrapcp.Solver_IntervalVar(self, start_min, start_max, duration_min, duration_max, end_min, end_max, optional, name)

    def MirrorInterval(self, interval_var: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates an interval var that is the mirror image of the given one, that is, the interval var obtained by reversing the axis.&#34;&#34;&#34;
        return _pywrapcp.Solver_MirrorInterval(self, interval_var)

    def FixedDurationStartSyncedOnStartIntervalVar(self, interval_var: &#34;IntervalVar&#34;, duration: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates an interval var with a fixed duration whose start is synchronized with the start of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.&#34;&#34;&#34;
        return _pywrapcp.Solver_FixedDurationStartSyncedOnStartIntervalVar(self, interval_var, duration, offset)

    def FixedDurationStartSyncedOnEndIntervalVar(self, interval_var: &#34;IntervalVar&#34;, duration: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates an interval var with a fixed duration whose start is synchronized with the end of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.&#34;&#34;&#34;
        return _pywrapcp.Solver_FixedDurationStartSyncedOnEndIntervalVar(self, interval_var, duration, offset)

    def FixedDurationEndSyncedOnStartIntervalVar(self, interval_var: &#34;IntervalVar&#34;, duration: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates an interval var with a fixed duration whose end is synchronized with the start of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.&#34;&#34;&#34;
        return _pywrapcp.Solver_FixedDurationEndSyncedOnStartIntervalVar(self, interval_var, duration, offset)

    def FixedDurationEndSyncedOnEndIntervalVar(self, interval_var: &#34;IntervalVar&#34;, duration: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates an interval var with a fixed duration whose end is synchronized with the end of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.&#34;&#34;&#34;
        return _pywrapcp.Solver_FixedDurationEndSyncedOnEndIntervalVar(self, interval_var, duration, offset)

    def IntervalRelaxedMin(self, interval_var: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates and returns an interval variable that wraps around the given one, relaxing the min start and end. Relaxing means making unbounded when optional. If the variable is non-optional, this method returns interval_var. More precisely, such an interval variable behaves as follows: * When the underlying must be performed, the returned interval variable     behaves exactly as the underlying; * When the underlying may or may not be performed, the returned interval     variable behaves like the underlying, except that it is unbounded on     the min side; * When the underlying cannot be performed, the returned interval variable     is of duration 0 and must be performed in an interval unbounded on     both sides. This is very useful to implement propagators that may only modify the start max or end max.&#34;&#34;&#34;
        return _pywrapcp.Solver_IntervalRelaxedMin(self, interval_var)

    def IntervalRelaxedMax(self, interval_var: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates and returns an interval variable that wraps around the given one, relaxing the max start and end. Relaxing means making unbounded when optional. If the variable is non optional, this method returns interval_var. More precisely, such an interval variable behaves as follows: * When the underlying must be performed, the returned interval variable     behaves exactly as the underlying; * When the underlying may or may not be performed, the returned interval     variable behaves like the underlying, except that it is unbounded on     the max side; * When the underlying cannot be performed, the returned interval variable     is of duration 0 and must be performed in an interval unbounded on     both sides. This is very useful for implementing propagators that may only modify the start min or end min.&#34;&#34;&#34;
        return _pywrapcp.Solver_IntervalRelaxedMax(self, interval_var)

    def TemporalDisjunction(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This constraint implements a temporal disjunction between two interval vars t1 and t2. &#39;alt&#39; indicates which alternative was chosen (alt == 0 is equivalent to t1 before t2).

        |

        *Overload 2:*
        This constraint implements a temporal disjunction between two interval vars.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_TemporalDisjunction(self, *args)

    def DisjunctiveConstraint(self, intervals: &#34;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::DisjunctiveConstraint *&#34;:
        r&#34;&#34;&#34; This constraint forces all interval vars into an non-overlapping sequence. Intervals with zero duration can be scheduled anywhere.&#34;&#34;&#34;
        return _pywrapcp.Solver_DisjunctiveConstraint(self, intervals, name)

    def Cumulative(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This constraint forces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.

        |

        *Overload 2:*
        This constraint forces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.

        |

        *Overload 3:*
        This constraint forces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.

        |

        *Overload 4:*
        This constraint enforces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.

        |

        *Overload 5:*
        This constraint enforces that, for any integer t, the sum of demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should be positive.

        |

        *Overload 6:*
        This constraint enforces that, for any integer t, the sum of demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should be positive.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Cumulative(self, *args)

    def Cover(self, vars: &#34;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&#34;, target_var: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; This constraint states that the target_var is the convex hull of the intervals. If none of the interval variables is performed, then the target var is unperformed too. Also, if the target variable is unperformed, then all the intervals variables are unperformed too.&#34;&#34;&#34;
        return _pywrapcp.Solver_Cover(self, vars, target_var)

    def Assignment(self, *args) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This method creates an empty assignment.

        |

        *Overload 2:*
        This method creates an assignment which is a copy of &#39;a&#39;.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Assignment(self, *args)

    def FirstSolutionCollector(self, *args) -&gt; &#34;operations_research::SolutionCollector *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Collect the first solution of the search.

        |

        *Overload 2:*
        Collect the first solution of the search. The variables will need to be added later.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_FirstSolutionCollector(self, *args)

    def LastSolutionCollector(self, *args) -&gt; &#34;operations_research::SolutionCollector *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Collect the last solution of the search.

        |

        *Overload 2:*
        Collect the last solution of the search. The variables will need to be added later.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_LastSolutionCollector(self, *args)

    def BestValueSolutionCollector(self, *args) -&gt; &#34;operations_research::SolutionCollector *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Collect the solution corresponding to the optimal value of the objective of &#39;assignment&#39;; if &#39;assignment&#39; does not have an objective no solution is collected. This collector only collects one solution corresponding to the best objective value (the first one found).

        |

        *Overload 2:*
        Collect the solution corresponding to the optimal value of the objective of &#39;assignment&#39;; if &#39;assignment&#39; does not have an objective no solution is collected. This collector only collects one solution corresponding to the best objective value (the first one found). The variables will need to be added later.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_BestValueSolutionCollector(self, *args)

    def AllSolutionCollector(self, *args) -&gt; &#34;operations_research::SolutionCollector *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Collect all solutions of the search.

        |

        *Overload 2:*
        Collect all solutions of the search. The variables will need to be added later.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_AllSolutionCollector(self, *args)

    def Minimize(self, v: &#34;IntVar&#34;, step: &#34;int64&#34;) -&gt; &#34;operations_research::OptimizeVar *&#34;:
        r&#34;&#34;&#34; Creates a minimization objective.&#34;&#34;&#34;
        return _pywrapcp.Solver_Minimize(self, v, step)

    def Maximize(self, v: &#34;IntVar&#34;, step: &#34;int64&#34;) -&gt; &#34;operations_research::OptimizeVar *&#34;:
        r&#34;&#34;&#34; Creates a maximization objective.&#34;&#34;&#34;
        return _pywrapcp.Solver_Maximize(self, v, step)

    def Optimize(self, maximize: &#34;bool&#34;, v: &#34;IntVar&#34;, step: &#34;int64&#34;) -&gt; &#34;operations_research::OptimizeVar *&#34;:
        r&#34;&#34;&#34; Creates a objective with a given sense (true = maximization).&#34;&#34;&#34;
        return _pywrapcp.Solver_Optimize(self, maximize, v, step)

    def WeightedMinimize(self, *args) -&gt; &#34;operations_research::OptimizeVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Creates a minimization weighted objective. The actual objective is scalar_prod(sub_objectives, weights).

        |

        *Overload 2:*
        Creates a minimization weighted objective. The actual objective is scalar_prod(sub_objectives, weights).
        &#34;&#34;&#34;
        return _pywrapcp.Solver_WeightedMinimize(self, *args)

    def WeightedMaximize(self, *args) -&gt; &#34;operations_research::OptimizeVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Creates a maximization weigthed objective.

        |

        *Overload 2:*
        Creates a maximization weigthed objective.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_WeightedMaximize(self, *args)

    def WeightedOptimize(self, *args) -&gt; &#34;operations_research::OptimizeVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Creates a weighted objective with a given sense (true = maximization).

        |

        *Overload 2:*
        Creates a weighted objective with a given sense (true = maximization).
        &#34;&#34;&#34;
        return _pywrapcp.Solver_WeightedOptimize(self, *args)

    def TabuSearch(self, maximize: &#34;bool&#34;, v: &#34;IntVar&#34;, step: &#34;int64&#34;, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, keep_tenure: &#34;int64&#34;, forbid_tenure: &#34;int64&#34;, tabu_factor: &#34;double&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        r&#34;&#34;&#34; MetaHeuristics which try to get the search out of local optima. Creates a Tabu Search monitor. In the context of local search the behavior is similar to MakeOptimize(), creating an objective in a given sense. The behavior differs once a local optimum is reached: thereafter solutions which degrade the value of the objective are allowed if they are not &#34;tabu&#34;. A solution is &#34;tabu&#34; if it doesn&#39;t respect the following rules: - improving the best solution found so far - variables in the &#34;keep&#34; list must keep their value, variables in the &#34;forbid&#34; list must not take the value they have in the list. Variables with new values enter the tabu lists after each new solution found and leave the lists after a given number of iterations (called tenure). Only the variables passed to the method can enter the lists. The tabu criterion is softened by the tabu factor which gives the number of &#34;tabu&#34; violations which is tolerated; a factor of 1 means no violations allowed; a factor of 0 means all violations are allowed.&#34;&#34;&#34;
        return _pywrapcp.Solver_TabuSearch(self, maximize, v, step, vars, keep_tenure, forbid_tenure, tabu_factor)

    def SimulatedAnnealing(self, maximize: &#34;bool&#34;, v: &#34;IntVar&#34;, step: &#34;int64&#34;, initial_temperature: &#34;int64&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        r&#34;&#34;&#34; Creates a Simulated Annealing monitor.&#34;&#34;&#34;
        return _pywrapcp.Solver_SimulatedAnnealing(self, maximize, v, step, initial_temperature)

    def LubyRestart(self, scale_factor: &#34;int&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        r&#34;&#34;&#34; This search monitor will restart the search periodically. At the iteration n, it will restart after scale_factor * Luby(n) failures where Luby is the Luby Strategy (i.e. 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8...).&#34;&#34;&#34;
        return _pywrapcp.Solver_LubyRestart(self, scale_factor)

    def ConstantRestart(self, frequency: &#34;int&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        r&#34;&#34;&#34; This search monitor will restart the search periodically after &#39;frequency&#39; failures.&#34;&#34;&#34;
        return _pywrapcp.Solver_ConstantRestart(self, frequency)

    def TimeLimit(self, time_in_ms: &#34;int64&#34;) -&gt; &#34;operations_research::RegularLimit *&#34;:
        r&#34;&#34;&#34; Creates a search limit that constrains the running time given in milliseconds.&#34;&#34;&#34;
        return _pywrapcp.Solver_TimeLimit(self, time_in_ms)

    def BranchesLimit(self, branches: &#34;int64&#34;) -&gt; &#34;operations_research::RegularLimit *&#34;:
        r&#34;&#34;&#34; Creates a search limit that constrains the number of branches explored in the search tree.&#34;&#34;&#34;
        return _pywrapcp.Solver_BranchesLimit(self, branches)

    def FailuresLimit(self, failures: &#34;int64&#34;) -&gt; &#34;operations_research::RegularLimit *&#34;:
        r&#34;&#34;&#34; Creates a search limit that constrains the number of failures that can happen when exploring the search tree.&#34;&#34;&#34;
        return _pywrapcp.Solver_FailuresLimit(self, failures)

    def SolutionsLimit(self, solutions: &#34;int64&#34;) -&gt; &#34;operations_research::RegularLimit *&#34;:
        r&#34;&#34;&#34; Creates a search limit that constrains the number of solutions found during the search.&#34;&#34;&#34;
        return _pywrapcp.Solver_SolutionsLimit(self, solutions)

    def Limit(self, *args) -&gt; &#34;operations_research::SearchLimit *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Limits the search with the &#39;time&#39;, &#39;branches&#39;, &#39;failures&#39; and &#39;solutions&#39; limits.

        |

        *Overload 2:*
        Version reducing calls to wall timer by estimating number of remaining calls.

        |

        *Overload 3:*
        Creates a search limit which can either apply cumulatively or search-by-search.

        |

        *Overload 4:*
        Creates a search limit from its protobuf description

        |

        *Overload 5:*
        Creates a search limit that is reached when either of the underlying limit is reached. That is, the returned limit is more stringent than both argument limits.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Limit(self, *args)

    def CustomLimit(self, limiter: &#34;std::function&lt; bool () &gt;&#34;) -&gt; &#34;operations_research::SearchLimit *&#34;:
        r&#34;&#34;&#34; Callback-based search limit. Search stops when limiter returns true; if this happens at a leaf the corresponding solution will be rejected.&#34;&#34;&#34;
        return _pywrapcp.Solver_CustomLimit(self, limiter)

    def SearchLog(self, *args) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        return _pywrapcp.Solver_SearchLog(self, *args)

    def SearchTrace(self, prefix: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        r&#34;&#34;&#34; Creates a search monitor that will trace precisely the behavior of the search. Use this only for low level debugging.&#34;&#34;&#34;
        return _pywrapcp.Solver_SearchTrace(self, prefix)

    def PrintModelVisitor(self) -&gt; &#34;operations_research::ModelVisitor *&#34;:
        r&#34;&#34;&#34; Prints the model.&#34;&#34;&#34;
        return _pywrapcp.Solver_PrintModelVisitor(self)

    def StatisticsModelVisitor(self) -&gt; &#34;operations_research::ModelVisitor *&#34;:
        r&#34;&#34;&#34; Displays some nice statistics on the model.&#34;&#34;&#34;
        return _pywrapcp.Solver_StatisticsModelVisitor(self)

    def AssignVariableValue(self, var: &#34;IntVar&#34;, val: &#34;int64&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        r&#34;&#34;&#34; Decisions.&#34;&#34;&#34;
        return _pywrapcp.Solver_AssignVariableValue(self, var, val)

    def VariableLessOrEqualValue(self, var: &#34;IntVar&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_VariableLessOrEqualValue(self, var, value)

    def VariableGreaterOrEqualValue(self, var: &#34;IntVar&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_VariableGreaterOrEqualValue(self, var, value)

    def SplitVariableDomain(self, var: &#34;IntVar&#34;, val: &#34;int64&#34;, start_with_lower_half: &#34;bool&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_SplitVariableDomain(self, var, val, start_with_lower_half)

    def AssignVariableValueOrFail(self, var: &#34;IntVar&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_AssignVariableValueOrFail(self, var, value)

    def AssignVariablesValues(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_AssignVariablesValues(self, vars, values)

    def FailDecision(self) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_FailDecision(self)

    def Decision(self, apply: &#34;operations_research::Solver::Action&#34;, refute: &#34;operations_research::Solver::Action&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_Decision(self, apply, refute)

    def Compose(self, dbs: &#34;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_Compose(self, dbs)

    def Try(self, dbs: &#34;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_Try(self, dbs)

    def DefaultPhase(self, *args) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_DefaultPhase(self, *args)

    def ScheduleOrPostpone(self, var: &#34;IntervalVar&#34;, est: &#34;int64&#34;, marker: &#34;int64 *const&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        r&#34;&#34;&#34; Returns a decision that tries to schedule a task at a given time. On the Apply branch, it will set that interval var as performed and set its start to &#39;est&#39;. On the Refute branch, it will just update the &#39;marker&#39; to &#39;est&#39; + 1. This decision is used in the INTERVAL_SET_TIMES_FORWARD strategy.&#34;&#34;&#34;
        return _pywrapcp.Solver_ScheduleOrPostpone(self, var, est, marker)

    def ScheduleOrExpedite(self, var: &#34;IntervalVar&#34;, est: &#34;int64&#34;, marker: &#34;int64 *const&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        r&#34;&#34;&#34; Returns a decision that tries to schedule a task at a given time. On the Apply branch, it will set that interval var as performed and set its end to &#39;est&#39;. On the Refute branch, it will just update the &#39;marker&#39; to &#39;est&#39; - 1. This decision is used in the INTERVAL_SET_TIMES_BACKWARD strategy.&#34;&#34;&#34;
        return _pywrapcp.Solver_ScheduleOrExpedite(self, var, est, marker)

    def RankFirstInterval(self, sequence: &#34;SequenceVar&#34;, index: &#34;int&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        r&#34;&#34;&#34; Returns a decision that tries to rank first the ith interval var in the sequence variable.&#34;&#34;&#34;
        return _pywrapcp.Solver_RankFirstInterval(self, sequence, index)

    def RankLastInterval(self, sequence: &#34;SequenceVar&#34;, index: &#34;int&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        r&#34;&#34;&#34; Returns a decision that tries to rank last the ith interval var in the sequence variable.&#34;&#34;&#34;
        return _pywrapcp.Solver_RankLastInterval(self, sequence, index)

    def Phase(self, *args) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_Phase(self, *args)

    def DecisionBuilderFromAssignment(self, assignment: &#34;Assignment&#34;, db: &#34;DecisionBuilder&#34;, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        r&#34;&#34;&#34; Returns a decision builder for which the left-most leaf corresponds to assignment, the rest of the tree being explored using &#39;db&#39;.&#34;&#34;&#34;
        return _pywrapcp.Solver_DecisionBuilderFromAssignment(self, assignment, db, vars)

    def ConstraintAdder(self, ct: &#34;Constraint&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        r&#34;&#34;&#34; Returns a decision builder that will add the given constraint to the model.&#34;&#34;&#34;
        return _pywrapcp.Solver_ConstraintAdder(self, ct)

    def SolveOnce(self, db: &#34;DecisionBuilder&#34;, monitors: &#34;std::vector&lt; operations_research::SearchMonitor * &gt; const &amp;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_SolveOnce(self, db, monitors)

    def NestedOptimize(self, *args) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_NestedOptimize(self, *args)

    def RestoreAssignment(self, assignment: &#34;Assignment&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        r&#34;&#34;&#34; Returns a DecisionBuilder which restores an Assignment (calls void Assignment::Restore())&#34;&#34;&#34;
        return _pywrapcp.Solver_RestoreAssignment(self, assignment)

    def StoreAssignment(self, assignment: &#34;Assignment&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        r&#34;&#34;&#34; Returns a DecisionBuilder which stores an Assignment (calls void Assignment::Store())&#34;&#34;&#34;
        return _pywrapcp.Solver_StoreAssignment(self, assignment)

    def Operator(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
        return _pywrapcp.Solver_Operator(self, *args)

    def RandomLnsOperator(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
        return _pywrapcp.Solver_RandomLnsOperator(self, *args)

    def MoveTowardTargetOperator(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Creates a local search operator that tries to move the assignment of some variables toward a target. The target is given as an Assignment. This operator generates neighbors in which the only difference compared to the current state is that one variable that belongs to the target assignment is set to its target value.

        |

        *Overload 2:*
        Creates a local search operator that tries to move the assignment of some variables toward a target. The target is given either as two vectors: a vector of variables and a vector of associated target values. The two vectors should be of the same length. This operator generates neighbors in which the only difference compared to the current state is that one variable that belongs to the given vector is set to its target value.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_MoveTowardTargetOperator(self, *args)

    def ConcatenateOperators(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
        return _pywrapcp.Solver_ConcatenateOperators(self, *args)

    def RandomConcatenateOperators(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Randomized version of local search concatenator; calls a random operator at each call to MakeNextNeighbor().

        |

        *Overload 2:*
        Randomized version of local search concatenator; calls a random operator at each call to MakeNextNeighbor(). The provided seed is used to initialize the random number generator.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_RandomConcatenateOperators(self, *args)

    def NeighborhoodLimit(self, op: &#34;LocalSearchOperator&#34;, limit: &#34;int64&#34;) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
        r&#34;&#34;&#34; Creates a local search operator that wraps another local search operator and limits the number of neighbors explored (i.e., calls to MakeNextNeighbor from the current solution (between two calls to Start()). When this limit is reached, MakeNextNeighbor() returns false. The counter is cleared when Start() is called.&#34;&#34;&#34;
        return _pywrapcp.Solver_NeighborhoodLimit(self, op, limit)

    def LocalSearchPhase(self, *args) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_LocalSearchPhase(self, *args)

    def LocalSearchPhaseParameters(self, *args) -&gt; &#34;operations_research::LocalSearchPhaseParameters *&#34;:
        return _pywrapcp.Solver_LocalSearchPhaseParameters(self, *args)

    def SearchDepth(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Gets the search depth of the current active search. Returns -1 if there is no active search opened.&#34;&#34;&#34;
        return _pywrapcp.Solver_SearchDepth(self)

    def SearchLeftDepth(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Gets the search left depth of the current active search. Returns -1 if there is no active search opened.&#34;&#34;&#34;
        return _pywrapcp.Solver_SearchLeftDepth(self)

    def SolveDepth(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Gets the number of nested searches. It returns 0 outside search, 1 during the top level search, 2 or more in case of nested searches.&#34;&#34;&#34;
        return _pywrapcp.Solver_SolveDepth(self)

    def Rand64(self, size: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns a random value between 0 and &#39;size&#39; - 1;&#34;&#34;&#34;
        return _pywrapcp.Solver_Rand64(self, size)

    def Rand32(self, size: &#34;int32&#34;) -&gt; &#34;int32&#34;:
        r&#34;&#34;&#34; Returns a random value between 0 and &#39;size&#39; - 1;&#34;&#34;&#34;
        return _pywrapcp.Solver_Rand32(self, size)

    def ReSeed(self, seed: &#34;int32&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Reseed the solver random generator.&#34;&#34;&#34;
        return _pywrapcp.Solver_ReSeed(self, seed)

    def LocalSearchProfile(self) -&gt; &#34;std::string&#34;:
        r&#34;&#34;&#34; Returns local search profiling information in a human readable format. search profiles.&#34;&#34;&#34;
        return _pywrapcp.Solver_LocalSearchProfile(self)

    def Constraints(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Counts the number of constraints that have been added to the solver before the search.&#34;&#34;&#34;
        return _pywrapcp.Solver_Constraints(self)

    def Accept(self, visitor: &#34;operations_research::ModelVisitor *const&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Accepts the given model visitor.&#34;&#34;&#34;
        return _pywrapcp.Solver_Accept(self, visitor)

    def FinishCurrentSearch(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Tells the solver to kill or restart the current search.&#34;&#34;&#34;
        return _pywrapcp.Solver_FinishCurrentSearch(self)

    def RestartCurrentSearch(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Solver_RestartCurrentSearch(self)

    def ShouldFail(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; These methods are only useful for the SWIG wrappers, which need a way to externally cause the Solver to fail.&#34;&#34;&#34;
        return _pywrapcp.Solver_ShouldFail(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Solver___str__(self)

    def Add(self, ct):
      if isinstance(ct, PyConstraint):
        self.__python_constraints.append(ct)
      self.AddConstraint(ct)


    def TreeNoCycle(self, nexts: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, active: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, callback: &#34;operations_research::Solver::IndexFilter1&#34;=0) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_TreeNoCycle(self, nexts, active, callback)

    def SearchLogWithCallback(self, period: &#34;int&#34;, callback: &#34;std::function&lt; std::string () &gt;&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        return _pywrapcp.Solver_SearchLogWithCallback(self, period, callback)

    def ElementFunction(self, values: &#34;std::function&lt; int64 (int64) &gt;&#34;, index: &#34;IntVar&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Solver_ElementFunction(self, values, index)

    def VarEvalValStrPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_evaluator: &#34;std::function&lt; int64 (int64) &gt;&#34;, val_str: &#34;operations_research::Solver::IntValueStrategy&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_VarEvalValStrPhase(self, vars, var_evaluator, val_str)

    def VarStrValEvalPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_str: &#34;operations_research::Solver::IntVarStrategy&#34;, val_eval: &#34;operations_research::Solver::IndexEvaluator2&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_VarStrValEvalPhase(self, vars, var_str, val_eval)

    def VarEvalValEvalPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_eval: &#34;std::function&lt; int64 (int64) &gt;&#34;, val_eval: &#34;operations_research::Solver::IndexEvaluator2&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_VarEvalValEvalPhase(self, vars, var_eval, val_eval)

    def VarStrValEvalTieBreakPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_str: &#34;operations_research::Solver::IntVarStrategy&#34;, val_eval: &#34;operations_research::Solver::IndexEvaluator2&#34;, tie_breaker: &#34;std::function&lt; int64 (int64) &gt;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_VarStrValEvalTieBreakPhase(self, vars, var_str, val_eval, tie_breaker)

    def VarEvalValEvalTieBreakPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_eval: &#34;std::function&lt; int64 (int64) &gt;&#34;, val_eval: &#34;operations_research::Solver::IndexEvaluator2&#34;, tie_breaker: &#34;std::function&lt; int64 (int64) &gt;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_VarEvalValEvalTieBreakPhase(self, vars, var_eval, val_eval, tie_breaker)

    def EvalEvalStrPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, evaluator: &#34;operations_research::Solver::IndexEvaluator2&#34;, str: &#34;operations_research::Solver::EvaluatorStrategy&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_EvalEvalStrPhase(self, vars, evaluator, str)

    def EvalEvalStrTieBreakPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, evaluator: &#34;operations_research::Solver::IndexEvaluator2&#34;, tie_breaker: &#34;operations_research::Solver::IndexEvaluator1&#34;, str: &#34;operations_research::Solver::EvaluatorStrategy&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_EvalEvalStrTieBreakPhase(self, vars, evaluator, tie_breaker, str)

    def GuidedLocalSearch(self, *args) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        return _pywrapcp.Solver_GuidedLocalSearch(self, *args)

    def SumObjectiveFilter(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, values: &#34;operations_research::Solver::IndexEvaluator2&#34;, filter_enum: &#34;operations_research::Solver::LocalSearchFilterBound&#34;) -&gt; &#34;operations_research::LocalSearchFilter *&#34;:
        return _pywrapcp.Solver_SumObjectiveFilter(self, vars, values, filter_enum)

# Register Solver in _pywrapcp:
_pywrapcp.Solver_swigregister(Solver)

def Solver_DefaultSolverParameters() -&gt; &#34;operations_research::ConstraintSolverParameters&#34;:
    r&#34;&#34;&#34; Create a ConstraintSolverParameters proto with all the default values.&#34;&#34;&#34;
    return _pywrapcp.Solver_DefaultSolverParameters()

def Solver_MemoryUsage() -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Current memory usage in bytes&#34;&#34;&#34;
    return _pywrapcp.Solver_MemoryUsage()

class BaseObject(object):
    r&#34;&#34;&#34;
    A BaseObject is the root of all reversibly allocated objects. A DebugString method and the associated.. code-block:: c++

       operator&lt;are implemented as a convenience.
    &#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self):
        if self.__class__ == BaseObject:
            _self = None
        else:
            _self = self
        _pywrapcp.BaseObject_swiginit(self, _pywrapcp.new_BaseObject(_self, ))
    __swig_destroy__ = _pywrapcp.delete_BaseObject

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.BaseObject_DebugString(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.BaseObject___str__(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.BaseObject___repr__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_BaseObject(self)
        return weakref.proxy(self)

# Register BaseObject in _pywrapcp:
_pywrapcp.BaseObject_swigregister(BaseObject)

class PropagationBaseObject(BaseObject):
    r&#34;&#34;&#34; NOLINT The PropagationBaseObject is a subclass of BaseObject that is also friend to the Solver class. It allows accessing methods useful when writing new constraints or new expressions.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, s: &#34;Solver&#34;):
        if self.__class__ == PropagationBaseObject:
            _self = None
        else:
            _self = self
        _pywrapcp.PropagationBaseObject_swiginit(self, _pywrapcp.new_PropagationBaseObject(_self, s))
    __swig_destroy__ = _pywrapcp.delete_PropagationBaseObject

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.PropagationBaseObject_DebugString(self)

    def solver(self) -&gt; &#34;operations_research::Solver *&#34;:
        return _pywrapcp.PropagationBaseObject_solver(self)

    def Name(self) -&gt; &#34;std::string&#34;:
        r&#34;&#34;&#34; Object naming.&#34;&#34;&#34;
        return _pywrapcp.PropagationBaseObject_Name(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_PropagationBaseObject(self)
        return weakref.proxy(self)

# Register PropagationBaseObject in _pywrapcp:
_pywrapcp.PropagationBaseObject_swigregister(PropagationBaseObject)

class Decision(BaseObject):
    r&#34;&#34;&#34; A Decision represents a choice point in the search tree. The two main methods are Apply() to go left, or Refute() to go right.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self):
        if self.__class__ == Decision:
            _self = None
        else:
            _self = self
        _pywrapcp.Decision_swiginit(self, _pywrapcp.new_Decision(_self, ))
    __swig_destroy__ = _pywrapcp.delete_Decision

    def ApplyWrapper(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Apply will be called first when the decision is executed.&#34;&#34;&#34;
        return _pywrapcp.Decision_ApplyWrapper(self, s)

    def RefuteWrapper(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Refute will be called after a backtrack.&#34;&#34;&#34;
        return _pywrapcp.Decision_RefuteWrapper(self, s)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Decision_DebugString(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Decision___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Decision___str__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_Decision(self)
        return weakref.proxy(self)

# Register Decision in _pywrapcp:
_pywrapcp.Decision_swigregister(Decision)

class DecisionBuilder(BaseObject):
    r&#34;&#34;&#34; A DecisionBuilder is responsible for creating the search tree. The important method is Next(), which returns the next decision to execute.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self):
        if self.__class__ == DecisionBuilder:
            _self = None
        else:
            _self = self
        _pywrapcp.DecisionBuilder_swiginit(self, _pywrapcp.new_DecisionBuilder(_self, ))
    __swig_destroy__ = _pywrapcp.delete_DecisionBuilder

    def NextWrapper(self, s: &#34;Solver&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        r&#34;&#34;&#34; This is the main method of the decision builder class. It must return a decision (an instance of the class Decision). If it returns nullptr, this means that the decision builder has finished its work.&#34;&#34;&#34;
        return _pywrapcp.DecisionBuilder_NextWrapper(self, s)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.DecisionBuilder_DebugString(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.DecisionBuilder___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.DecisionBuilder___str__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_DecisionBuilder(self)
        return weakref.proxy(self)

# Register DecisionBuilder in _pywrapcp:
_pywrapcp.DecisionBuilder_swigregister(DecisionBuilder)

class Demon(BaseObject):
    r&#34;&#34;&#34; A Demon is the base element of a propagation queue. It is the main   object responsible for implementing the actual propagation   of the constraint and pruning the inconsistent values in the domains   of the variables. The main concept is that demons are listeners that are   attached to the variables and listen to their modifications. There are two methods:  - Run() is the actual method called when the demon is processed.  - priority() returns its priority. Standard priorities are slow, normal    or fast. &#34;immediate&#34; is reserved for variables and is treated separately.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self):
        r&#34;&#34;&#34; This indicates the priority of a demon. Immediate demons are treated separately and corresponds to variables.&#34;&#34;&#34;
        if self.__class__ == Demon:
            _self = None
        else:
            _self = self
        _pywrapcp.Demon_swiginit(self, _pywrapcp.new_Demon(_self, ))
    __swig_destroy__ = _pywrapcp.delete_Demon

    def RunWrapper(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This is the main callback of the demon.&#34;&#34;&#34;
        return _pywrapcp.Demon_RunWrapper(self, s)

    def Priority(self) -&gt; &#34;operations_research::Solver::DemonPriority&#34;:
        r&#34;&#34;&#34; This method returns the priority of the demon. Usually a demon is fast, slow or normal. Immediate demons are reserved for internal use to maintain variables.&#34;&#34;&#34;
        return _pywrapcp.Demon_Priority(self)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Demon_DebugString(self)

    def Inhibit(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method inhibits the demon in the search tree below the current position.&#34;&#34;&#34;
        return _pywrapcp.Demon_Inhibit(self, s)

    def Desinhibit(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method un-inhibits the demon that was previously inhibited.&#34;&#34;&#34;
        return _pywrapcp.Demon_Desinhibit(self, s)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_Demon(self)
        return weakref.proxy(self)

# Register Demon in _pywrapcp:
_pywrapcp.Demon_swigregister(Demon)

class Constraint(PropagationBaseObject):
    r&#34;&#34;&#34; A constraint is the main modeling object. It provides two methods:   - Post() is responsible for creating the demons and attaching them to     immediate demons().   - InitialPropagate() is called once just after Post and performs     the initial propagation. The subsequent propagations will be performed     by the demons Posted during the post() method.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, solver: &#34;Solver&#34;):
        if self.__class__ == Constraint:
            _self = None
        else:
            _self = self
        _pywrapcp.Constraint_swiginit(self, _pywrapcp.new_Constraint(_self, solver))
    __swig_destroy__ = _pywrapcp.delete_Constraint

    def Post(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method is called when the constraint is processed by the solver. Its main usage is to attach demons to variables.&#34;&#34;&#34;
        return _pywrapcp.Constraint_Post(self)

    def InitialPropagateWrapper(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method performs the initial propagation of the constraint. It is called just after the post.&#34;&#34;&#34;
        return _pywrapcp.Constraint_InitialPropagateWrapper(self)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Constraint_DebugString(self)

    def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Creates a Boolean variable representing the status of the constraint (false = constraint is violated, true = constraint is satisfied). It returns nullptr if the constraint does not support this API.&#34;&#34;&#34;
        return _pywrapcp.Constraint_Var(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Constraint___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Constraint___str__(self)

    def __add__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___add__(self, *args)

    def __radd__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___radd__(self, v)

    def __sub__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___sub__(self, *args)

    def __rsub__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___rsub__(self, v)

    def __mul__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___mul__(self, *args)

    def __rmul__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___rmul__(self, v)

    def __floordiv__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___floordiv__(self, v)

    def __neg__(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___neg__(self)

    def __abs__(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___abs__(self)

    def Square(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint_Square(self)

    def __eq__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint___eq__(self, *args)

    def __ne__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint___ne__(self, *args)

    def __ge__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint___ge__(self, *args)

    def __gt__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint___gt__(self, *args)

    def __le__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint___le__(self, *args)

    def __lt__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint___lt__(self, *args)

    def MapTo(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint_MapTo(self, vars)

    def IndexOf(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint_IndexOf(self, *args)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_Constraint(self)
        return weakref.proxy(self)

# Register Constraint in _pywrapcp:
_pywrapcp.Constraint_swigregister(Constraint)

class SearchMonitor(BaseObject):
    r&#34;&#34;&#34; A search monitor is a simple set of callbacks to monitor all search events&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, s: &#34;Solver&#34;):
        if self.__class__ == SearchMonitor:
            _self = None
        else:
            _self = self
        _pywrapcp.SearchMonitor_swiginit(self, _pywrapcp.new_SearchMonitor(_self, s))
    __swig_destroy__ = _pywrapcp.delete_SearchMonitor

    def EnterSearch(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Beginning of the search.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_EnterSearch(self)

    def RestartSearch(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Restart the search.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_RestartSearch(self)

    def ExitSearch(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; End of the search.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_ExitSearch(self)

    def BeginNextDecision(self, b: &#34;DecisionBuilder&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Before calling DecisionBuilder::Next.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_BeginNextDecision(self, b)

    def EndNextDecision(self, b: &#34;DecisionBuilder&#34;, d: &#34;Decision&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; After calling DecisionBuilder::Next, along with the returned decision.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_EndNextDecision(self, b, d)

    def ApplyDecision(self, d: &#34;Decision&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Before applying the decision.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_ApplyDecision(self, d)

    def RefuteDecision(self, d: &#34;Decision&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Before refuting the decision.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_RefuteDecision(self, d)

    def AfterDecision(self, d: &#34;Decision&#34;, apply: &#34;bool&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Just after refuting or applying the decision, apply is true after Apply. This is called only if the Apply() or Refute() methods have not failed.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_AfterDecision(self, d, apply)

    def BeginFail(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Just when the failure occurs.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_BeginFail(self)

    def EndFail(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; After completing the backtrack.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_EndFail(self)

    def BeginInitialPropagation(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Before the initial propagation.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_BeginInitialPropagation(self)

    def EndInitialPropagation(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; After the initial propagation.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_EndInitialPropagation(self)

    def AcceptSolution(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; This method is called when a solution is found. It asserts whether the solution is valid. A value of false indicates that the solution should be discarded.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_AcceptSolution(self)

    def AtSolution(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; This method is called when a valid solution is found. If the return value is true, then search will resume after. If the result is false, then search will stop there.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_AtSolution(self)

    def NoMoreSolutions(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; When the search tree is finished.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_NoMoreSolutions(self)

    def LocalOptimum(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; When a local optimum is reached. If &#39;true&#39; is returned, the last solution is discarded and the search proceeds with the next one.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_LocalOptimum(self)

    def AcceptDelta(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.SearchMonitor_AcceptDelta(self, delta, deltadelta)

    def AcceptNeighbor(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; After accepting a neighbor during local search.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_AcceptNeighbor(self)

    def solver(self) -&gt; &#34;operations_research::Solver *&#34;:
        return _pywrapcp.SearchMonitor_solver(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SearchMonitor___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SearchMonitor___str__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_SearchMonitor(self)
        return weakref.proxy(self)

# Register SearchMonitor in _pywrapcp:
_pywrapcp.SearchMonitor_swigregister(SearchMonitor)

class IntExpr(PropagationBaseObject):
    r&#34;&#34;&#34; The class IntExpr is the base of all integer expressions in constraint programming. It contains the basic protocol for an expression:   - setting and modifying its bound   - querying if it is bound   - listening to events modifying its bounds   - casting it into a variable (instance of IntVar)&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)

    def Min(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntExpr_Min(self)

    def SetMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntExpr_SetMin(self, m)

    def Max(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntExpr_Max(self)

    def SetMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntExpr_SetMax(self, m)

    def SetRange(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method sets both the min and the max of the expression.&#34;&#34;&#34;
        return _pywrapcp.IntExpr_SetRange(self, l, u)

    def SetValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method sets the value of the expression.&#34;&#34;&#34;
        return _pywrapcp.IntExpr_SetValue(self, v)

    def Bound(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if the min and the max of the expression are equal.&#34;&#34;&#34;
        return _pywrapcp.IntExpr_Bound(self)

    def IsVar(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if the expression is indeed a variable.&#34;&#34;&#34;
        return _pywrapcp.IntExpr_IsVar(self)

    def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Creates a variable from the expression.&#34;&#34;&#34;
        return _pywrapcp.IntExpr_Var(self)

    def VarWithName(self, name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Creates a variable from the expression and set the name of the resulting var. If the expression is already a variable, then it will set the name of the expression, possibly overwriting it. This is just a shortcut to Var() followed by set_name().&#34;&#34;&#34;
        return _pywrapcp.IntExpr_VarWithName(self, name)

    def WhenRange(self, *args) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Attach a demon that will watch the min or the max of the expression.

        |

        *Overload 2:*
        Attach a demon that will watch the min or the max of the expression.
        &#34;&#34;&#34;
        return _pywrapcp.IntExpr_WhenRange(self, *args)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.IntExpr___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.IntExpr___str__(self)

    def __add__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___add__(self, *args)

    def __radd__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___radd__(self, v)

    def __sub__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___sub__(self, *args)

    def __rsub__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___rsub__(self, v)

    def __mul__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___mul__(self, *args)

    def __rmul__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___rmul__(self, v)

    def __floordiv__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___floordiv__(self, *args)

    def __mod__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___mod__(self, *args)

    def __neg__(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___neg__(self)

    def __abs__(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___abs__(self)

    def Square(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr_Square(self)

    def __eq__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr___eq__(self, *args)

    def __ne__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr___ne__(self, *args)

    def __ge__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr___ge__(self, *args)

    def __gt__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr___gt__(self, *args)

    def __le__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr___le__(self, *args)

    def __lt__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr___lt__(self, *args)

    def MapTo(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr_MapTo(self, vars)

    def IndexOf(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr_IndexOf(self, *args)

    def IsMember(self, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.IntExpr_IsMember(self, values)

    def Member(self, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr_Member(self, values)

    def NotMember(self, starts: &#34;std::vector&lt; int64 &gt; const &amp;&#34;, ends: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr_NotMember(self, starts, ends)

# Register IntExpr in _pywrapcp:
_pywrapcp.IntExpr_swigregister(IntExpr)

class IntVarIterator(BaseObject):
    r&#34;&#34;&#34; The class Iterator has two direct subclasses. HoleIterators iterates over all holes, that is value removed between the current min and max of the variable since the last time the variable was processed in the queue. DomainIterators iterates over all elements of the variable domain. Both iterators are not robust to domain changes. Hole iterators can also report values outside the current min and max of the variable. HoleIterators should only be called from a demon attached to the variable that has created this iterator. IntVar* current_var; std::unique_ptr&lt;IntVarIterator&gt; it(current_var-&gt;MakeHoleIterator(false)); for (const int64 hole : InitAndGetValues(it)) {   /// use the hole }&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def Init(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method must be called before each loop.&#34;&#34;&#34;
        return _pywrapcp.IntVarIterator_Init(self)

    def Ok(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; This method indicates if we can call Value() or not.&#34;&#34;&#34;
        return _pywrapcp.IntVarIterator_Ok(self)

    def Value(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This method returns the current value of the iterator.&#34;&#34;&#34;
        return _pywrapcp.IntVarIterator_Value(self)

    def Next(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method moves the iterator to the next value.&#34;&#34;&#34;
        return _pywrapcp.IntVarIterator_Next(self)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        r&#34;&#34;&#34; Pretty Print.&#34;&#34;&#34;
        return _pywrapcp.IntVarIterator_DebugString(self)

    def __iter__(self):
      self.Init()
      return self

    def next(self):
      if self.Ok():
        result = self.Value()
        self.Next()
        return result
      else:
        raise StopIteration()

    def __next__(self):
      return self.next()


# Register IntVarIterator in _pywrapcp:
_pywrapcp.IntVarIterator_swigregister(IntVarIterator)

class IntVar(IntExpr):
    r&#34;&#34;&#34; The class IntVar is a subset of IntExpr. In addition to the IntExpr protocol, it offers persistence, removing values from the domains, and a finer model for events.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)

    def IsVar(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVar_IsVar(self)

    def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.IntVar_Var(self)

    def Value(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This method returns the value of the variable. This method checks before that the variable is bound.&#34;&#34;&#34;
        return _pywrapcp.IntVar_Value(self)

    def RemoveValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method removes the value &#39;v&#39; from the domain of the variable.&#34;&#34;&#34;
        return _pywrapcp.IntVar_RemoveValue(self, v)

    def RemoveInterval(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method removes the interval &#39;l&#39; .. &#39;u&#39; from the domain of the variable. It assumes that &#39;l&#39; &lt;= &#39;u&#39;.&#34;&#34;&#34;
        return _pywrapcp.IntVar_RemoveInterval(self, l, u)

    def RemoveValues(self, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method remove the values from the domain of the variable.&#34;&#34;&#34;
        return _pywrapcp.IntVar_RemoveValues(self, values)

    def SetValues(self, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method intersects the current domain with the values in the array.&#34;&#34;&#34;
        return _pywrapcp.IntVar_SetValues(self, values)

    def WhenBound(self, *args) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This method attaches a demon that will be awakened when the variable is bound.

        |

        *Overload 2:*
        This method attaches a closure that will be awakened when the variable is bound.
        &#34;&#34;&#34;
        return _pywrapcp.IntVar_WhenBound(self, *args)

    def WhenDomain(self, *args) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This method attaches a demon that will watch any domain modification of the domain of the variable.

        |

        *Overload 2:*
        This method attaches a closure that will watch any domain modification of the domain of the variable.
        &#34;&#34;&#34;
        return _pywrapcp.IntVar_WhenDomain(self, *args)

    def Size(self) -&gt; &#34;uint64&#34;:
        r&#34;&#34;&#34; This method returns the number of values in the domain of the variable.&#34;&#34;&#34;
        return _pywrapcp.IntVar_Size(self)

    def Contains(self, v: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; This method returns whether the value &#39;v&#39; is in the domain of the variable.&#34;&#34;&#34;
        return _pywrapcp.IntVar_Contains(self, v)

    def HoleIteratorAux(self, reversible: &#34;bool&#34;) -&gt; &#34;operations_research::IntVarIterator *&#34;:
        r&#34;&#34;&#34; Creates a hole iterator. When &#39;reversible&#39; is false, the returned object is created on the normal C++ heap and the solver does NOT take ownership of the object.&#34;&#34;&#34;
        return _pywrapcp.IntVar_HoleIteratorAux(self, reversible)

    def DomainIteratorAux(self, reversible: &#34;bool&#34;) -&gt; &#34;operations_research::IntVarIterator *&#34;:
        r&#34;&#34;&#34; Creates a domain iterator. When &#39;reversible&#39; is false, the returned object is created on the normal C++ heap and the solver does NOT take ownership of the object.&#34;&#34;&#34;
        return _pywrapcp.IntVar_DomainIteratorAux(self, reversible)

    def OldMin(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the previous min.&#34;&#34;&#34;
        return _pywrapcp.IntVar_OldMin(self)

    def OldMax(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the previous max.&#34;&#34;&#34;
        return _pywrapcp.IntVar_OldMax(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.IntVar___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.IntVar___str__(self)

    def DomainIterator(self):
      return iter(self.DomainIteratorAux(False))

    def HoleIterator(self):
      return iter(self.HoleIteratorAux(False))


# Register IntVar in _pywrapcp:
_pywrapcp.IntVar_swigregister(IntVar)

class SolutionCollector(SearchMonitor):
    r&#34;&#34;&#34; This class is the root class of all solution collectors. It implements a basic query API to be used independently of the collector used.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SolutionCollector_DebugString(self)

    def Add(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.SolutionCollector_Add(self, *args)

    def AddObjective(self, objective: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SolutionCollector_AddObjective(self, objective)

    def EnterSearch(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Beginning of the search.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_EnterSearch(self)

    def SolutionCount(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns how many solutions were stored during the search.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_SolutionCount(self)

    def Solution(self, n: &#34;int&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34; Returns the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_Solution(self, n)

    def WallTime(self, n: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the wall time in ms for the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_WallTime(self, n)

    def Branches(self, n: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the number of branches when the nth solution was found.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_Branches(self, n)

    def Failures(self, n: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the number of failures encountered at the time of the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_Failures(self, n)

    def ObjectiveValue(self, n: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the objective value of the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_ObjectiveValue(self, n)

    def Value(self, n: &#34;int&#34;, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the Value of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_Value(self, n, var)

    def StartValue(self, n: &#34;int&#34;, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the StartValue of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_StartValue(self, n, var)

    def EndValue(self, n: &#34;int&#34;, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the EndValue of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_EndValue(self, n, var)

    def DurationValue(self, n: &#34;int&#34;, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the DurationValue of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_DurationValue(self, n, var)

    def PerformedValue(self, n: &#34;int&#34;, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the PerformedValue of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_PerformedValue(self, n, var)

    def ForwardSequence(self, n: &#34;int&#34;, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the ForwardSequence of &#39;var&#39; in the nth solution. The forward sequence is the list of ranked interval variables starting from the start of the sequence.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_ForwardSequence(self, n, var)

    def BackwardSequence(self, n: &#34;int&#34;, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the BackwardSequence of &#39;var&#39; in the nth solution. The backward sequence is the list of ranked interval variables starting from the end of the sequence.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_BackwardSequence(self, n, var)

    def Unperformed(self, n: &#34;int&#34;, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the list of unperformed of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_Unperformed(self, n, var)

# Register SolutionCollector in _pywrapcp:
_pywrapcp.SolutionCollector_swigregister(SolutionCollector)

class OptimizeVar(SearchMonitor):
    r&#34;&#34;&#34; This class encapsulates an objective. It requires the direction (minimize or maximize), the variable to optimize, and the improvement step.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Best(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the best value found during search.&#34;&#34;&#34;
        return _pywrapcp.OptimizeVar_Best(self)

    def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the variable that is optimized.&#34;&#34;&#34;
        return _pywrapcp.OptimizeVar_Var(self)

    def AcceptDelta(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Internal methods.&#34;&#34;&#34;
        return _pywrapcp.OptimizeVar_AcceptDelta(self, delta, deltadelta)

    def EnterSearch(self) -&gt; &#34;void&#34;:
        return _pywrapcp.OptimizeVar_EnterSearch(self)

    def BeginNextDecision(self, db: &#34;DecisionBuilder&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.OptimizeVar_BeginNextDecision(self, db)

    def RefuteDecision(self, d: &#34;Decision&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.OptimizeVar_RefuteDecision(self, d)

    def AtSolution(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.OptimizeVar_AtSolution(self)

    def AcceptSolution(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.OptimizeVar_AcceptSolution(self)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.OptimizeVar_DebugString(self)

# Register OptimizeVar in _pywrapcp:
_pywrapcp.OptimizeVar_swigregister(OptimizeVar)

class SearchLimit(SearchMonitor):
    r&#34;&#34;&#34; Base class of all search limits.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_SearchLimit

    def Crossed(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if the limit has been crossed.&#34;&#34;&#34;
        return _pywrapcp.SearchLimit_Crossed(self)

    def Check(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; This method is called to check the status of the limit. A return value of true indicates that we have indeed crossed the limit. In that case, this method will not be called again and the remaining search will be discarded.&#34;&#34;&#34;
        return _pywrapcp.SearchLimit_Check(self)

    def Init(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method is called when the search limit is initialized.&#34;&#34;&#34;
        return _pywrapcp.SearchLimit_Init(self)

    def EnterSearch(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Internal methods.&#34;&#34;&#34;
        return _pywrapcp.SearchLimit_EnterSearch(self)

    def BeginNextDecision(self, b: &#34;DecisionBuilder&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SearchLimit_BeginNextDecision(self, b)

    def RefuteDecision(self, d: &#34;Decision&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SearchLimit_RefuteDecision(self, d)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SearchLimit_DebugString(self)

# Register SearchLimit in _pywrapcp:
_pywrapcp.SearchLimit_swigregister(SearchLimit)

class IntervalVar(PropagationBaseObject):
    r&#34;&#34;&#34; Interval variables are often used in scheduling. The main characteristics of an IntervalVar are the start position, duration, and end date. All these characteristics can be queried and set, and demons can be posted on their modifications. An important aspect is optionality: an IntervalVar can be performed or not. If unperformed, then it simply does not exist, and its characteristics cannot be accessed any more. An interval var is automatically marked as unperformed when it is not consistent anymore (start greater than end, duration &lt; 0...)&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)

    def StartMin(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; These methods query, set, and watch the start position of the interval var.&#34;&#34;&#34;
        return _pywrapcp.IntervalVar_StartMin(self)

    def StartMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_StartMax(self)

    def SetStartMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetStartMin(self, m)

    def SetStartMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetStartMax(self, m)

    def SetStartRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetStartRange(self, mi, ma)

    def OldStartMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_OldStartMin(self)

    def OldStartMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_OldStartMax(self)

    def WhenStartRange(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenStartRange(self, *args)

    def WhenStartBound(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenStartBound(self, *args)

    def DurationMin(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; These methods query, set, and watch the duration of the interval var.&#34;&#34;&#34;
        return _pywrapcp.IntervalVar_DurationMin(self)

    def DurationMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_DurationMax(self)

    def SetDurationMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetDurationMin(self, m)

    def SetDurationMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetDurationMax(self, m)

    def SetDurationRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetDurationRange(self, mi, ma)

    def OldDurationMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_OldDurationMin(self)

    def OldDurationMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_OldDurationMax(self)

    def WhenDurationRange(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenDurationRange(self, *args)

    def WhenDurationBound(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenDurationBound(self, *args)

    def EndMin(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; These methods query, set, and watch the end position of the interval var.&#34;&#34;&#34;
        return _pywrapcp.IntervalVar_EndMin(self)

    def EndMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_EndMax(self)

    def SetEndMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetEndMin(self, m)

    def SetEndMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetEndMax(self, m)

    def SetEndRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetEndRange(self, mi, ma)

    def OldEndMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_OldEndMin(self)

    def OldEndMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_OldEndMax(self)

    def WhenEndRange(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenEndRange(self, *args)

    def WhenEndBound(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenEndBound(self, *args)

    def MustBePerformed(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; These methods query, set, and watch the performed status of the interval var.&#34;&#34;&#34;
        return _pywrapcp.IntervalVar_MustBePerformed(self)

    def MayBePerformed(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVar_MayBePerformed(self)

    def CannotBePerformed(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVar_CannotBePerformed(self)

    def IsPerformedBound(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVar_IsPerformedBound(self)

    def SetPerformed(self, val: &#34;bool&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetPerformed(self, val)

    def WasPerformedBound(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVar_WasPerformedBound(self)

    def WhenPerformedBound(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenPerformedBound(self, *args)

    def WhenAnything(self, *args) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Attaches a demon awakened when anything about this interval changes.

        |

        *Overload 2:*
        Attaches a closure awakened when anything about this interval changes.
        &#34;&#34;&#34;
        return _pywrapcp.IntervalVar_WhenAnything(self, *args)

    def StartExpr(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; These methods create expressions encapsulating the start, end and duration of the interval var. Please note that these must not be used if the interval var is unperformed.&#34;&#34;&#34;
        return _pywrapcp.IntervalVar_StartExpr(self)

    def DurationExpr(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntervalVar_DurationExpr(self)

    def EndExpr(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntervalVar_EndExpr(self)

    def PerformedExpr(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntervalVar_PerformedExpr(self)

    def SafeStartExpr(self, unperformed_value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; These methods create expressions encapsulating the start, end and duration of the interval var. If the interval var is unperformed, they will return the unperformed_value.&#34;&#34;&#34;
        return _pywrapcp.IntervalVar_SafeStartExpr(self, unperformed_value)

    def SafeDurationExpr(self, unperformed_value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntervalVar_SafeDurationExpr(self, unperformed_value)

    def SafeEndExpr(self, unperformed_value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntervalVar_SafeEndExpr(self, unperformed_value)

    def EndsAfterEnd(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAfterEnd(self, other)

    def EndsAfterEndWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAfterEndWithDelay(self, other, delay)

    def EndsAfterStart(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAfterStart(self, other)

    def EndsAfterStartWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAfterStartWithDelay(self, other, delay)

    def EndsAtEnd(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAtEnd(self, other)

    def EndsAtEndWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAtEndWithDelay(self, other, delay)

    def EndsAtStart(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAtStart(self, other)

    def EndsAtStartWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAtStartWithDelay(self, other, delay)

    def StartsAfterEnd(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAfterEnd(self, other)

    def StartsAfterEndWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAfterEndWithDelay(self, other, delay)

    def StartsAfterStart(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAfterStart(self, other)

    def StartsAfterStartWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAfterStartWithDelay(self, other, delay)

    def StartsAtEnd(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAtEnd(self, other)

    def StartsAtEndWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAtEndWithDelay(self, other, delay)

    def StartsAtStart(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAtStart(self, other)

    def StartsAtStartWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAtStartWithDelay(self, other, delay)

    def StaysInSync(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StaysInSync(self, other)

    def StaysInSyncWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StaysInSyncWithDelay(self, other, delay)

    def EndsAfter(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAfter(self, date)

    def EndsAt(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAt(self, date)

    def EndsBefore(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsBefore(self, date)

    def StartsAfter(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAfter(self, date)

    def StartsAt(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAt(self, date)

    def StartsBefore(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsBefore(self, date)

    def CrossesDate(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_CrossesDate(self, date)

    def AvoidsDate(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_AvoidsDate(self, date)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.IntervalVar___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.IntervalVar___str__(self)

# Register IntervalVar in _pywrapcp:
_pywrapcp.IntervalVar_swigregister(IntervalVar)

class SequenceVar(PropagationBaseObject):
    r&#34;&#34;&#34; A sequence variable is a variable whose domain is a set of possible orderings of the interval variables. It allows ordering of tasks. It has two sets of methods: ComputePossibleFirstsAndLasts(), which returns the list of interval variables that can be ranked first or last; and RankFirst/RankNotFirst/RankLast/RankNotLast, which can be used to create the search decision.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SequenceVar_DebugString(self)

    def RankFirst(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Ranks the index_th interval var first of all unranked interval vars. After that, it will no longer be considered ranked.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_RankFirst(self, index)

    def RankNotFirst(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Indicates that the index_th interval var will not be ranked first of all currently unranked interval vars.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_RankNotFirst(self, index)

    def RankLast(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Ranks the index_th interval var first of all unranked interval vars. After that, it will no longer be considered ranked.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_RankLast(self, index)

    def RankNotLast(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Indicates that the index_th interval var will not be ranked first of all currently unranked interval vars.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_RankNotLast(self, index)

    def Interval(self, index: &#34;int&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Returns the index_th interval of the sequence.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_Interval(self, index)

    def Next(self, index: &#34;int&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the next of the index_th interval of the sequence.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_Next(self, index)

    def Size(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the number of interval vars in the sequence.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_Size(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SequenceVar___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SequenceVar___str__(self)

# Register SequenceVar in _pywrapcp:
_pywrapcp.SequenceVar_swigregister(SequenceVar)

class AssignmentElement(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Activate(self) -&gt; &#34;void&#34;:
        return _pywrapcp.AssignmentElement_Activate(self)

    def Deactivate(self) -&gt; &#34;void&#34;:
        return _pywrapcp.AssignmentElement_Deactivate(self)

    def Activated(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.AssignmentElement_Activated(self)
    __swig_destroy__ = _pywrapcp.delete_AssignmentElement

# Register AssignmentElement in _pywrapcp:
_pywrapcp.AssignmentElement_swigregister(AssignmentElement)

class IntVarElement(AssignmentElement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.IntVarElement_Var(self)

    def Min(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntVarElement_Min(self)

    def SetMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarElement_SetMin(self, m)

    def Max(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntVarElement_Max(self)

    def SetMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarElement_SetMax(self, m)

    def Value(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntVarElement_Value(self)

    def Bound(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVarElement_Bound(self)

    def SetRange(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarElement_SetRange(self, l, u)

    def SetValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarElement_SetValue(self, v)

    def __eq__(self, element: &#34;IntVarElement&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVarElement___eq__(self, element)

    def __ne__(self, element: &#34;IntVarElement&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVarElement___ne__(self, element)
    __swig_destroy__ = _pywrapcp.delete_IntVarElement

# Register IntVarElement in _pywrapcp:
_pywrapcp.IntVarElement_swigregister(IntVarElement)

class IntervalVarElement(AssignmentElement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Var(self) -&gt; &#34;operations_research::IntervalVar *&#34;:
        return _pywrapcp.IntervalVarElement_Var(self)

    def StartMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_StartMin(self)

    def StartMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_StartMax(self)

    def StartValue(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_StartValue(self)

    def DurationMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_DurationMin(self)

    def DurationMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_DurationMax(self)

    def DurationValue(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_DurationValue(self)

    def EndMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_EndMin(self)

    def EndMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_EndMax(self)

    def EndValue(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_EndValue(self)

    def PerformedMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_PerformedMin(self)

    def PerformedMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_PerformedMax(self)

    def PerformedValue(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_PerformedValue(self)

    def SetStartMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetStartMin(self, m)

    def SetStartMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetStartMax(self, m)

    def SetStartRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetStartRange(self, mi, ma)

    def SetStartValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetStartValue(self, v)

    def SetDurationMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetDurationMin(self, m)

    def SetDurationMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetDurationMax(self, m)

    def SetDurationRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetDurationRange(self, mi, ma)

    def SetDurationValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetDurationValue(self, v)

    def SetEndMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetEndMin(self, m)

    def SetEndMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetEndMax(self, m)

    def SetEndRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetEndRange(self, mi, ma)

    def SetEndValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetEndValue(self, v)

    def SetPerformedMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetPerformedMin(self, m)

    def SetPerformedMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetPerformedMax(self, m)

    def SetPerformedRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetPerformedRange(self, mi, ma)

    def SetPerformedValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetPerformedValue(self, v)

    def __eq__(self, element: &#34;IntervalVarElement&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVarElement___eq__(self, element)

    def __ne__(self, element: &#34;IntervalVarElement&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVarElement___ne__(self, element)
    __swig_destroy__ = _pywrapcp.delete_IntervalVarElement

# Register IntervalVarElement in _pywrapcp:
_pywrapcp.IntervalVarElement_swigregister(IntervalVarElement)

class SequenceVarElement(AssignmentElement):
    r&#34;&#34;&#34; The SequenceVarElement stores a partial representation of ranked interval variables in the underlying sequence variable. This representation consists of three vectors:   - the forward sequence. That is the list of interval variables     ranked first in the sequence.  The first element of the backward     sequence is the first interval in the sequence variable.   - the backward sequence. That is the list of interval variables     ranked last in the sequence. The first element of the backward     sequence is the last interval in the sequence variable.   - The list of unperformed interval variables.  Furthermore, if all performed variables are ranked, then by  convention, the forward_sequence will contain all such variables  and the backward_sequence will be empty.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Var(self) -&gt; &#34;operations_research::SequenceVar *&#34;:
        return _pywrapcp.SequenceVarElement_Var(self)

    def ForwardSequence(self) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.SequenceVarElement_ForwardSequence(self)

    def BackwardSequence(self) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.SequenceVarElement_BackwardSequence(self)

    def Unperformed(self) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.SequenceVarElement_Unperformed(self)

    def SetSequence(self, forward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;, backward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;, unperformed: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarElement_SetSequence(self, forward_sequence, backward_sequence, unperformed)

    def SetForwardSequence(self, forward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarElement_SetForwardSequence(self, forward_sequence)

    def SetBackwardSequence(self, backward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarElement_SetBackwardSequence(self, backward_sequence)

    def SetUnperformed(self, unperformed: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarElement_SetUnperformed(self, unperformed)

    def __eq__(self, element: &#34;SequenceVarElement&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.SequenceVarElement___eq__(self, element)

    def __ne__(self, element: &#34;SequenceVarElement&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.SequenceVarElement___ne__(self, element)
    __swig_destroy__ = _pywrapcp.delete_SequenceVarElement

# Register SequenceVarElement in _pywrapcp:
_pywrapcp.SequenceVarElement_swigregister(SequenceVarElement)

class Assignment(PropagationBaseObject):
    r&#34;&#34;&#34; An Assignment is a variable -&gt; domains mapping, used to report solutions to the user.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Clear(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Clear(self)

    def Empty(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment_Empty(self)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.Assignment_Size(self)

    def NumIntVars(self) -&gt; &#34;int&#34;:
        return _pywrapcp.Assignment_NumIntVars(self)

    def NumIntervalVars(self) -&gt; &#34;int&#34;:
        return _pywrapcp.Assignment_NumIntervalVars(self)

    def NumSequenceVars(self) -&gt; &#34;int&#34;:
        return _pywrapcp.Assignment_NumSequenceVars(self)

    def Store(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Store(self)

    def Restore(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Restore(self)

    def Load(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Load(self, *args)

    def Save(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Save(self, *args)

    def AddObjective(self, v: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_AddObjective(self, v)

    def Objective(self) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.Assignment_Objective(self)

    def HasObjective(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment_HasObjective(self)

    def ObjectiveMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_ObjectiveMin(self)

    def ObjectiveMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_ObjectiveMax(self)

    def ObjectiveValue(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_ObjectiveValue(self)

    def ObjectiveBound(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment_ObjectiveBound(self)

    def SetObjectiveMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetObjectiveMin(self, m)

    def SetObjectiveMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetObjectiveMax(self, m)

    def SetObjectiveValue(self, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetObjectiveValue(self, value)

    def SetObjectiveRange(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetObjectiveRange(self, l, u)

    def Min(self, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_Min(self, var)

    def Max(self, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_Max(self, var)

    def Value(self, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_Value(self, var)

    def Bound(self, var: &#34;IntVar&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment_Bound(self, var)

    def SetMin(self, var: &#34;IntVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetMin(self, var, m)

    def SetMax(self, var: &#34;IntVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetMax(self, var, m)

    def SetRange(self, var: &#34;IntVar&#34;, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetRange(self, var, l, u)

    def SetValue(self, var: &#34;IntVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetValue(self, var, value)

    def StartMin(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_StartMin(self, var)

    def StartMax(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_StartMax(self, var)

    def StartValue(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_StartValue(self, var)

    def DurationMin(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_DurationMin(self, var)

    def DurationMax(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_DurationMax(self, var)

    def DurationValue(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_DurationValue(self, var)

    def EndMin(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_EndMin(self, var)

    def EndMax(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_EndMax(self, var)

    def EndValue(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_EndValue(self, var)

    def PerformedMin(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_PerformedMin(self, var)

    def PerformedMax(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_PerformedMax(self, var)

    def PerformedValue(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_PerformedValue(self, var)

    def SetStartMin(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetStartMin(self, var, m)

    def SetStartMax(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetStartMax(self, var, m)

    def SetStartRange(self, var: &#34;IntervalVar&#34;, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetStartRange(self, var, mi, ma)

    def SetStartValue(self, var: &#34;IntervalVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetStartValue(self, var, value)

    def SetDurationMin(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetDurationMin(self, var, m)

    def SetDurationMax(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetDurationMax(self, var, m)

    def SetDurationRange(self, var: &#34;IntervalVar&#34;, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetDurationRange(self, var, mi, ma)

    def SetDurationValue(self, var: &#34;IntervalVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetDurationValue(self, var, value)

    def SetEndMin(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetEndMin(self, var, m)

    def SetEndMax(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetEndMax(self, var, m)

    def SetEndRange(self, var: &#34;IntervalVar&#34;, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetEndRange(self, var, mi, ma)

    def SetEndValue(self, var: &#34;IntervalVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetEndValue(self, var, value)

    def SetPerformedMin(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetPerformedMin(self, var, m)

    def SetPerformedMax(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetPerformedMax(self, var, m)

    def SetPerformedRange(self, var: &#34;IntervalVar&#34;, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetPerformedRange(self, var, mi, ma)

    def SetPerformedValue(self, var: &#34;IntervalVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetPerformedValue(self, var, value)

    def Add(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Add(self, *args)

    def ForwardSequence(self, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.Assignment_ForwardSequence(self, var)

    def BackwardSequence(self, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.Assignment_BackwardSequence(self, var)

    def Unperformed(self, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.Assignment_Unperformed(self, var)

    def SetSequence(self, var: &#34;SequenceVar&#34;, forward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;, backward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;, unperformed: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetSequence(self, var, forward_sequence, backward_sequence, unperformed)

    def SetForwardSequence(self, var: &#34;SequenceVar&#34;, forward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetForwardSequence(self, var, forward_sequence)

    def SetBackwardSequence(self, var: &#34;SequenceVar&#34;, backward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetBackwardSequence(self, var, backward_sequence)

    def SetUnperformed(self, var: &#34;SequenceVar&#34;, unperformed: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetUnperformed(self, var, unperformed)

    def Activate(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Activate(self, *args)

    def Deactivate(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Deactivate(self, *args)

    def Activated(self, *args) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment_Activated(self, *args)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Assignment_DebugString(self)

    def IntVarContainer(self) -&gt; &#34;operations_research::Assignment::IntContainer const &amp;&#34;:
        return _pywrapcp.Assignment_IntVarContainer(self)

    def MutableIntVarContainer(self) -&gt; &#34;operations_research::Assignment::IntContainer *&#34;:
        return _pywrapcp.Assignment_MutableIntVarContainer(self)

    def IntervalVarContainer(self) -&gt; &#34;operations_research::Assignment::IntervalContainer const &amp;&#34;:
        return _pywrapcp.Assignment_IntervalVarContainer(self)

    def MutableIntervalVarContainer(self) -&gt; &#34;operations_research::Assignment::IntervalContainer *&#34;:
        return _pywrapcp.Assignment_MutableIntervalVarContainer(self)

    def SequenceVarContainer(self) -&gt; &#34;operations_research::Assignment::SequenceContainer const &amp;&#34;:
        return _pywrapcp.Assignment_SequenceVarContainer(self)

    def MutableSequenceVarContainer(self) -&gt; &#34;operations_research::Assignment::SequenceContainer *&#34;:
        return _pywrapcp.Assignment_MutableSequenceVarContainer(self)

    def __eq__(self, assignment: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment___eq__(self, assignment)

    def __ne__(self, assignment: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment___ne__(self, assignment)

# Register Assignment in _pywrapcp:
_pywrapcp.Assignment_swigregister(Assignment)


def __lshift__(*args) -&gt; &#34;std::ostream &amp;&#34;:
    return _pywrapcp.__lshift__(*args)
class Pack(Constraint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def AddWeightedSumLessOrEqualConstantDimension(self, *args) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Dimensions are additional constraints than can restrict what is possible with the pack constraint. It can be used to set capacity limits, to count objects per bin, to compute unassigned penalties... This dimension imposes that for all bins b, the weighted sum (weights[i]) of all objects i assigned to &#39;b&#39; is less or equal &#39;bounds[b]&#39;.

        |

        *Overload 2:*
        This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i)) of all objects i assigned to &#39;b&#39; is less or equal to &#39;bounds[b]&#39;. Ownership of the callback is transferred to the pack constraint.

        |

        *Overload 3:*
        This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i, b) of all objects i assigned to &#39;b&#39; is less or equal to &#39;bounds[b]&#39;. Ownership of the callback is transferred to the pack constraint.
        &#34;&#34;&#34;
        return _pywrapcp.Pack_AddWeightedSumLessOrEqualConstantDimension(self, *args)

    def AddWeightedSumEqualVarDimension(self, *args) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This dimension imposes that for all bins b, the weighted sum (weights[i]) of all objects i assigned to &#39;b&#39; is equal to loads[b].

        |

        *Overload 2:*
        This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i, b)) of all objects i assigned to &#39;b&#39; is equal to loads[b].
        &#34;&#34;&#34;
        return _pywrapcp.Pack_AddWeightedSumEqualVarDimension(self, *args)

    def AddSumVariableWeightsLessOrEqualConstantDimension(self, usage: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, capacity: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This dimension imposes: forall b in bins,    sum (i in items: usage[i] * is_assigned(i, b)) &lt;= capacity[b] where is_assigned(i, b) is true if and only if item i is assigned to the bin b. This can be used to model shapes of items by linking variables of the same item on parallel dimensions with an allowed assignment constraint.&#34;&#34;&#34;
        return _pywrapcp.Pack_AddSumVariableWeightsLessOrEqualConstantDimension(self, usage, capacity)

    def AddWeightedSumOfAssignedDimension(self, weights: &#34;std::vector&lt; int64 &gt; const &amp;&#34;, cost_var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This dimension enforces that cost_var == sum of weights[i] for all objects &#39;i&#39; assigned to a bin.&#34;&#34;&#34;
        return _pywrapcp.Pack_AddWeightedSumOfAssignedDimension(self, weights, cost_var)

    def AddCountUsedBinDimension(self, count_var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This dimension links &#39;count_var&#39; to the actual number of bins used in the pack.&#34;&#34;&#34;
        return _pywrapcp.Pack_AddCountUsedBinDimension(self, count_var)

    def AddCountAssignedItemsDimension(self, count_var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This dimension links &#39;count_var&#39; to the actual number of items assigned to a bin in the pack.&#34;&#34;&#34;
        return _pywrapcp.Pack_AddCountAssignedItemsDimension(self, count_var)

    def Post(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Pack_Post(self)

    def InitialPropagateWrapper(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Pack_InitialPropagateWrapper(self)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Pack_DebugString(self)

# Register Pack in _pywrapcp:
_pywrapcp.Pack_swigregister(Pack)

class DisjunctiveConstraint(Constraint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def SequenceVar(self) -&gt; &#34;operations_research::SequenceVar *&#34;:
        r&#34;&#34;&#34; Creates a sequence variable from the constraint.&#34;&#34;&#34;
        return _pywrapcp.DisjunctiveConstraint_SequenceVar(self)

    def SetTransitionTime(self, transition_time: &#34;operations_research::Solver::IndexEvaluator2&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Add a transition time between intervals.  It forces the distance between the end of interval a and start of interval b that follows it to be at least transition_time(a, b). This function must always return a positive or null value.&#34;&#34;&#34;
        return _pywrapcp.DisjunctiveConstraint_SetTransitionTime(self, transition_time)

    def TransitionTime(self, before_index: &#34;int&#34;, after_index: &#34;int&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.DisjunctiveConstraint_TransitionTime(self, before_index, after_index)

# Register DisjunctiveConstraint in _pywrapcp:
_pywrapcp.DisjunctiveConstraint_swigregister(DisjunctiveConstraint)

class RevInteger(object):
    r&#34;&#34;&#34; This class adds reversibility to a POD type. It contains the stamp optimization. i.e. the SaveValue call is done only once per node of the search tree.  Please note that actual stamps always starts at 1, thus an initial value of 0 will always trigger the first SaveValue.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, val: &#34;long const &amp;&#34;):
        _pywrapcp.RevInteger_swiginit(self, _pywrapcp.new_RevInteger(val))

    def Value(self) -&gt; &#34;long const &amp;&#34;:
        return _pywrapcp.RevInteger_Value(self)

    def SetValue(self, s: &#34;Solver&#34;, val: &#34;long const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RevInteger_SetValue(self, s, val)
    __swig_destroy__ = _pywrapcp.delete_RevInteger

# Register RevInteger in _pywrapcp:
_pywrapcp.RevInteger_swigregister(RevInteger)

class NumericalRevInteger(RevInteger):
    r&#34;&#34;&#34; Subclass of Rev&lt;T&gt; which adds numerical operations.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, val: &#34;long const &amp;&#34;):
        _pywrapcp.NumericalRevInteger_swiginit(self, _pywrapcp.new_NumericalRevInteger(val))

    def Add(self, s: &#34;Solver&#34;, to_add: &#34;long const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.NumericalRevInteger_Add(self, s, to_add)

    def Incr(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.NumericalRevInteger_Incr(self, s)

    def Decr(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.NumericalRevInteger_Decr(self, s)
    __swig_destroy__ = _pywrapcp.delete_NumericalRevInteger

# Register NumericalRevInteger in _pywrapcp:
_pywrapcp.NumericalRevInteger_swigregister(NumericalRevInteger)

class RevBool(object):
    r&#34;&#34;&#34; This class adds reversibility to a POD type. It contains the stamp optimization. i.e. the SaveValue call is done only once per node of the search tree.  Please note that actual stamps always starts at 1, thus an initial value of 0 will always trigger the first SaveValue.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, val: &#34;bool const &amp;&#34;):
        _pywrapcp.RevBool_swiginit(self, _pywrapcp.new_RevBool(val))

    def Value(self) -&gt; &#34;bool const &amp;&#34;:
        return _pywrapcp.RevBool_Value(self)

    def SetValue(self, s: &#34;Solver&#34;, val: &#34;bool const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RevBool_SetValue(self, s, val)
    __swig_destroy__ = _pywrapcp.delete_RevBool

# Register RevBool in _pywrapcp:
_pywrapcp.RevBool_swigregister(RevBool)

class IntVarContainer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Contains(self, var: &#34;IntVar&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVarContainer_Contains(self, var)

    def Element(self, index: &#34;int&#34;) -&gt; &#34;operations_research::IntVarElement *&#34;:
        return _pywrapcp.IntVarContainer_Element(self, index)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.IntVarContainer_Size(self)

    def Store(self) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarContainer_Store(self)

    def Restore(self) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarContainer_Restore(self)

    def __eq__(self, container: &#34;IntVarContainer&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if this and &#39;container&#39; both represent the same V* -&gt; E map. Runs in linear time; requires that the == operator on the type E is well defined.&#34;&#34;&#34;
        return _pywrapcp.IntVarContainer___eq__(self, container)

    def __ne__(self, container: &#34;IntVarContainer&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVarContainer___ne__(self, container)
    __swig_destroy__ = _pywrapcp.delete_IntVarContainer

# Register IntVarContainer in _pywrapcp:
_pywrapcp.IntVarContainer_swigregister(IntVarContainer)

class IntervalVarContainer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Contains(self, var: &#34;IntervalVar&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVarContainer_Contains(self, var)

    def Element(self, index: &#34;int&#34;) -&gt; &#34;operations_research::IntervalVarElement *&#34;:
        return _pywrapcp.IntervalVarContainer_Element(self, index)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.IntervalVarContainer_Size(self)

    def Store(self) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarContainer_Store(self)

    def Restore(self) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarContainer_Restore(self)

    def __eq__(self, container: &#34;IntervalVarContainer&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if this and &#39;container&#39; both represent the same V* -&gt; E map. Runs in linear time; requires that the == operator on the type E is well defined.&#34;&#34;&#34;
        return _pywrapcp.IntervalVarContainer___eq__(self, container)

    def __ne__(self, container: &#34;IntervalVarContainer&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVarContainer___ne__(self, container)
    __swig_destroy__ = _pywrapcp.delete_IntervalVarContainer

# Register IntervalVarContainer in _pywrapcp:
_pywrapcp.IntervalVarContainer_swigregister(IntervalVarContainer)

class SequenceVarContainer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Contains(self, var: &#34;SequenceVar&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.SequenceVarContainer_Contains(self, var)

    def Element(self, index: &#34;int&#34;) -&gt; &#34;operations_research::SequenceVarElement *&#34;:
        return _pywrapcp.SequenceVarContainer_Element(self, index)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.SequenceVarContainer_Size(self)

    def Store(self) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarContainer_Store(self)

    def Restore(self) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarContainer_Restore(self)

    def __eq__(self, container: &#34;SequenceVarContainer&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if this and &#39;container&#39; both represent the same V* -&gt; E map. Runs in linear time; requires that the == operator on the type E is well defined.&#34;&#34;&#34;
        return _pywrapcp.SequenceVarContainer___eq__(self, container)

    def __ne__(self, container: &#34;SequenceVarContainer&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.SequenceVarContainer___ne__(self, container)
    __swig_destroy__ = _pywrapcp.delete_SequenceVarContainer

# Register SequenceVarContainer in _pywrapcp:
_pywrapcp.SequenceVarContainer_swigregister(SequenceVarContainer)

class LocalSearchOperator(BaseObject):
    r&#34;&#34;&#34; This class represent a reversible FIFO structure. The main difference w.r.t a standard FIFO structure is that a Solver is given as parameter to the modifiers such that the solver can store the backtrack information Iterator&#39;s traversing order should not be changed, as some algorithm depend on it to be consistent. It&#39;s main use is to store a list of demons in the various classes of variables. The base class for all local search operators. A local search operator is an object that defines the neighborhood of a solution. In other words, a neighborhood is the set of solutions which can be reached from a given solution using an operator. The behavior of the LocalSearchOperator class is similar to iterators. The operator is synchronized with an assignment (gives the current values of the variables); this is done in the Start() method. Then one can iterate over the neighbors using the MakeNextNeighbor method. This method returns an assignment which represents the incremental changes to the current solution. It also returns a second assignment representing the changes to the last solution defined by the neighborhood operator; this assignment is empty if the neighborhood operator cannot track this information.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def NextNeighbor(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.LocalSearchOperator_NextNeighbor(self, delta, deltadelta)

    def Start(self, assignment: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.LocalSearchOperator_Start(self, assignment)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_LocalSearchOperator(self)
        return weakref.proxy(self)

# Register LocalSearchOperator in _pywrapcp:
_pywrapcp.LocalSearchOperator_swigregister(LocalSearchOperator)

class IntVarLocalSearchOperatorTemplate(LocalSearchOperator):
    r&#34;&#34;&#34; Base operator class for operators manipulating variables.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def Start(self, assignment: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method should not be overridden. Override OnStart() instead which is called before exiting this method.&#34;&#34;&#34;
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_Start(self, assignment)

    def IsIncremental(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_IsIncremental(self)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_Size(self)

    def Value(self, index: &#34;int64&#34;) -&gt; &#34;long const &amp;&#34;:
        r&#34;&#34;&#34; Returns the value in the current assignment of the variable of given index.&#34;&#34;&#34;
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_Value(self, index)

    def OldValue(self, index: &#34;int64&#34;) -&gt; &#34;long const &amp;&#34;:
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_OldValue(self, index)

    def SetValue(self, index: &#34;int64&#34;, value: &#34;long const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_SetValue(self, index, value)

    def OnStart(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Called by Start() after synchronizing the operator with the current assignment. Should be overridden instead of Start() to avoid calling VarLocalSearchOperator::Start explicitly.&#34;&#34;&#34;
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_OnStart(self)

# Register IntVarLocalSearchOperatorTemplate in _pywrapcp:
_pywrapcp.IntVarLocalSearchOperatorTemplate_swigregister(IntVarLocalSearchOperatorTemplate)

class IntVarLocalSearchOperator(IntVarLocalSearchOperatorTemplate):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, *args):
        if self.__class__ == IntVarLocalSearchOperator:
            _self = None
        else:
            _self = self
        _pywrapcp.IntVarLocalSearchOperator_swiginit(self, _pywrapcp.new_IntVarLocalSearchOperator(_self, *args))
    __swig_destroy__ = _pywrapcp.delete_IntVarLocalSearchOperator

    def NextNeighbor(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Redefines MakeNextNeighbor to export a simpler interface. The calls to ApplyChanges() and RevertChanges() are factored in this method, hiding both delta and deltadelta from subclasses which only need to override MakeOneNeighbor(). Therefore this method should not be overridden. Override MakeOneNeighbor() instead.&#34;&#34;&#34;
        return _pywrapcp.IntVarLocalSearchOperator_NextNeighbor(self, delta, deltadelta)

    def OneNeighbor(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Creates a new neighbor. It returns false when the neighborhood is completely explored. MakeNextNeighbor() in a subclass of IntVarLocalSearchOperator.&#34;&#34;&#34;
        return _pywrapcp.IntVarLocalSearchOperator_OneNeighbor(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_IntVarLocalSearchOperator(self)
        return weakref.proxy(self)

# Register IntVarLocalSearchOperator in _pywrapcp:
_pywrapcp.IntVarLocalSearchOperator_swigregister(IntVarLocalSearchOperator)

class SequenceVarLocalSearchOperatorTemplate(LocalSearchOperator):
    r&#34;&#34;&#34; Base operator class for operators manipulating variables.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def Start(self, assignment: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method should not be overridden. Override OnStart() instead which is called before exiting this method.&#34;&#34;&#34;
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_Start(self, assignment)

    def IsIncremental(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_IsIncremental(self)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_Size(self)

    def Value(self, index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns the value in the current assignment of the variable of given index.&#34;&#34;&#34;
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_Value(self, index)

    def OldValue(self, index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_OldValue(self, index)

    def SetValue(self, index: &#34;int64&#34;, value: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_SetValue(self, index, value)

    def OnStart(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Called by Start() after synchronizing the operator with the current assignment. Should be overridden instead of Start() to avoid calling VarLocalSearchOperator::Start explicitly.&#34;&#34;&#34;
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_OnStart(self)

# Register SequenceVarLocalSearchOperatorTemplate in _pywrapcp:
_pywrapcp.SequenceVarLocalSearchOperatorTemplate_swigregister(SequenceVarLocalSearchOperatorTemplate)

class SequenceVarLocalSearchOperator(SequenceVarLocalSearchOperatorTemplate):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

# Register SequenceVarLocalSearchOperator in _pywrapcp:
_pywrapcp.SequenceVarLocalSearchOperator_swigregister(SequenceVarLocalSearchOperator)

class BaseLns(IntVarLocalSearchOperator):
    r&#34;&#34;&#34; This is the base class for building an Lns operator. An Lns fragment is a collection of variables which will be relaxed. Fragments are built with NextFragment(), which returns false if there are no more fragments to build. Optionally one can override InitFragments, which is called from LocalSearchOperator::Start to initialize fragment data. Here&#39;s a sample relaxing one variable at a time: class OneVarLns : public BaseLns {  public:   OneVarLns(const std::vector&lt;IntVar*&gt;&amp; vars) : BaseLns(vars), index_(0) {}   virtual ~OneVarLns() {}   virtual void InitFragments() { index_ = 0; }   virtual bool NextFragment() {     const int size = Size();     if (index_ &lt; size) {       AppendToFragment(index_);       ++index_;       return true;     } else {       return false;     }   }  private:   int index_; };&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;):
        if self.__class__ == BaseLns:
            _self = None
        else:
            _self = self
        _pywrapcp.BaseLns_swiginit(self, _pywrapcp.new_BaseLns(_self, vars))
    __swig_destroy__ = _pywrapcp.delete_BaseLns

    def InitFragments(self) -&gt; &#34;void&#34;:
        return _pywrapcp.BaseLns_InitFragments(self)

    def NextFragment(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.BaseLns_NextFragment(self)

    def AppendToFragment(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BaseLns_AppendToFragment(self, index)

    def FragmentSize(self) -&gt; &#34;int&#34;:
        return _pywrapcp.BaseLns_FragmentSize(self)

    def __getitem__(self, index: &#34;int&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.BaseLns___getitem__(self, index)

    def __len__(self) -&gt; &#34;int&#34;:
        return _pywrapcp.BaseLns___len__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_BaseLns(self)
        return weakref.proxy(self)

# Register BaseLns in _pywrapcp:
_pywrapcp.BaseLns_swigregister(BaseLns)

class ChangeValue(IntVarLocalSearchOperator):
    r&#34;&#34;&#34; Defines operators which change the value of variables; each neighbor corresponds to *one* modified variable. Sub-classes have to define ModifyValue which determines what the new variable value is going to be (given the current value and the variable).&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;):
        if self.__class__ == ChangeValue:
            _self = None
        else:
            _self = self
        _pywrapcp.ChangeValue_swiginit(self, _pywrapcp.new_ChangeValue(_self, vars))
    __swig_destroy__ = _pywrapcp.delete_ChangeValue

    def ModifyValue(self, index: &#34;int64&#34;, value: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.ChangeValue_ModifyValue(self, index, value)

    def OneNeighbor(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; This method should not be overridden. Override ModifyValue() instead.&#34;&#34;&#34;
        return _pywrapcp.ChangeValue_OneNeighbor(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_ChangeValue(self)
        return weakref.proxy(self)

# Register ChangeValue in _pywrapcp:
_pywrapcp.ChangeValue_swigregister(ChangeValue)

class PathOperator(IntVarLocalSearchOperator):
    r&#34;&#34;&#34; Base class of the local search operators dedicated to path modifications (a path is a set of nodes linked together by arcs). This family of neighborhoods supposes they are handling next variables representing the arcs (var[i] represents the node immediately after i on a path). Several services are provided: - arc manipulators (SetNext(), ReverseChain(), MoveChain()) - path inspectors (Next(), Prev(), IsPathEnd()) - path iterators: operators need a given number of nodes to define a   neighbor; this class provides the iteration on a given number of (base)   nodes which can be used to define a neighbor (through the BaseNode method) Subclasses only need to override MakeNeighbor to create neighbors using the services above (no direct manipulation of assignments).&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def Neighbor(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.PathOperator_Neighbor(self)

# Register PathOperator in _pywrapcp:
_pywrapcp.PathOperator_swigregister(PathOperator)

class LocalSearchFilter(BaseObject):
    r&#34;&#34;&#34; Local Search Filters are used for fast neighbor pruning. Filtering a move is done in several phases: - in the Relax phase, filters determine which parts of their internals   will be changed by the candidate, and modify intermediary State - in the Accept phase, filters check that the candidate is feasible, - if the Accept phase succeeds, the solver may decide to trigger a   Synchronize phase that makes filters change their internal representation   to the last candidate, - otherwise (Accept fails or the solver does not want to synchronize),   a Revert phase makes filters erase any intermediary State generated by the   Relax and Accept phases. A given filter has phases called with the following pattern: (Relax.Accept.Synchronize | Relax.Accept.Revert | Relax.Revert)*. Filters&#39;s Revert() is always called in the reverse order their Accept() was called, to allow late filters to use state done/undone by early filters&#39; Accept()/Revert().&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def Accept(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;, objective_min: &#34;int64&#34;, objective_max: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Accepts a &#34;delta&#34; given the assignment with which the filter has been synchronized; the delta holds the variables which have been modified and their new value. If the filter represents a part of the global objective, its contribution must be between objective_min and objective_max. Sample: supposing one wants to maintain a[0,1] + b[0,1] &lt;= 1, for the assignment (a,1), (b,0), the delta (b,1) will be rejected but the delta (a,0) will be accepted. TODO(user): Remove arguments when there are no more need for those.&#34;&#34;&#34;
        return _pywrapcp.LocalSearchFilter_Accept(self, delta, deltadelta, objective_min, objective_max)

    def IsIncremental(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.LocalSearchFilter_IsIncremental(self)

    def Synchronize(self, assignment: &#34;Assignment&#34;, delta: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Synchronizes the filter with the current solution, delta being the difference with the solution passed to the previous call to Synchronize() or IncrementalSynchronize(). &#39;delta&#39; can be used to incrementally synchronizing the filter with the new solution by only considering the changes in delta.&#34;&#34;&#34;
        return _pywrapcp.LocalSearchFilter_Synchronize(self, assignment, delta)
    __swig_destroy__ = _pywrapcp.delete_LocalSearchFilter

# Register LocalSearchFilter in _pywrapcp:
_pywrapcp.LocalSearchFilter_swigregister(LocalSearchFilter)

class IntVarLocalSearchFilter(LocalSearchFilter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;):
        if self.__class__ == IntVarLocalSearchFilter:
            _self = None
        else:
            _self = self
        _pywrapcp.IntVarLocalSearchFilter_swiginit(self, _pywrapcp.new_IntVarLocalSearchFilter(_self, vars))
    __swig_destroy__ = _pywrapcp.delete_IntVarLocalSearchFilter

    def Synchronize(self, assignment: &#34;Assignment&#34;, delta: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method should not be overridden. Override OnSynchronize() instead which is called before exiting this method.&#34;&#34;&#34;
        return _pywrapcp.IntVarLocalSearchFilter_Synchronize(self, assignment, delta)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.IntVarLocalSearchFilter_Size(self)

    def Value(self, index: &#34;int&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntVarLocalSearchFilter_Value(self, index)

    def IndexFromVar(self, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntVarLocalSearchFilter_IndexFromVar(self, var)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_IntVarLocalSearchFilter(self)
        return weakref.proxy(self)

# Register IntVarLocalSearchFilter in _pywrapcp:
_pywrapcp.IntVarLocalSearchFilter_swigregister(IntVarLocalSearchFilter)

class BooleanVar(IntVar):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def Min(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.BooleanVar_Min(self)

    def SetMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_SetMin(self, m)

    def Max(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.BooleanVar_Max(self)

    def SetMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_SetMax(self, m)

    def SetRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_SetRange(self, mi, ma)

    def Bound(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.BooleanVar_Bound(self)

    def Value(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.BooleanVar_Value(self)

    def RemoveValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_RemoveValue(self, v)

    def RemoveInterval(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_RemoveInterval(self, l, u)

    def WhenBound(self, d: &#34;Demon&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_WhenBound(self, d)

    def WhenRange(self, d: &#34;Demon&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_WhenRange(self, d)

    def WhenDomain(self, d: &#34;Demon&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_WhenDomain(self, d)

    def Size(self) -&gt; &#34;uint64&#34;:
        return _pywrapcp.BooleanVar_Size(self)

    def Contains(self, v: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.BooleanVar_Contains(self, v)

    def HoleIteratorAux(self, reversible: &#34;bool&#34;) -&gt; &#34;operations_research::IntVarIterator *&#34;:
        return _pywrapcp.BooleanVar_HoleIteratorAux(self, reversible)

    def DomainIteratorAux(self, reversible: &#34;bool&#34;) -&gt; &#34;operations_research::IntVarIterator *&#34;:
        return _pywrapcp.BooleanVar_DomainIteratorAux(self, reversible)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.BooleanVar_DebugString(self)

# Register BooleanVar in _pywrapcp:
_pywrapcp.BooleanVar_swigregister(BooleanVar)


class PyDecision(Decision):

  def __init__(self):
    Decision.__init__(self)

  def ApplyWrapper(self, solver):
    try:
       self.Apply(solver)
    except Exception as e:
      if &#39;CP Solver fail&#39; in str(e):
        solver.ShouldFail()
      else:
        raise

  def RefuteWrapper(self, solver):
    try:
       self.Refute(solver)
    except Exception as e:
      if &#39;CP Solver fail&#39; in str(e):
        solver.ShouldFail()
      else:
        raise

  def DebugString(self):
    return &#34;PyDecision&#34;


class PyDecisionBuilder(DecisionBuilder):

  def __init__(self):
    DecisionBuilder.__init__(self)

  def NextWrapper(self, solver):
    try:
      return self.Next(solver)
    except Exception as e:
      if &#39;CP Solver fail&#39; in str(e):
        return solver.FailDecision()
      else:
        raise

  def DebugString(self):
    return &#34;PyDecisionBuilder&#34;


class PyDemon(Demon):

  def RunWrapper(self, solver):
    try:
      self.Run(solver)
    except Exception as e:
      if &#39;CP Solver fail&#39; in str(e):
        solver.ShouldFail()
      else:
        raise

  def DebugString(self):
    return &#34;PyDemon&#34;


class PyConstraintDemon(PyDemon):

  def __init__(self, ct, method, delayed, *args):
    PyDemon.__init__(self)
    self.__constraint = ct
    self.__method = method
    self.__delayed = delayed
    self.__args = args

  def Run(self, solver):
    self.__method(self.__constraint, *self.__args)

  def Priority(self):
    return Solver.DELAYED_PRIORITY if self.__delayed else Solver.NORMAL_PRIORITY

  def DebugString(self):
    return &#39;PyConstraintDemon&#39;


class PyConstraint(Constraint):

  def __init__(self, solver):
    Constraint.__init__(self, solver)
    self.__demons = []

  def Demon(self, method, *args):
    demon = PyConstraintDemon(self, method, False, *args)
    self.__demons.append(demon)
    return demon

  def DelayedDemon(self, method, *args):
    demon = PyConstraintDemon(self, method, True, *args)
    self.__demons.append(demon)
    return demon

  def InitialPropagateDemon(self):
    return self.solver().ConstraintInitialPropagateCallback(self)

  def DelayedInitialPropagateDemon(self):
    return self.solver().DelayedConstraintInitialPropagateCallback(self)

  def InitialPropagateWrapper(self):
    try:
      self.InitialPropagate()
    except Exception as e:
      if &#39;CP Solver fail&#39; in str(e):
        self.solver().ShouldFail()
      else:
        raise

  def DebugString(self):
    return &#34;PyConstraint&#34;



class RoutingIndexManager(object):
    r&#34;&#34;&#34; Manager for any NodeIndex &lt;-&gt; variable index conversion. The routing solver uses variable indices internally and through its API. These variable indices are tricky to manage directly because one Node can correspond to a multitude of variables, depending on the number of times they appear in the model, and if they&#39;re used as start and/or end points. This class aims to simplify variable index usage, allowing users to use NodeIndex instead. Usage:   .cpp}   auto starts_ends = ...;  /// These are NodeIndex.   RoutingIndexManager manager(10, 4, starts_ends);  // 10 nodes, 4 vehicles.   RoutingModel model(manager);&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pywrapcp.RoutingIndexManager_swiginit(self, _pywrapcp.new_RoutingIndexManager(*args))
    __swig_destroy__ = _pywrapcp.delete_RoutingIndexManager

    def GetNumberOfNodes(self) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingIndexManager_GetNumberOfNodes(self)

    def GetNumberOfVehicles(self) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingIndexManager_GetNumberOfVehicles(self)

    def GetNumberOfIndices(self) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingIndexManager_GetNumberOfIndices(self)

    def NodeToIndex(self, node: &#34;operations_research::RoutingIndexManager::NodeIndex&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingIndexManager_NodeToIndex(self, node)

    def IndexToNode(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::RoutingIndexManager::NodeIndex&#34;:
        return _pywrapcp.RoutingIndexManager_IndexToNode(self, index)

# Register RoutingIndexManager in _pywrapcp:
_pywrapcp.RoutingIndexManager_swigregister(RoutingIndexManager)


def DefaultRoutingModelParameters() -&gt; &#34;operations_research::RoutingModelParameters&#34;:
    return _pywrapcp.DefaultRoutingModelParameters()

def DefaultRoutingSearchParameters() -&gt; &#34;operations_research::RoutingSearchParameters&#34;:
    return _pywrapcp.DefaultRoutingSearchParameters()

def FindErrorInRoutingSearchParameters(search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;) -&gt; &#34;std::string&#34;:
    r&#34;&#34;&#34; Returns an empty std::string if the routing search parameters are valid, and a non-empty, human readable error description if they&#39;re not.&#34;&#34;&#34;
    return _pywrapcp.FindErrorInRoutingSearchParameters(search_parameters)
BOOL_UNSPECIFIED = _pywrapcp.BOOL_UNSPECIFIED
BOOL_FALSE = _pywrapcp.BOOL_FALSE
BOOL_TRUE = _pywrapcp.BOOL_TRUE
class RoutingModel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr
    ROUTING_NOT_SOLVED = _pywrapcp.RoutingModel_ROUTING_NOT_SOLVED
    r&#34;&#34;&#34; Problem not solved yet (before calling RoutingModel::Solve()).&#34;&#34;&#34;
    ROUTING_SUCCESS = _pywrapcp.RoutingModel_ROUTING_SUCCESS
    r&#34;&#34;&#34; Problem solved successfully after calling RoutingModel::Solve().&#34;&#34;&#34;
    ROUTING_FAIL = _pywrapcp.RoutingModel_ROUTING_FAIL
    r&#34;&#34;&#34; No solution found to the problem after calling RoutingModel::Solve().&#34;&#34;&#34;
    ROUTING_FAIL_TIMEOUT = _pywrapcp.RoutingModel_ROUTING_FAIL_TIMEOUT
    r&#34;&#34;&#34; Time limit reached before finding a solution with RoutingModel::Solve().&#34;&#34;&#34;
    ROUTING_INVALID = _pywrapcp.RoutingModel_ROUTING_INVALID
    r&#34;&#34;&#34; Model, model parameters or flags are not valid.&#34;&#34;&#34;
    PICKUP_AND_DELIVERY_NO_ORDER = _pywrapcp.RoutingModel_PICKUP_AND_DELIVERY_NO_ORDER
    r&#34;&#34;&#34; Any precedence is accepted.&#34;&#34;&#34;
    PICKUP_AND_DELIVERY_LIFO = _pywrapcp.RoutingModel_PICKUP_AND_DELIVERY_LIFO
    r&#34;&#34;&#34; Deliveries must be performed in reverse order of pickups.&#34;&#34;&#34;
    PICKUP_AND_DELIVERY_FIFO = _pywrapcp.RoutingModel_PICKUP_AND_DELIVERY_FIFO
    r&#34;&#34;&#34; Deliveries must be performed in the same order as pickups.&#34;&#34;&#34;

    def __init__(self, *args):
        _pywrapcp.RoutingModel_swiginit(self, _pywrapcp.new_RoutingModel(*args))
    __swig_destroy__ = _pywrapcp.delete_RoutingModel

    def RegisterUnaryTransitCallback(self, callback: &#34;operations_research::RoutingModel::TransitCallback1&#34;) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Registers &#39;callback&#39; and returns its index.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_RegisterUnaryTransitCallback(self, callback)

    def RegisterPositiveUnaryTransitCallback(self, callback: &#34;operations_research::RoutingModel::TransitCallback1&#34;) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingModel_RegisterPositiveUnaryTransitCallback(self, callback)

    def RegisterTransitCallback(self, callback: &#34;operations_research::RoutingModel::TransitCallback2&#34;) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingModel_RegisterTransitCallback(self, callback)

    def RegisterPositiveTransitCallback(self, callback: &#34;operations_research::RoutingModel::TransitCallback2&#34;) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingModel_RegisterPositiveTransitCallback(self, callback)

    def TransitCallback(self, callback_index: &#34;int&#34;) -&gt; &#34;operations_research::RoutingModel::TransitCallback2 const &amp;&#34;:
        return _pywrapcp.RoutingModel_TransitCallback(self, callback_index)

    def UnaryTransitCallbackOrNull(self, callback_index: &#34;int&#34;) -&gt; &#34;operations_research::RoutingModel::TransitCallback1 const &amp;&#34;:
        return _pywrapcp.RoutingModel_UnaryTransitCallbackOrNull(self, callback_index)

    def AddDimension(self, evaluator_index: &#34;int&#34;, slack_max: &#34;int64&#34;, capacity: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Model creation Methods to add dimensions to routes; dimensions represent quantities accumulated at nodes along the routes. They represent quantities such as weights or volumes carried along the route, or distance or times. Quantities at a node are represented by &#34;cumul&#34; variables and the increase or decrease of quantities between nodes are represented by &#34;transit&#34; variables. These variables are linked as follows: if j == next(i), cumul(j) = cumul(i) + transit(i) + slack(i) where slack is a positive slack variable (can represent waiting times for a time dimension). Setting the value of fix_start_cumul_to_zero to true will force the &#34;cumul&#34; variable of the start node of all vehicles to be equal to 0. Creates a dimension where the transit variable is constrained to be equal to evaluator(i, next(i)); &#39;slack_max&#39; is the upper bound of the slack variable and &#39;capacity&#39; is the upper bound of the cumul variables. &#39;name&#39; is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn&#39;t create the new dimension). Takes ownership of the callback &#39;evaluator&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddDimension(self, evaluator_index, slack_max, capacity, fix_start_cumul_to_zero, name)

    def AddDimensionWithVehicleTransits(self, evaluator_indices: &#34;std::vector&lt; int &gt; const &amp;&#34;, slack_max: &#34;int64&#34;, capacity: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_AddDimensionWithVehicleTransits(self, evaluator_indices, slack_max, capacity, fix_start_cumul_to_zero, name)

    def AddDimensionWithVehicleCapacity(self, evaluator_index: &#34;int&#34;, slack_max: &#34;int64&#34;, vehicle_capacities: &#34;std::vector&lt; int64 &gt;&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_AddDimensionWithVehicleCapacity(self, evaluator_index, slack_max, vehicle_capacities, fix_start_cumul_to_zero, name)

    def AddDimensionWithVehicleTransitAndCapacity(self, evaluator_indices: &#34;std::vector&lt; int &gt; const &amp;&#34;, slack_max: &#34;int64&#34;, vehicle_capacities: &#34;std::vector&lt; int64 &gt;&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_AddDimensionWithVehicleTransitAndCapacity(self, evaluator_indices, slack_max, vehicle_capacities, fix_start_cumul_to_zero, name)

    def AddConstantDimensionWithSlack(self, value: &#34;int64&#34;, capacity: &#34;int64&#34;, slack_max: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Creates a dimension where the transit variable is constrained to be equal to &#39;value&#39;; &#39;capacity&#39; is the upper bound of the cumul variables. &#39;name&#39; is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn&#39;t create the new dimension).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddConstantDimensionWithSlack(self, value, capacity, slack_max, fix_start_cumul_to_zero, name)

    def AddConstantDimension(self, value: &#34;int64&#34;, capacity: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_AddConstantDimension(self, value, capacity, fix_start_cumul_to_zero, name)

    def AddVectorDimension(self, values: &#34;std::vector&lt; int64 &gt;&#34;, capacity: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Creates a dimension where the transit variable is constrained to be equal to &#39;values[i]&#39; for node i; &#39;capacity&#39; is the upper bound of the cumul variables. &#39;name&#39; is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn&#39;t create the new dimension).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddVectorDimension(self, values, capacity, fix_start_cumul_to_zero, name)

    def MakePathSpansAndTotalSlacks(self, dimension: &#34;RoutingDimension&#34;, spans: &#34;std::vector&lt; operations_research::IntVar * &gt;&#34;, total_slacks: &#34;std::vector&lt; operations_research::IntVar * &gt;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; For every vehicle of the routing model: - if total_slacks[vehicle] is not nullptr, constrains it to be the sum of   slacks on that vehicle, that is,   dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start) -   sum_{node in path of vehicle} dimension-&gt;FixedTransitVar(node). - if spans[vehicle] is not nullptr, constrains it to be   dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start) This does stronger propagation than a decomposition, and takes breaks into account.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_MakePathSpansAndTotalSlacks(self, dimension, spans, total_slacks)

    def GetAllDimensionNames(self) -&gt; &#34;std::vector&lt; std::string &gt;&#34;:
        r&#34;&#34;&#34; Outputs the names of all dimensions added to the routing engine.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetAllDimensionNames(self)

    def GetDimensions(self) -&gt; &#34;std::vector&lt; operations_research::RoutingDimension * &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns all dimensions of the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDimensions(self)

    def GetDimensionsWithSoftOrSpanCosts(self) -&gt; &#34;std::vector&lt; operations_research::RoutingDimension * &gt;&#34;:
        r&#34;&#34;&#34; Returns dimensions with soft or vehicle span costs.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDimensionsWithSoftOrSpanCosts(self)

    def GetGlobalDimensionCumulOptimizers(self) -&gt; &#34;std::vector&lt; std::unique_ptr&lt; operations_research::GlobalDimensionCumulOptimizer &gt; &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns [global|local]_dimension_optimizers_, which are empty if the model has not been closed.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetGlobalDimensionCumulOptimizers(self)

    def GetLocalDimensionCumulOptimizers(self) -&gt; &#34;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&#34;:
        return _pywrapcp.RoutingModel_GetLocalDimensionCumulOptimizers(self)

    def GetLocalDimensionCumulMPOptimizers(self) -&gt; &#34;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&#34;:
        return _pywrapcp.RoutingModel_GetLocalDimensionCumulMPOptimizers(self)

    def GetMutableGlobalCumulOptimizer(self, dimension: &#34;RoutingDimension&#34;) -&gt; &#34;operations_research::GlobalDimensionCumulOptimizer *&#34;:
        r&#34;&#34;&#34; Returns the global/local dimension cumul optimizer for a given dimension, or nullptr if there is none.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetMutableGlobalCumulOptimizer(self, dimension)

    def GetMutableLocalCumulOptimizer(self, dimension: &#34;RoutingDimension&#34;) -&gt; &#34;operations_research::LocalDimensionCumulOptimizer *&#34;:
        return _pywrapcp.RoutingModel_GetMutableLocalCumulOptimizer(self, dimension)

    def GetMutableLocalCumulMPOptimizer(self, dimension: &#34;RoutingDimension&#34;) -&gt; &#34;operations_research::LocalDimensionCumulOptimizer *&#34;:
        return _pywrapcp.RoutingModel_GetMutableLocalCumulMPOptimizer(self, dimension)

    def HasDimension(self, dimension_name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if a dimension exists for a given dimension name.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_HasDimension(self, dimension_name)

    def GetDimensionOrDie(self, dimension_name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::RoutingDimension const &amp;&#34;:
        r&#34;&#34;&#34; Returns a dimension from its name. Dies if the dimension does not exist.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDimensionOrDie(self, dimension_name)

    def GetMutableDimension(self, dimension_name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::RoutingDimension *&#34;:
        r&#34;&#34;&#34; Returns a dimension from its name. Returns nullptr if the dimension does not exist.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetMutableDimension(self, dimension_name)

    def SetPrimaryConstrainedDimension(self, dimension_name: &#34;std::string const &amp;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Set the given dimension as &#34;primary constrained&#34;. As of August 2013, this is only used by ArcIsMoreConstrainedThanArc(). &#34;dimension&#34; must be the name of an existing dimension, or be empty, in which case there will not be a primary dimension after this call.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetPrimaryConstrainedDimension(self, dimension_name)

    def GetPrimaryConstrainedDimension(self) -&gt; &#34;std::string const &amp;&#34;:
        r&#34;&#34;&#34; Get the primary constrained dimension, or an empty string if it is unset.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetPrimaryConstrainedDimension(self)

    def AddDisjunction(self, *args) -&gt; &#34;operations_research::RoutingModel::DisjunctionIndex&#34;:
        r&#34;&#34;&#34; Adds a disjunction constraint on the indices: exactly &#39;max_cardinality&#39; of the indices are active. Start and end indices of any vehicle cannot be part of a disjunction. If a penalty is given, at most &#39;max_cardinality&#39; of the indices can be active, and if less are active, &#39;penalty&#39; is payed per inactive index. This is equivalent to adding the constraint:     p + Sum(i)active[i] == max_cardinality where p is an integer variable, and the following cost to the cost function:     p * penalty. &#39;penalty&#39; must be positive to make the disjunction optional; a negative penalty will force &#39;max_cardinality&#39; indices of the disjunction to be performed, and therefore p == 0. Note: passing a vector with a single index will model an optional index with a penalty cost if it is not visited.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddDisjunction(self, *args)

    def GetDisjunctionIndices(self, index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; operations_research::RoutingModel::DisjunctionIndex &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns the indices of the disjunctions to which an index belongs.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDisjunctionIndices(self, index)

    def GetDisjunctionPenalty(self, index: &#34;operations_research::RoutingModel::DisjunctionIndex&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the penalty of the node disjunction of index &#39;index&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDisjunctionPenalty(self, index)

    def GetDisjunctionMaxCardinality(self, index: &#34;operations_research::RoutingModel::DisjunctionIndex&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the maximum number of possible active nodes of the node disjunction of index &#39;index&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDisjunctionMaxCardinality(self, index)

    def GetNumberOfDisjunctions(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns the number of node disjunctions in the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetNumberOfDisjunctions(self)

    def GetPerfectBinaryDisjunctions(self) -&gt; &#34;std::vector&lt; std::pair&lt; int64,int64 &gt; &gt;&#34;:
        r&#34;&#34;&#34; Returns the list of all perfect binary disjunctions, as pairs of variable indices: a disjunction is &#34;perfect&#34; when its variables do not appear in any other disjunction. Each pair is sorted (lowest variable index first), and the output vector is also sorted (lowest pairs first).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetPerfectBinaryDisjunctions(self)

    def IgnoreDisjunctionsAlreadyForcedToZero(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; SPECIAL: Makes the solver ignore all the disjunctions whose active variables are all trivially zero (i.e. Max() == 0), by setting their max_cardinality to 0. This can be useful when using the BaseBinaryDisjunctionNeighborhood operators, in the context of arc-based routing.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_IgnoreDisjunctionsAlreadyForcedToZero(self)

    def AddSoftSameVehicleConstraint(self, indices: &#34;std::vector&lt; int64 &gt; const &amp;&#34;, cost: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a soft contraint to force a set of variable indices to be on the same vehicle. If all nodes are not on the same vehicle, each extra vehicle used adds &#39;cost&#39; to the cost function.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddSoftSameVehicleConstraint(self, indices, cost)

    def SetAllowedVehiclesForIndex(self, vehicles: &#34;std::vector&lt; int &gt; const &amp;&#34;, index: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the vehicles which can visit a given node. If the node is in a disjunction, this will not prevent it from being unperformed. Specifying an empty vector of vehicles has no effect (all vehicles will be allowed to visit the node).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetAllowedVehiclesForIndex(self, vehicles, index)

    def IsVehicleAllowedForIndex(self, vehicle: &#34;int&#34;, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if a vehicle is allowed to visit a given node.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_IsVehicleAllowedForIndex(self, vehicle, index)

    def AddPickupAndDelivery(self, pickup: &#34;int64&#34;, delivery: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Notifies that index1 and index2 form a pair of nodes which should belong to the same route. This methods helps the search find better solutions, especially in the local search phase. It should be called each time you have an equality constraint linking the vehicle variables of two node (including for instance pickup and delivery problems):     Solver* const solver = routing.solver();     int64 index1 = manager.NodeToIndex(node1);     int64 index2 = manager.NodeToIndex(node2);     solver-&gt;AddConstraint(solver-&gt;MakeEquality(         routing.VehicleVar(index1),         routing.VehicleVar(index2)));     routing.AddPickupAndDelivery(index1, index2);&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddPickupAndDelivery(self, pickup, delivery)

    def AddPickupAndDeliverySets(self, pickup_disjunction: &#34;operations_research::RoutingModel::DisjunctionIndex&#34;, delivery_disjunction: &#34;operations_research::RoutingModel::DisjunctionIndex&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Same as AddPickupAndDelivery but notifying that the performed node from the disjunction of index &#39;pickup_disjunction&#39; is on the same route as the performed node from the disjunction of index &#39;delivery_disjunction&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddPickupAndDeliverySets(self, pickup_disjunction, delivery_disjunction)

    def GetPickupIndexPairs(self, node_index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns pairs for which the node is a pickup; the first element of each pair is the index in the pickup and delivery pairs list in which the pickup appears, the second element is its index in the pickups list.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetPickupIndexPairs(self, node_index)

    def GetDeliveryIndexPairs(self, node_index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Same as above for deliveries.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDeliveryIndexPairs(self, node_index)

    def SetPickupAndDeliveryPolicyOfAllVehicles(self, policy: &#34;operations_research::RoutingModel::PickupAndDeliveryPolicy&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the Pickup and delivery policy of all vehicles. It is equivalent to calling SetPickupAndDeliveryPolicyOfVehicle on all vehicles.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetPickupAndDeliveryPolicyOfAllVehicles(self, policy)

    def SetPickupAndDeliveryPolicyOfVehicle(self, policy: &#34;operations_research::RoutingModel::PickupAndDeliveryPolicy&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingModel_SetPickupAndDeliveryPolicyOfVehicle(self, policy, vehicle)

    def GetPickupAndDeliveryPolicyOfVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;operations_research::RoutingModel::PickupAndDeliveryPolicy&#34;:
        return _pywrapcp.RoutingModel_GetPickupAndDeliveryPolicyOfVehicle(self, vehicle)

    def GetNumOfSingletonNodes(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns the number of non-start/end nodes which do not appear in a pickup/delivery pair.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetNumOfSingletonNodes(self)
    TYPE_ADDED_TO_VEHICLE = _pywrapcp.RoutingModel_TYPE_ADDED_TO_VEHICLE
    r&#34;&#34;&#34; When visited, the number of types &#39;T&#39; on the vehicle increases by one.&#34;&#34;&#34;
    ADDED_TYPE_REMOVED_FROM_VEHICLE = _pywrapcp.RoutingModel_ADDED_TYPE_REMOVED_FROM_VEHICLE
    r&#34;&#34;&#34; When visited, one instance of type &#39;T&#39; previously added to the route (TYPE_ADDED_TO_VEHICLE), if any, is removed from the vehicle. If the type was not previously added to the route or all added instances have already been removed, this visit has no effect on the types.&#34;&#34;&#34;
    TYPE_ON_VEHICLE_UP_TO_VISIT = _pywrapcp.RoutingModel_TYPE_ON_VEHICLE_UP_TO_VISIT
    r&#34;&#34;&#34; With the following policy, the visit enforces that type &#39;T&#39; is considered on the route from its start until this node is visited.&#34;&#34;&#34;
    TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED = _pywrapcp.RoutingModel_TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED
    r&#34;&#34;&#34; The visit doesn&#39;t have an impact on the number of types &#39;T&#39; on the route, as it&#39;s (virtually) added and removed directly. This policy can be used for visits which are part of an incompatibility or requirement set without affecting the type count on the route.&#34;&#34;&#34;

    def SetVisitType(self, index: &#34;int64&#34;, type: &#34;int&#34;, type_policy: &#34;operations_research::RoutingModel::VisitTypePolicy&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingModel_SetVisitType(self, index, type, type_policy)

    def GetVisitType(self, index: &#34;int64&#34;) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingModel_GetVisitType(self, index)

    def GetVisitTypePolicy(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::RoutingModel::VisitTypePolicy&#34;:
        return _pywrapcp.RoutingModel_GetVisitTypePolicy(self, index)

    def CloseVisitTypes(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This function should be called once all node visit types have been set and prior to adding any incompatibilities/requirements. &#34;close&#34; types.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CloseVisitTypes(self)

    def GetNumberOfVisitTypes(self) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingModel_GetNumberOfVisitTypes(self)

    def AddHardTypeIncompatibility(self, type1: &#34;int&#34;, type2: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Incompatibilities: Two nodes with &#34;hard&#34; incompatible types cannot share the same route at all, while with a &#34;temporal&#34; incompatibility they can&#39;t be on the same route at the same time.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddHardTypeIncompatibility(self, type1, type2)

    def AddTemporalTypeIncompatibility(self, type1: &#34;int&#34;, type2: &#34;int&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingModel_AddTemporalTypeIncompatibility(self, type1, type2)

    def GetHardTypeIncompatibilitiesOfType(self, type: &#34;int&#34;) -&gt; &#34;absl::flat_hash_set&lt; int &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns visit types incompatible with a given type.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetHardTypeIncompatibilitiesOfType(self, type)

    def GetTemporalTypeIncompatibilitiesOfType(self, type: &#34;int&#34;) -&gt; &#34;absl::flat_hash_set&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.RoutingModel_GetTemporalTypeIncompatibilitiesOfType(self, type)

    def HasHardTypeIncompatibilities(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true iff any hard (resp. temporal) type incompatibilities have been added to the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_HasHardTypeIncompatibilities(self)

    def HasTemporalTypeIncompatibilities(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_HasTemporalTypeIncompatibilities(self)

    def AddSameVehicleRequiredTypeAlternatives(self, dependent_type: &#34;int&#34;, required_type_alternatives: &#34;absl::flat_hash_set&lt; int &gt;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Requirements: NOTE: As of 2019-04, cycles in the requirement graph are not supported, and lead to the dependent nodes being skipped if possible (otherwise the model is considered infeasible). The following functions specify that &#34;dependent_type&#34; requires at least one of the types in &#34;required_type_alternatives&#34;. For same-vehicle requirements, a node of dependent type type_D requires at least one node of type type_R among the required alternatives on the same route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddSameVehicleRequiredTypeAlternatives(self, dependent_type, required_type_alternatives)

    def AddRequiredTypeAlternativesWhenAddingType(self, dependent_type: &#34;int&#34;, required_type_alternatives: &#34;absl::flat_hash_set&lt; int &gt;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; If type_D depends on type_R when adding type_D, any node_D of type_D and VisitTypePolicy TYPE_ADDED_TO_VEHICLE or TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED requires at least one type_R on its vehicle at the time node_D is visited.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddRequiredTypeAlternativesWhenAddingType(self, dependent_type, required_type_alternatives)

    def AddRequiredTypeAlternativesWhenRemovingType(self, dependent_type: &#34;int&#34;, required_type_alternatives: &#34;absl::flat_hash_set&lt; int &gt;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; The following requirements apply when visiting dependent nodes that remove their type from the route, i.e. type_R must be on the vehicle when type_D of VisitTypePolicy ADDED_TYPE_REMOVED_FROM_VEHICLE, TYPE_ON_VEHICLE_UP_TO_VISIT or TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED is visited.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddRequiredTypeAlternativesWhenRemovingType(self, dependent_type, required_type_alternatives)

    def GetSameVehicleRequiredTypeAlternativesOfType(self, type: &#34;int&#34;) -&gt; &#34;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns the set of same-vehicle requirement alternatives for the given type.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetSameVehicleRequiredTypeAlternativesOfType(self, type)

    def GetRequiredTypeAlternativesWhenAddingType(self, type: &#34;int&#34;) -&gt; &#34;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns the set of requirement alternatives when adding the given type.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetRequiredTypeAlternativesWhenAddingType(self, type)

    def GetRequiredTypeAlternativesWhenRemovingType(self, type: &#34;int&#34;) -&gt; &#34;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns the set of requirement alternatives when removing the given type.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetRequiredTypeAlternativesWhenRemovingType(self, type)

    def HasSameVehicleTypeRequirements(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true iff any same-route (resp. temporal) type requirements have been added to the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_HasSameVehicleTypeRequirements(self)

    def HasTemporalTypeRequirements(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_HasTemporalTypeRequirements(self)

    def HasTypeRegulations(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true iff the model has any incompatibilities or requirements set on node types.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_HasTypeRegulations(self)

    def UnperformedPenalty(self, var_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Get the &#34;unperformed&#34; penalty of a node. This is only well defined if the node is only part of a single Disjunction involving only itself, and that disjunction has a penalty. In all other cases, including forced active nodes, this returns 0.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_UnperformedPenalty(self, var_index)

    def UnperformedPenaltyOrValue(self, default_value: &#34;int64&#34;, var_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Same as above except that it returns default_value instead of 0 when penalty is not well defined (default value is passed as first argument to simplify the usage of the method in a callback).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_UnperformedPenaltyOrValue(self, default_value, var_index)

    def GetDepot(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the variable index of the first starting or ending node of all routes. If all routes start  and end at the same node (single depot), this is the node returned.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDepot(self)

    def SetArcCostEvaluatorOfAllVehicles(self, evaluator_index: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the cost function of the model such that the cost of a segment of a route between node &#39;from&#39; and &#39;to&#39; is evaluator(from, to), whatever the route or vehicle performing the route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetArcCostEvaluatorOfAllVehicles(self, evaluator_index)

    def SetArcCostEvaluatorOfVehicle(self, evaluator_index: &#34;int&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the cost function for a given vehicle route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetArcCostEvaluatorOfVehicle(self, evaluator_index, vehicle)

    def SetFixedCostOfAllVehicles(self, cost: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the fixed cost of all vehicle routes. It is equivalent to calling SetFixedCostOfVehicle on all vehicle routes.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetFixedCostOfAllVehicles(self, cost)

    def SetFixedCostOfVehicle(self, cost: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the fixed cost of one vehicle route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetFixedCostOfVehicle(self, cost, vehicle)

    def GetFixedCostOfVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the route fixed cost taken into account if the route of the vehicle is not empty, aka there&#39;s at least one node on the route other than the first and last nodes.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetFixedCostOfVehicle(self, vehicle)

    def SetAmortizedCostFactorsOfAllVehicles(self, linear_cost_factor: &#34;int64&#34;, quadratic_cost_factor: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; The following methods set the linear and quadratic cost factors of vehicles (must be positive values). The default value of these parameters is zero for all vehicles. When set, the cost_ of the model will contain terms aiming at reducing the number of vehicles used in the model, by adding the following to the objective for every vehicle v: INDICATOR(v used in the model) *   [linear_cost_factor_of_vehicle_[v]    - quadratic_cost_factor_of_vehicle_[v]*(square of length of route v)] i.e. for every used vehicle, we add the linear factor as fixed cost, and subtract the square of the route length multiplied by the quadratic factor. This second term aims at making the routes as dense as possible. Sets the linear and quadratic cost factor of all vehicles.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetAmortizedCostFactorsOfAllVehicles(self, linear_cost_factor, quadratic_cost_factor)

    def SetAmortizedCostFactorsOfVehicle(self, linear_cost_factor: &#34;int64&#34;, quadratic_cost_factor: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the linear and quadratic cost factor of the given vehicle.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetAmortizedCostFactorsOfVehicle(self, linear_cost_factor, quadratic_cost_factor, vehicle)

    def GetAmortizedLinearCostFactorOfVehicles(self) -&gt; &#34;std::vector&lt; int64 &gt; const &amp;&#34;:
        return _pywrapcp.RoutingModel_GetAmortizedLinearCostFactorOfVehicles(self)

    def GetAmortizedQuadraticCostFactorOfVehicles(self) -&gt; &#34;std::vector&lt; int64 &gt; const &amp;&#34;:
        return _pywrapcp.RoutingModel_GetAmortizedQuadraticCostFactorOfVehicles(self)

    def ConsiderEmptyRouteCostsForVehicle(self, consider_costs: &#34;bool&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingModel_ConsiderEmptyRouteCostsForVehicle(self, consider_costs, vehicle)

    def AreEmptyRouteCostsConsideredForVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_AreEmptyRouteCostsConsideredForVehicle(self, vehicle)

    def SetFirstSolutionEvaluator(self, evaluator: &#34;operations_research::Solver::IndexEvaluator2&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Gets/sets the evaluator used during the search. Only relevant when RoutingSearchParameters.first_solution_strategy = EVALUATOR_STRATEGY. Takes ownership of evaluator.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetFirstSolutionEvaluator(self, evaluator)

    def AddLocalSearchOperator(self, ls_operator: &#34;LocalSearchOperator&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a local search operator to the set of operators used to solve the vehicle routing problem.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddLocalSearchOperator(self, ls_operator)

    def AddSearchMonitor(self, monitor: &#34;SearchMonitor&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a search monitor to the search used to solve the routing model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddSearchMonitor(self, monitor)

    def AddAtSolutionCallback(self, callback: &#34;std::function&lt; void () &gt;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a callback called each time a solution is found during the search. This is a shortcut to creating a monitor to call the callback on AtSolution() and adding it with AddSearchMonitor.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddAtSolutionCallback(self, callback)

    def AddVariableMinimizedByFinalizer(self, var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a variable to minimize in the solution finalizer. The solution finalizer is called each time a solution is found during the search and allows to instantiate secondary variables (such as dimension cumul variables).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddVariableMinimizedByFinalizer(self, var)

    def AddVariableMaximizedByFinalizer(self, var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a variable to maximize in the solution finalizer (see above for information on the solution finalizer).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddVariableMaximizedByFinalizer(self, var)

    def AddWeightedVariableMinimizedByFinalizer(self, var: &#34;IntVar&#34;, cost: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a variable to minimize in the solution finalizer, with a weighted priority: the higher the more priority it has.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddWeightedVariableMinimizedByFinalizer(self, var, cost)

    def AddVariableTargetToFinalizer(self, var: &#34;IntVar&#34;, target: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Add a variable to set the closest possible to the target value in the solution finalizer.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddVariableTargetToFinalizer(self, var, target)

    def CloseModel(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Closes the current routing model; after this method is called, no modification to the model can be done, but RoutesToAssignment becomes available. Note that CloseModel() is automatically called by Solve() and other methods that produce solution. This is equivalent to calling CloseModelWithParameters(DefaultRoutingSearchParameters()).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CloseModel(self)

    def CloseModelWithParameters(self, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Same as above taking search parameters (as of 10/2015 some the parameters have to be set when closing the model).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CloseModelWithParameters(self, search_parameters)

    def Solve(self, assignment: &#34;Assignment&#34;=None) -&gt; &#34;operations_research::Assignment const *&#34;:
        r&#34;&#34;&#34; Solves the current routing model; closes the current model. This is equivalent to calling SolveWithParameters(DefaultRoutingSearchParameters()) or SolveFromAssignmentWithParameters(assignment,                                   DefaultRoutingSearchParameters()).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_Solve(self, assignment)

    def SolveWithParameters(self, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;, solutions: &#34;std::vector&lt; operations_research::Assignment const * &gt; *&#34;=None) -&gt; &#34;operations_research::Assignment const *&#34;:
        r&#34;&#34;&#34; Solves the current routing model with the given parameters. If &#39;solutions&#39; is specified, it will contain the k best solutions found during the search (from worst to best, including the one returned by this method), where k corresponds to the &#39;number_of_solutions_to_collect&#39; in &#39;search_parameters&#39;. Note that the Assignment returned by the method and the ones in solutions are owned by the underlying solver and should not be deleted.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SolveWithParameters(self, search_parameters, solutions)

    def SolveFromAssignmentWithParameters(self, assignment: &#34;Assignment&#34;, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;, solutions: &#34;std::vector&lt; operations_research::Assignment const * &gt; *&#34;=None) -&gt; &#34;operations_research::Assignment const *&#34;:
        return _pywrapcp.RoutingModel_SolveFromAssignmentWithParameters(self, assignment, search_parameters, solutions)

    def SetAssignmentFromOtherModelAssignment(self, target_assignment: &#34;Assignment&#34;, source_model: &#34;RoutingModel&#34;, source_assignment: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Given a &#34;source_model&#34; and its &#34;source_assignment&#34;, resets &#34;target_assignment&#34; with the IntVar variables (nexts_, and vehicle_vars_ if costs aren&#39;t homogeneous across vehicles) of &#34;this&#34; model, with the values set according to those in &#34;other_assignment&#34;. The objective_element of target_assignment is set to this-&gt;cost_.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetAssignmentFromOtherModelAssignment(self, target_assignment, source_model, source_assignment)

    def ComputeLowerBound(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Computes a lower bound to the routing problem solving a linear assignment problem. The routing model must be closed before calling this method. Note that problems with node disjunction constraints (including optional nodes) and non-homogenous costs are not supported (the method returns 0 in these cases).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ComputeLowerBound(self)

    def status(self) -&gt; &#34;operations_research::RoutingModel::Status&#34;:
        r&#34;&#34;&#34; Returns the current status of the routing model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_status(self)

    def ApplyLocks(self, locks: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Applies a lock chain to the next search. &#39;locks&#39; represents an ordered vector of nodes representing a partial route which will be fixed during the next search; it will constrain next variables such that: next[locks[i]] == locks[i+1]. Returns the next variable at the end of the locked chain; this variable is not locked. An assignment containing the locks can be obtained by calling PreAssignment().&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ApplyLocks(self, locks)

    def ApplyLocksToAllVehicles(self, locks: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; const &amp;&#34;, close_routes: &#34;bool&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Applies lock chains to all vehicles to the next search, such that locks[p] is the lock chain for route p. Returns false if the locks do not contain valid routes; expects that the routes do not contain the depots, i.e. there are empty vectors in place of empty routes. If close_routes is set to true, adds the end nodes to the route of each vehicle and deactivates other nodes. An assignment containing the locks can be obtained by calling PreAssignment().&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ApplyLocksToAllVehicles(self, locks, close_routes)

    def PreAssignment(self) -&gt; &#34;operations_research::Assignment const *const&#34;:
        r&#34;&#34;&#34; Returns an assignment used to fix some of the variables of the problem. In practice, this assignment locks partial routes of the problem. This can be used in the context of locking the parts of the routes which have already been driven in online routing problems.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_PreAssignment(self)

    def MutablePreAssignment(self) -&gt; &#34;operations_research::Assignment *&#34;:
        return _pywrapcp.RoutingModel_MutablePreAssignment(self)

    def WriteAssignment(self, file_name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Writes the current solution to a file containing an AssignmentProto. Returns false if the file cannot be opened or if there is no current solution.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_WriteAssignment(self, file_name)

    def ReadAssignment(self, file_name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34; Reads an assignment from a file and returns the current solution. Returns nullptr if the file cannot be opened or if the assignment is not valid.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ReadAssignment(self, file_name)

    def RestoreAssignment(self, solution: &#34;Assignment&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34; Restores an assignment as a solution in the routing model and returns the new solution. Returns nullptr if the assignment is not valid.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_RestoreAssignment(self, solution)

    def ReadAssignmentFromRoutes(self, routes: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; const &amp;&#34;, ignore_inactive_indices: &#34;bool&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34; Restores the routes as the current solution. Returns nullptr if the solution cannot be restored (routes do not contain a valid solution). Note that calling this method will run the solver to assign values to the dimension variables; this may take considerable amount of time, especially when using dimensions with slack.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ReadAssignmentFromRoutes(self, routes, ignore_inactive_indices)

    def RoutesToAssignment(self, routes: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; const &amp;&#34;, ignore_inactive_indices: &#34;bool&#34;, close_routes: &#34;bool&#34;, assignment: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Fills an assignment from a specification of the routes of the vehicles. The routes are specified as lists of variable indices that appear on the routes of the vehicles. The indices of the outer vector in &#39;routes&#39; correspond to vehicles IDs, the inner vector contains the variable indices on the routes for the given vehicle. The inner vectors must not contain the start and end indices, as these are determined by the routing model.  Sets the value of NextVars in the assignment, adding the variables to the assignment if necessary. The method does not touch other variables in the assignment. The method can only be called after the model is closed.  With ignore_inactive_indices set to false, this method will fail (return nullptr) in case some of the route contain indices that are deactivated in the model; when set to true, these indices will be skipped.  Returns true if routes were successfully loaded. However, such assignment still might not be a valid solution to the routing problem due to more complex constraints; it is advisible to call solver()-&gt;CheckSolution() afterwards.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_RoutesToAssignment(self, routes, ignore_inactive_indices, close_routes, assignment)

    def AssignmentToRoutes(self, assignment: &#34;Assignment&#34;, routes: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; *const&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Converts the solution in the given assignment to routes for all vehicles. Expects that assignment contains a valid solution (i.e. routes for all vehicles end with an end index for that vehicle).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AssignmentToRoutes(self, assignment, routes)

    def CompactAssignment(self, assignment: &#34;Assignment&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34; Returns a compacted version of the given assignment, in which all vehicles with id lower or equal to some N have non-empty routes, and all vehicles with id greater than N have empty routes. Does not take ownership of the returned object. If found, the cost of the compact assignment is the same as in the original assignment and it preserves the values of &#39;active&#39; variables. Returns nullptr if a compact assignment was not found. This method only works in homogenous mode, and it only swaps equivalent vehicles (vehicles with the same start and end nodes). When creating the compact assignment, the empty plan is replaced by the route assigned to the compatible vehicle with the highest id. Note that with more complex constraints on vehicle variables, this method might fail even if a compact solution exists. This method changes the vehicle and dimension variables as necessary. While compacting the solution, only basic checks on vehicle variables are performed; if one of these checks fails no attempts to repair it are made (instead, the method returns nullptr).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CompactAssignment(self, assignment)

    def CompactAndCheckAssignment(self, assignment: &#34;Assignment&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34; Same as CompactAssignment() but also checks the validity of the final compact solution; if it is not valid, no attempts to repair it are made (instead, the method returns nullptr).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CompactAndCheckAssignment(self, assignment)

    def AddToAssignment(self, var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds an extra variable to the vehicle routing assignment.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddToAssignment(self, var)

    def AddIntervalToAssignment(self, interval: &#34;IntervalVar&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingModel_AddIntervalToAssignment(self, interval)

    def PackCumulsOfOptimizerDimensionsFromAssignment(self, original_assignment: &#34;Assignment&#34;, duration_limit: &#34;absl::Duration&#34;) -&gt; &#34;operations_research::Assignment const *&#34;:
        r&#34;&#34;&#34; For every dimension in the model with an optimizer in local/global_dimension_optimizers_, this method tries to pack the cumul values of the dimension, such that: - The cumul costs (span costs, soft lower and upper bound costs, etc) are   minimized. - The cumuls of the ends of the routes are minimized for this given   minimal cumul cost. - Given these minimal end cumuls, the route start cumuls are maximized. Returns the assignment resulting from allocating these packed cumuls with the solver, and nullptr if these cumuls could not be set by the solver.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_PackCumulsOfOptimizerDimensionsFromAssignment(self, original_assignment, duration_limit)

    def AddLocalSearchFilter(self, filter: &#34;LocalSearchFilter&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a custom local search filter to the list of filters used to speed up local search by pruning unfeasible variable assignments. Calling this method after the routing model has been closed (CloseModel() or Solve() has been called) has no effect. The routing model does not take ownership of the filter.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddLocalSearchFilter(self, filter)

    def Start(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Model inspection. Returns the variable index of the starting node of a vehicle route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_Start(self, vehicle)

    def End(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the variable index of the ending node of a vehicle route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_End(self, vehicle)

    def IsStart(self, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if &#39;index&#39; represents the first node of a route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_IsStart(self, index)

    def IsEnd(self, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if &#39;index&#39; represents the last node of a route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_IsEnd(self, index)

    def VehicleIndex(self, index: &#34;int&#34;) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns the vehicle of the given start/end index, and -1 if the given index is not a vehicle start/end.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_VehicleIndex(self, index)

    def Next(self, assignment: &#34;Assignment&#34;, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Assignment inspection Returns the variable index of the node directly after the node corresponding to &#39;index&#39; in &#39;assignment&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_Next(self, assignment, index)

    def IsVehicleUsed(self, assignment: &#34;Assignment&#34;, vehicle: &#34;int&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if the route of &#39;vehicle&#39; is non empty in &#39;assignment&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_IsVehicleUsed(self, assignment, vehicle)

    def NextVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the next variable of the node corresponding to index. Note that NextVar(index) == index is equivalent to ActiveVar(index) == 0.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_NextVar(self, index)

    def ActiveVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the active variable of the node corresponding to index.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ActiveVar(self, index)

    def VehicleCostsConsideredVar(self, vehicle: &#34;int&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the variable specifying whether or not costs are considered for vehicle.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_VehicleCostsConsideredVar(self, vehicle)

    def VehicleVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the vehicle variable of the node corresponding to index. Note that VehicleVar(index) == -1 is equivalent to ActiveVar(index) == 0.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_VehicleVar(self, index)

    def CostVar(self) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the global cost variable which is being minimized.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CostVar(self)

    def GetArcCostForVehicle(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;, vehicle: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the cost of the transit arc between two nodes for a given vehicle. Input are variable indices of node. This returns 0 if vehicle &lt; 0.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetArcCostForVehicle(self, from_index, to_index, vehicle)

    def CostsAreHomogeneousAcrossVehicles(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Whether costs are homogeneous across all vehicles.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CostsAreHomogeneousAcrossVehicles(self)

    def GetHomogeneousCost(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the cost of the segment between two nodes supposing all vehicle costs are the same (returns the cost for the first vehicle otherwise).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetHomogeneousCost(self, from_index, to_index)

    def GetArcCostForFirstSolution(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the cost of the arc in the context of the first solution strategy. This is typically a simplification of the actual cost; see the .cc.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetArcCostForFirstSolution(self, from_index, to_index)

    def GetArcCostForClass(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;, cost_class_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the cost of the segment between two nodes for a given cost class. Input are variable indices of nodes and the cost class. Unlike GetArcCostForVehicle(), if cost_class is kNoCost, then the returned cost won&#39;t necessarily be zero: only some of the components of the cost that depend on the cost class will be omited. See the code for details.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetArcCostForClass(self, from_index, to_index, cost_class_index)

    def GetCostClassIndexOfVehicle(self, vehicle: &#34;int64&#34;) -&gt; &#34;operations_research::RoutingModel::CostClassIndex&#34;:
        r&#34;&#34;&#34; Get the cost class index of the given vehicle.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetCostClassIndexOfVehicle(self, vehicle)

    def HasVehicleWithCostClassIndex(self, cost_class_index: &#34;operations_research::RoutingModel::CostClassIndex&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true iff the model contains a vehicle with the given cost_class_index.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_HasVehicleWithCostClassIndex(self, cost_class_index)

    def GetCostClassesCount(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns the number of different cost classes in the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetCostClassesCount(self)

    def GetNonZeroCostClassesCount(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Ditto, minus the &#39;always zero&#39;, built-in cost class.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetNonZeroCostClassesCount(self)

    def GetVehicleClassIndexOfVehicle(self, vehicle: &#34;int64&#34;) -&gt; &#34;operations_research::RoutingModel::VehicleClassIndex&#34;:
        return _pywrapcp.RoutingModel_GetVehicleClassIndexOfVehicle(self, vehicle)

    def GetVehicleClassesCount(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns the number of different vehicle classes in the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetVehicleClassesCount(self)

    def GetSameVehicleIndicesOfIndex(self, node: &#34;int&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns variable indices of nodes constrained to be on the same route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetSameVehicleIndicesOfIndex(self, node)

    def ArcIsMoreConstrainedThanArc(self, _from: &#34;int64&#34;, to1: &#34;int64&#34;, to2: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns whether the arc from-&gt;to1 is more constrained than from-&gt;to2, taking into account, in order: - whether the destination node isn&#39;t an end node - whether the destination node is mandatory - whether the destination node is bound to the same vehicle as the source - the &#34;primary constrained&#34; dimension (see SetPrimaryConstrainedDimension) It then breaks ties using, in order: - the arc cost (taking unperformed penalties into account) - the size of the vehicle vars of &#34;to1&#34; and &#34;to2&#34; (lowest size wins) - the value: the lowest value of the indices to1 and to2 wins. See the .cc for details. The more constrained arc is typically preferable when building a first solution. This method is intended to be used as a callback for the BestValueByComparisonSelector value selector. Args:   from: the variable index of the source node   to1: the variable index of the first candidate destination node.   to2: the variable index of the second candidate destination node.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ArcIsMoreConstrainedThanArc(self, _from, to1, to2)

    def DebugOutputAssignment(self, solution_assignment: &#34;Assignment&#34;, dimension_to_print: &#34;std::string const &amp;&#34;) -&gt; &#34;std::string&#34;:
        r&#34;&#34;&#34; Print some debugging information about an assignment, including the feasible intervals of the CumulVar for dimension &#34;dimension_to_print&#34; at each step of the routes. If &#34;dimension_to_print&#34; is omitted, all dimensions will be printed.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_DebugOutputAssignment(self, solution_assignment, dimension_to_print)

    def solver(self) -&gt; &#34;operations_research::Solver *&#34;:
        r&#34;&#34;&#34; Returns the underlying constraint solver. Can be used to add extra constraints and/or modify search algoithms.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_solver(self)

    def CheckLimit(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if the search limit has been crossed.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CheckLimit(self)

    def RemainingTime(self) -&gt; &#34;absl::Duration&#34;:
        r&#34;&#34;&#34; Returns the time left in the search limit.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_RemainingTime(self)

    def nodes(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Sizes and indices Returns the number of nodes in the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_nodes(self)

    def vehicles(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns the number of vehicle routes in the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_vehicles(self)

    def Size(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the number of next variables in the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_Size(self)

    def GetNumberOfDecisionsInFirstSolution(self, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns statistics on first solution search, number of decisions sent to filters, number of decisions rejected by filters.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetNumberOfDecisionsInFirstSolution(self, search_parameters)

    def GetNumberOfRejectsInFirstSolution(self, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingModel_GetNumberOfRejectsInFirstSolution(self, search_parameters)

    def GetAutomaticFirstSolutionStrategy(self) -&gt; &#34;operations_research::FirstSolutionStrategy::Value&#34;:
        r&#34;&#34;&#34; Returns the automatic first solution strategy selected.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetAutomaticFirstSolutionStrategy(self)

    def IsMatchingModel(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if a vehicle/node matching problem is detected.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_IsMatchingModel(self)

    def MakeGuidedSlackFinalizer(self, dimension: &#34;RoutingDimension&#34;, initializer: &#34;std::function&lt; int64 (int64) &gt;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        r&#34;&#34;&#34; The next few members are in the public section only for testing purposes. MakeGuidedSlackFinalizer creates a DecisionBuilder for the slacks of a dimension using a callback to choose which values to start with. The finalizer works only when all next variables in the model have been fixed. It has the following two characteristics: 1. It follows the routes defined by the nexts variables when choosing a    variable to make a decision on. 2. When it comes to choose a value for the slack of node i, the decision    builder first calls the callback with argument i, and supposingly the    returned value is x it creates decisions slack[i] = x, slack[i] = x +    1, slack[i] = x - 1, slack[i] = x + 2, etc.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_MakeGuidedSlackFinalizer(self, dimension, initializer)

    def MakeSelfDependentDimensionFinalizer(self, dimension: &#34;RoutingDimension&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        r&#34;&#34;&#34; MakeSelfDependentDimensionFinalizer is a finalizer for the slacks of a self-dependent dimension. It makes an extensive use of the caches of the state dependent transits. In detail, MakeSelfDependentDimensionFinalizer returns a composition of a local search decision builder with a greedy descent operator for the cumul of the start of each route and a guided slack finalizer. Provided there are no time windows and the maximum slacks are large enough, once the cumul of the start of route is fixed, the guided finalizer can find optimal values of the slacks for the rest of the route in time proportional to the length of the route. Therefore the composed finalizer generally works in time O(log(t)*n*m), where t is the latest possible departute time, n is the number of nodes in the network and m is the number of vehicles.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_MakeSelfDependentDimensionFinalizer(self, dimension)

    def AddMatrixDimension(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingModel_AddMatrixDimension(self, *args)

# Register RoutingModel in _pywrapcp:
_pywrapcp.RoutingModel_swigregister(RoutingModel)
cvar = _pywrapcp.cvar
RoutingModel.kNoPenalty = _pywrapcp.cvar.RoutingModel_kNoPenalty
RoutingModel.kNoDisjunction = _pywrapcp.cvar.RoutingModel_kNoDisjunction
RoutingModel.kNoDimension = _pywrapcp.cvar.RoutingModel_kNoDimension

class RoutingModelVisitor(BaseObject):
    r&#34;&#34;&#34; Routing model visitor.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self):
        _pywrapcp.RoutingModelVisitor_swiginit(self, _pywrapcp.new_RoutingModelVisitor())
    __swig_destroy__ = _pywrapcp.delete_RoutingModelVisitor

# Register RoutingModelVisitor in _pywrapcp:
_pywrapcp.RoutingModelVisitor_swigregister(RoutingModelVisitor)
RoutingModelVisitor.kLightElement = _pywrapcp.cvar.RoutingModelVisitor_kLightElement
RoutingModelVisitor.kLightElement2 = _pywrapcp.cvar.RoutingModelVisitor_kLightElement2
RoutingModelVisitor.kRemoveValues = _pywrapcp.cvar.RoutingModelVisitor_kRemoveValues

class GlobalVehicleBreaksConstraint(Constraint):
    r&#34;&#34;&#34; GlobalVehicleBreaksConstraint ensures breaks constraints are enforced on all vehicles in the dimension passed to its constructor. It is intended to be used for dimensions representing time. A break constraint ensures break intervals fit on the route of a vehicle. For a given vehicle, it forces break intervals to be disjoint from visit intervals, where visit intervals start at CumulVar(node) and last for node_visit_transit[node]. Moreover, it ensures that there is enough time between two consecutive nodes of a route to do transit and vehicle breaks, i.e. if Next(nodeA) = nodeB, CumulVar(nodeA) = tA and CumulVar(nodeB) = tB, then SlackVar(nodeA) &gt;= sum_{breaks [tA, tB)} duration(break).&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, dimension: &#34;RoutingDimension&#34;):
        _pywrapcp.GlobalVehicleBreaksConstraint_swiginit(self, _pywrapcp.new_GlobalVehicleBreaksConstraint(dimension))

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.GlobalVehicleBreaksConstraint_DebugString(self)

    def Post(self) -&gt; &#34;void&#34;:
        return _pywrapcp.GlobalVehicleBreaksConstraint_Post(self)

    def InitialPropagateWrapper(self) -&gt; &#34;void&#34;:
        return _pywrapcp.GlobalVehicleBreaksConstraint_InitialPropagateWrapper(self)
    __swig_destroy__ = _pywrapcp.delete_GlobalVehicleBreaksConstraint

# Register GlobalVehicleBreaksConstraint in _pywrapcp:
_pywrapcp.GlobalVehicleBreaksConstraint_swigregister(GlobalVehicleBreaksConstraint)

class TypeRegulationsChecker(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_TypeRegulationsChecker

    def CheckVehicle(self, vehicle: &#34;int&#34;, next_accessor: &#34;std::function&lt; int64 (int64) &gt; const &amp;&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.TypeRegulationsChecker_CheckVehicle(self, vehicle, next_accessor)

# Register TypeRegulationsChecker in _pywrapcp:
_pywrapcp.TypeRegulationsChecker_swigregister(TypeRegulationsChecker)

class TypeIncompatibilityChecker(TypeRegulationsChecker):
    r&#34;&#34;&#34; Checker for type incompatibilities.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, model: &#34;RoutingModel&#34;, check_hard_incompatibilities: &#34;bool&#34;):
        _pywrapcp.TypeIncompatibilityChecker_swiginit(self, _pywrapcp.new_TypeIncompatibilityChecker(model, check_hard_incompatibilities))
    __swig_destroy__ = _pywrapcp.delete_TypeIncompatibilityChecker

# Register TypeIncompatibilityChecker in _pywrapcp:
_pywrapcp.TypeIncompatibilityChecker_swigregister(TypeIncompatibilityChecker)

class TypeRequirementChecker(TypeRegulationsChecker):
    r&#34;&#34;&#34; Checker for type requirements.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, model: &#34;RoutingModel&#34;):
        _pywrapcp.TypeRequirementChecker_swiginit(self, _pywrapcp.new_TypeRequirementChecker(model))
    __swig_destroy__ = _pywrapcp.delete_TypeRequirementChecker

# Register TypeRequirementChecker in _pywrapcp:
_pywrapcp.TypeRequirementChecker_swigregister(TypeRequirementChecker)

class TypeRegulationsConstraint(Constraint):
    r&#34;&#34;&#34; The following constraint ensures that incompatibilities and requirements between types are respected. It verifies both &#34;hard&#34; and &#34;temporal&#34; incompatibilities. Two nodes with hard incompatible types cannot be served by the same vehicle at all, while with a temporal incompatibility they can&#39;t be on the same route at the same time. The VisitTypePolicy of a node determines how visiting it impacts the type count on the route. For example, for - three temporally incompatible types T1 T2 and T3 - 2 pairs of nodes a1/r1 and a2/r2 of type T1 and T2 respectively, with     - a1 and a2 of VisitTypePolicy TYPE_ADDED_TO_VEHICLE     - r1 and r2 of policy ADDED_TYPE_REMOVED_FROM_VEHICLE - 3 nodes A, UV and AR of type T3, respectively with type policies   TYPE_ADDED_TO_VEHICLE, TYPE_ON_VEHICLE_UP_TO_VISIT and   TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED the configurations UV --&gt; a1 --&gt; r1 --&gt; a2 --&gt; r2,   a1 --&gt; r1 --&gt; a2 --&gt; r2 --&gt; A and a1 --&gt; r1 --&gt; AR --&gt; a2 --&gt; r2 are acceptable, whereas the configurations a1 --&gt; a2 --&gt; r1 --&gt; ..., or A --&gt; a1 --&gt; r1 --&gt; ..., or a1 --&gt; r1 --&gt; UV --&gt; ... are not feasible. It also verifies same-vehicle and temporal type requirements. A node of type T_d with a same-vehicle requirement for type T_r needs to be served by the same vehicle as a node of type T_r. Temporal requirements, on the other hand, can take effect either when the dependent type is being added to the route or when it&#39;s removed from it, which is determined by the dependent node&#39;s VisitTypePolicy. In the above example: - If T3 is required on the same vehicle as T1, A, AR or UV must be on the   same vehicle as a1. - If T2 is required when adding T1, a2 must be visited *before* a1, and if   r2 is also visited on the route, it must be *after* a1, i.e. T2 must be on   the vehicle when a1 is visited:   ... --&gt; a2 --&gt; ... --&gt; a1 --&gt; ... --&gt; r2 --&gt; ... - If T3 is required when removing T1, T3 needs to be on the vehicle when   r1 is visited:   ... --&gt; A --&gt; ... --&gt; r1 --&gt; ...   OR   ... --&gt; r1 --&gt; ... --&gt; UV --&gt; ...&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, model: &#34;RoutingModel&#34;):
        _pywrapcp.TypeRegulationsConstraint_swiginit(self, _pywrapcp.new_TypeRegulationsConstraint(model))

    def Post(self) -&gt; &#34;void&#34;:
        return _pywrapcp.TypeRegulationsConstraint_Post(self)

    def InitialPropagateWrapper(self) -&gt; &#34;void&#34;:
        return _pywrapcp.TypeRegulationsConstraint_InitialPropagateWrapper(self)
    __swig_destroy__ = _pywrapcp.delete_TypeRegulationsConstraint

# Register TypeRegulationsConstraint in _pywrapcp:
_pywrapcp.TypeRegulationsConstraint_swigregister(TypeRegulationsConstraint)

class RoutingDimension(object):
    r&#34;&#34;&#34; Dimensions represent quantities accumulated at nodes along the routes. They represent quantities such as weights or volumes carried along the route, or distance or times. Quantities at a node are represented by &#34;cumul&#34; variables and the increase or decrease of quantities between nodes are represented by &#34;transit&#34; variables. These variables are linked as follows: if j == next(i), cumuls(j) = cumuls(i) + transits(i) + slacks(i) +             state_dependent_transits(i) where slack is a positive slack variable (can represent waiting times for a time dimension), and state_dependent_transits is a non-purely functional version of transits_. Favour transits over state_dependent_transits when possible, because purely functional callbacks allow more optimisations and make the model faster and easier to solve. for a given vehicle, it is passed as an external vector, it would be better to have this information here.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_RoutingDimension

    def model(self) -&gt; &#34;operations_research::RoutingModel *&#34;:
        r&#34;&#34;&#34; Returns the model on which the dimension was created.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_model(self)

    def GetTransitValue(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;, vehicle: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the transition value for a given pair of nodes (as var index); this value is the one taken by the corresponding transit variable when the &#39;next&#39; variable for &#39;from_index&#39; is bound to &#39;to_index&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_GetTransitValue(self, from_index, to_index, vehicle)

    def GetTransitValueFromClass(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;, vehicle_class: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Same as above but taking a vehicle class of the dimension instead of a vehicle (the class of a vehicle can be obtained with vehicle_to_class()).&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_GetTransitValueFromClass(self, from_index, to_index, vehicle_class)

    def CumulVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Get the cumul, transit and slack variables for the given node (given as int64 var index).&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_CumulVar(self, index)

    def TransitVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.RoutingDimension_TransitVar(self, index)

    def FixedTransitVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.RoutingDimension_FixedTransitVar(self, index)

    def SlackVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.RoutingDimension_SlackVar(self, index)

    def SetSpanUpperBoundForVehicle(self, upper_bound: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets an upper bound on the dimension span on a given vehicle. This is the preferred way to limit the &#34;length&#34; of the route of a vehicle according to a dimension.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetSpanUpperBoundForVehicle(self, upper_bound, vehicle)

    def SetSpanCostCoefficientForVehicle(self, coefficient: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets a cost proportional to the dimension span on a given vehicle, or on all vehicles at once. &#34;coefficient&#34; must be nonnegative. This is handy to model costs proportional to idle time when the dimension represents time. The cost for a vehicle is   span_cost = coefficient * (dimension end value - dimension start value).&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetSpanCostCoefficientForVehicle(self, coefficient, vehicle)

    def SetSpanCostCoefficientForAllVehicles(self, coefficient: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingDimension_SetSpanCostCoefficientForAllVehicles(self, coefficient)

    def SetGlobalSpanCostCoefficient(self, coefficient: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets a cost proportional to the *global* dimension span, that is the difference between the largest value of route end cumul variables and the smallest value of route start cumul variables. In other words: global_span_cost =   coefficient * (Max(dimension end value) - Min(dimension start value)).&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetGlobalSpanCostCoefficient(self, coefficient)

    def SetCumulVarSoftUpperBound(self, index: &#34;int64&#34;, upper_bound: &#34;int64&#34;, coefficient: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets a soft upper bound to the cumul variable of a given variable index. If the value of the cumul variable is greater than the bound, a cost proportional to the difference between this value and the bound is added to the cost function of the model:   cumulVar &lt;= upper_bound -&gt; cost = 0    cumulVar &gt; upper_bound -&gt; cost = coefficient * (cumulVar - upper_bound) This is also handy to model tardiness costs when the dimension represents time.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetCumulVarSoftUpperBound(self, index, upper_bound, coefficient)

    def HasCumulVarSoftUpperBound(self, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if a soft upper bound has been set for a given variable index.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_HasCumulVarSoftUpperBound(self, index)

    def GetCumulVarSoftUpperBound(self, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the soft upper bound of a cumul variable for a given variable index. The &#34;hard&#34; upper bound of the variable is returned if no soft upper bound has been set.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_GetCumulVarSoftUpperBound(self, index)

    def GetCumulVarSoftUpperBoundCoefficient(self, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the cost coefficient of the soft upper bound of a cumul variable for a given variable index. If no soft upper bound has been set, 0 is returned.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_GetCumulVarSoftUpperBoundCoefficient(self, index)

    def SetCumulVarSoftLowerBound(self, index: &#34;int64&#34;, lower_bound: &#34;int64&#34;, coefficient: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets a soft lower bound to the cumul variable of a given variable index. If the value of the cumul variable is less than the bound, a cost proportional to the difference between this value and the bound is added to the cost function of the model:   cumulVar &gt; lower_bound -&gt; cost = 0   cumulVar &lt;= lower_bound -&gt; cost = coefficient * (lower_bound -               cumulVar). This is also handy to model earliness costs when the dimension represents time. Note: Using soft lower and upper bounds or span costs together is, as of 6/2014, not well supported in the sense that an optimal schedule is not guaranteed.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetCumulVarSoftLowerBound(self, index, lower_bound, coefficient)

    def HasCumulVarSoftLowerBound(self, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if a soft lower bound has been set for a given variable index.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_HasCumulVarSoftLowerBound(self, index)

    def GetCumulVarSoftLowerBound(self, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the soft lower bound of a cumul variable for a given variable index. The &#34;hard&#34; lower bound of the variable is returned if no soft lower bound has been set.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_GetCumulVarSoftLowerBound(self, index)

    def GetCumulVarSoftLowerBoundCoefficient(self, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the cost coefficient of the soft lower bound of a cumul variable for a given variable index. If no soft lower bound has been set, 0 is returned.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_GetCumulVarSoftLowerBoundCoefficient(self, index)

    def SetBreakIntervalsOfVehicle(self, breaks: &#34;std::vector&lt; operations_research::IntervalVar * &gt;&#34;, vehicle: &#34;int&#34;, node_visit_transits: &#34;std::vector&lt; int64 &gt;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the breaks for a given vehicle. Breaks are represented by IntervalVars. They may interrupt transits between nodes and increase the value of corresponding slack variables. A break may take place before the start of a vehicle, after the end of a vehicle, or during a travel i -&gt; j. In that case, the interval [break.Start(), break.End()) must be a subset of [CumulVar(i) + pre_travel(i, j), CumulVar(j) - post_travel(i, j)). In other words, a break may not overlap any node n&#39;s visit, given by [CumulVar(n) - post_travel(_, n), CumulVar(n) + pre_travel(n, _)). This formula considers post_travel(_, start) and pre_travel(end, _) to be 0; pre_travel will never be called on any (_, start) and post_travel will never we called on any (end, _). If pre_travel_evaluator or post_travel_evaluator is -1, it will be taken as a function that always returns 0. Deprecated, sets pre_travel(i, j) = node_visit_transit[i].&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetBreakIntervalsOfVehicle(self, breaks, vehicle, node_visit_transits)

    def SetBreakDistanceDurationOfVehicle(self, distance: &#34;int64&#34;, duration: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; With breaks supposed to be consecutive, this forces the distance between breaks of size at least minimum_break_duration to be at least distance. This supposes that the time until route start and after route end are infinite breaks.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetBreakDistanceDurationOfVehicle(self, distance, duration, vehicle)

    def InitializeBreaks(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets up vehicle_break_intervals_, vehicle_break_distance_duration_, pre_travel_evaluators and post_travel_evaluators.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_InitializeBreaks(self)

    def HasBreakConstraints(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if any break interval or break distance was defined.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_HasBreakConstraints(self)

    def GetPreTravelEvaluatorOfVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingDimension_GetPreTravelEvaluatorOfVehicle(self, vehicle)

    def GetPostTravelEvaluatorOfVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingDimension_GetPostTravelEvaluatorOfVehicle(self, vehicle)

    def base_dimension(self) -&gt; &#34;operations_research::RoutingDimension const *&#34;:
        r&#34;&#34;&#34; Returns the parent in the dependency tree if any or nullptr otherwise.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_base_dimension(self)

    def ShortestTransitionSlack(self, node: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; It makes sense to use the function only for self-dependent dimension. For such dimensions the value of the slack of a node determines the transition cost of the next transit. Provided that   1. cumul[node] is fixed,   2. next[node] and next[next[node]] (if exists) are fixed, the value of slack[node] for which cumul[next[node]] + transit[next[node]] is minimized can be found in O(1) using this function.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_ShortestTransitionSlack(self, node)

    def name(self) -&gt; &#34;std::string const &amp;&#34;:
        r&#34;&#34;&#34; Returns the name of the dimension.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_name(self)

    def SetPickupToDeliveryLimitFunctionForPair(self, limit_function: &#34;operations_research::RoutingDimension::PickupToDeliveryLimitFunction&#34;, pair_index: &#34;int&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingDimension_SetPickupToDeliveryLimitFunctionForPair(self, limit_function, pair_index)

    def HasPickupToDeliveryLimits(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingDimension_HasPickupToDeliveryLimits(self)

    def AddNodePrecedence(self, first_node: &#34;int64&#34;, second_node: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingDimension_AddNodePrecedence(self, first_node, second_node, offset)

    def GetSpanUpperBoundForVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingDimension_GetSpanUpperBoundForVehicle(self, vehicle)

    def GetSpanCostCoefficientForVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingDimension_GetSpanCostCoefficientForVehicle(self, vehicle)

    def global_span_cost_coefficient(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingDimension_global_span_cost_coefficient(self)

    def GetGlobalOptimizerOffset(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingDimension_GetGlobalOptimizerOffset(self)

    def GetLocalOptimizerOffsetForVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingDimension_GetLocalOptimizerOffsetForVehicle(self, vehicle)

# Register RoutingDimension in _pywrapcp:
_pywrapcp.RoutingDimension_swigregister(RoutingDimension)


def MakeSetValuesFromTargets(solver: &#34;Solver&#34;, variables: &#34;std::vector&lt; operations_research::IntVar * &gt;&#34;, targets: &#34;std::vector&lt; int64 &gt;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    r&#34;&#34;&#34; A decision builder which tries to assign values to variables as close as possible to target values first.&#34;&#34;&#34;
    return _pywrapcp.MakeSetValuesFromTargets(solver, variables, targets)

def SolveModelWithSat(model: &#34;RoutingModel&#34;, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;, initial_solution: &#34;Assignment&#34;, solution: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Attempts to solve the model using the cp-sat solver. As of 5/2019, will solve the TSP corresponding to the model if it has a single vehicle. Therefore the resulting solution might not actually be feasible. Will return false if a solution could not be found.&#34;&#34;&#34;
    return _pywrapcp.SolveModelWithSat(model, search_parameters, initial_solution, solution)
class BasePathFilter(IntVarLocalSearchFilter):
    r&#34;&#34;&#34; Generic path-based filter class.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_BasePathFilter

    def Accept(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;, objective_min: &#34;int64&#34;, objective_max: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.BasePathFilter_Accept(self, delta, deltadelta, objective_min, objective_max)

    def OnSynchronize(self, delta: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BasePathFilter_OnSynchronize(self, delta)

# Register BasePathFilter in _pywrapcp:
_pywrapcp.BasePathFilter_swigregister(BasePathFilter)

class CPFeasibilityFilter(IntVarLocalSearchFilter):
    r&#34;&#34;&#34; This filter accepts deltas for which the assignment satisfies the constraints of the Solver. This is verified by keeping an internal copy of the assignment with all Next vars and their updated values, and calling RestoreAssignment() on the assignment+delta. exception of Next Vars (woud fail on large instances). WARNING: In the case of mandatory nodes, when all vehicles are currently being used in the solution but uninserted nodes still remain, this filter will reject the solution, even if the node could be inserted on one of these routes, because all Next vars of vehicle starts are already instantiated.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, routing_model: &#34;RoutingModel&#34;):
        _pywrapcp.CPFeasibilityFilter_swiginit(self, _pywrapcp.new_CPFeasibilityFilter(routing_model))
    __swig_destroy__ = _pywrapcp.delete_CPFeasibilityFilter

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.CPFeasibilityFilter_DebugString(self)

    def Accept(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;, objective_min: &#34;int64&#34;, objective_max: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.CPFeasibilityFilter_Accept(self, delta, deltadelta, objective_min, objective_max)

    def OnSynchronize(self, delta: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.CPFeasibilityFilter_OnSynchronize(self, delta)

# Register CPFeasibilityFilter in _pywrapcp:
_pywrapcp.CPFeasibilityFilter_swigregister(CPFeasibilityFilter)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pywrapcp.DefaultRoutingModelParameters"><code class="name flex">
<span>def <span class="ident">DefaultRoutingModelParameters</span></span>(<span>) -> 'operations_research::RoutingModelParameters'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DefaultRoutingModelParameters() -&gt; &#34;operations_research::RoutingModelParameters&#34;:
    return _pywrapcp.DefaultRoutingModelParameters()</code></pre>
</details>
</dd>
<dt id="pywrapcp.DefaultRoutingSearchParameters"><code class="name flex">
<span>def <span class="ident">DefaultRoutingSearchParameters</span></span>(<span>) -> 'operations_research::RoutingSearchParameters'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DefaultRoutingSearchParameters() -&gt; &#34;operations_research::RoutingSearchParameters&#34;:
    return _pywrapcp.DefaultRoutingSearchParameters()</code></pre>
</details>
</dd>
<dt id="pywrapcp.FindErrorInRoutingSearchParameters"><code class="name flex">
<span>def <span class="ident">FindErrorInRoutingSearchParameters</span></span>(<span>search_parameters: operations_research::RoutingSearchParameters const &) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an empty std::string if the routing search parameters are valid, and a non-empty, human readable error description if they're not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FindErrorInRoutingSearchParameters(search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;) -&gt; &#34;std::string&#34;:
    r&#34;&#34;&#34; Returns an empty std::string if the routing search parameters are valid, and a non-empty, human readable error description if they&#39;re not.&#34;&#34;&#34;
    return _pywrapcp.FindErrorInRoutingSearchParameters(search_parameters)</code></pre>
</details>
</dd>
<dt id="pywrapcp.MakeSetValuesFromTargets"><code class="name flex">
<span>def <span class="ident">MakeSetValuesFromTargets</span></span>(<span>solver: Solver, variables: std::vector< operations_research::IntVar * >, targets: std::vector< int64 >) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>A decision builder which tries to assign values to variables as close as possible to target values first.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MakeSetValuesFromTargets(solver: &#34;Solver&#34;, variables: &#34;std::vector&lt; operations_research::IntVar * &gt;&#34;, targets: &#34;std::vector&lt; int64 &gt;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    r&#34;&#34;&#34; A decision builder which tries to assign values to variables as close as possible to target values first.&#34;&#34;&#34;
    return _pywrapcp.MakeSetValuesFromTargets(solver, variables, targets)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolveModelWithSat"><code class="name flex">
<span>def <span class="ident">SolveModelWithSat</span></span>(<span>model: RoutingModel, search_parameters: operations_research::RoutingSearchParameters const &, initial_solution: Assignment, solution: Assignment) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Attempts to solve the model using the cp-sat solver. As of 5/2019, will solve the TSP corresponding to the model if it has a single vehicle. Therefore the resulting solution might not actually be feasible. Will return false if a solution could not be found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SolveModelWithSat(model: &#34;RoutingModel&#34;, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;, initial_solution: &#34;Assignment&#34;, solution: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Attempts to solve the model using the cp-sat solver. As of 5/2019, will solve the TSP corresponding to the model if it has a single vehicle. Therefore the resulting solution might not actually be feasible. Will return false if a solution could not be found.&#34;&#34;&#34;
    return _pywrapcp.SolveModelWithSat(model, search_parameters, initial_solution, solution)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver_DefaultSolverParameters"><code class="name flex">
<span>def <span class="ident">Solver_DefaultSolverParameters</span></span>(<span>) -> 'operations_research::ConstraintSolverParameters'</span>
</code></dt>
<dd>
<div class="desc"><p>Create a ConstraintSolverParameters proto with all the default values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Solver_DefaultSolverParameters() -&gt; &#34;operations_research::ConstraintSolverParameters&#34;:
    r&#34;&#34;&#34; Create a ConstraintSolverParameters proto with all the default values.&#34;&#34;&#34;
    return _pywrapcp.Solver_DefaultSolverParameters()</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver_MemoryUsage"><code class="name flex">
<span>def <span class="ident">Solver_MemoryUsage</span></span>(<span>) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Current memory usage in bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Solver_MemoryUsage() -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Current memory usage in bytes&#34;&#34;&#34;
    return _pywrapcp.Solver_MemoryUsage()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pywrapcp.Assignment"><code class="flex name class">
<span>class <span class="ident">Assignment</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An Assignment is a variable -&gt; domains mapping, used to report solutions to the user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Assignment(PropagationBaseObject):
    r&#34;&#34;&#34; An Assignment is a variable -&gt; domains mapping, used to report solutions to the user.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Clear(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Clear(self)

    def Empty(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment_Empty(self)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.Assignment_Size(self)

    def NumIntVars(self) -&gt; &#34;int&#34;:
        return _pywrapcp.Assignment_NumIntVars(self)

    def NumIntervalVars(self) -&gt; &#34;int&#34;:
        return _pywrapcp.Assignment_NumIntervalVars(self)

    def NumSequenceVars(self) -&gt; &#34;int&#34;:
        return _pywrapcp.Assignment_NumSequenceVars(self)

    def Store(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Store(self)

    def Restore(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Restore(self)

    def Load(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Load(self, *args)

    def Save(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Save(self, *args)

    def AddObjective(self, v: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_AddObjective(self, v)

    def Objective(self) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.Assignment_Objective(self)

    def HasObjective(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment_HasObjective(self)

    def ObjectiveMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_ObjectiveMin(self)

    def ObjectiveMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_ObjectiveMax(self)

    def ObjectiveValue(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_ObjectiveValue(self)

    def ObjectiveBound(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment_ObjectiveBound(self)

    def SetObjectiveMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetObjectiveMin(self, m)

    def SetObjectiveMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetObjectiveMax(self, m)

    def SetObjectiveValue(self, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetObjectiveValue(self, value)

    def SetObjectiveRange(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetObjectiveRange(self, l, u)

    def Min(self, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_Min(self, var)

    def Max(self, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_Max(self, var)

    def Value(self, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_Value(self, var)

    def Bound(self, var: &#34;IntVar&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment_Bound(self, var)

    def SetMin(self, var: &#34;IntVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetMin(self, var, m)

    def SetMax(self, var: &#34;IntVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetMax(self, var, m)

    def SetRange(self, var: &#34;IntVar&#34;, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetRange(self, var, l, u)

    def SetValue(self, var: &#34;IntVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetValue(self, var, value)

    def StartMin(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_StartMin(self, var)

    def StartMax(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_StartMax(self, var)

    def StartValue(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_StartValue(self, var)

    def DurationMin(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_DurationMin(self, var)

    def DurationMax(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_DurationMax(self, var)

    def DurationValue(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_DurationValue(self, var)

    def EndMin(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_EndMin(self, var)

    def EndMax(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_EndMax(self, var)

    def EndValue(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_EndValue(self, var)

    def PerformedMin(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_PerformedMin(self, var)

    def PerformedMax(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_PerformedMax(self, var)

    def PerformedValue(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.Assignment_PerformedValue(self, var)

    def SetStartMin(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetStartMin(self, var, m)

    def SetStartMax(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetStartMax(self, var, m)

    def SetStartRange(self, var: &#34;IntervalVar&#34;, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetStartRange(self, var, mi, ma)

    def SetStartValue(self, var: &#34;IntervalVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetStartValue(self, var, value)

    def SetDurationMin(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetDurationMin(self, var, m)

    def SetDurationMax(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetDurationMax(self, var, m)

    def SetDurationRange(self, var: &#34;IntervalVar&#34;, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetDurationRange(self, var, mi, ma)

    def SetDurationValue(self, var: &#34;IntervalVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetDurationValue(self, var, value)

    def SetEndMin(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetEndMin(self, var, m)

    def SetEndMax(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetEndMax(self, var, m)

    def SetEndRange(self, var: &#34;IntervalVar&#34;, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetEndRange(self, var, mi, ma)

    def SetEndValue(self, var: &#34;IntervalVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetEndValue(self, var, value)

    def SetPerformedMin(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetPerformedMin(self, var, m)

    def SetPerformedMax(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetPerformedMax(self, var, m)

    def SetPerformedRange(self, var: &#34;IntervalVar&#34;, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetPerformedRange(self, var, mi, ma)

    def SetPerformedValue(self, var: &#34;IntervalVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetPerformedValue(self, var, value)

    def Add(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Add(self, *args)

    def ForwardSequence(self, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.Assignment_ForwardSequence(self, var)

    def BackwardSequence(self, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.Assignment_BackwardSequence(self, var)

    def Unperformed(self, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.Assignment_Unperformed(self, var)

    def SetSequence(self, var: &#34;SequenceVar&#34;, forward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;, backward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;, unperformed: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetSequence(self, var, forward_sequence, backward_sequence, unperformed)

    def SetForwardSequence(self, var: &#34;SequenceVar&#34;, forward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetForwardSequence(self, var, forward_sequence)

    def SetBackwardSequence(self, var: &#34;SequenceVar&#34;, backward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetBackwardSequence(self, var, backward_sequence)

    def SetUnperformed(self, var: &#34;SequenceVar&#34;, unperformed: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_SetUnperformed(self, var, unperformed)

    def Activate(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Activate(self, *args)

    def Deactivate(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.Assignment_Deactivate(self, *args)

    def Activated(self, *args) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment_Activated(self, *args)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Assignment_DebugString(self)

    def IntVarContainer(self) -&gt; &#34;operations_research::Assignment::IntContainer const &amp;&#34;:
        return _pywrapcp.Assignment_IntVarContainer(self)

    def MutableIntVarContainer(self) -&gt; &#34;operations_research::Assignment::IntContainer *&#34;:
        return _pywrapcp.Assignment_MutableIntVarContainer(self)

    def IntervalVarContainer(self) -&gt; &#34;operations_research::Assignment::IntervalContainer const &amp;&#34;:
        return _pywrapcp.Assignment_IntervalVarContainer(self)

    def MutableIntervalVarContainer(self) -&gt; &#34;operations_research::Assignment::IntervalContainer *&#34;:
        return _pywrapcp.Assignment_MutableIntervalVarContainer(self)

    def SequenceVarContainer(self) -&gt; &#34;operations_research::Assignment::SequenceContainer const &amp;&#34;:
        return _pywrapcp.Assignment_SequenceVarContainer(self)

    def MutableSequenceVarContainer(self) -&gt; &#34;operations_research::Assignment::SequenceContainer *&#34;:
        return _pywrapcp.Assignment_MutableSequenceVarContainer(self)

    def __eq__(self, assignment: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment___eq__(self, assignment)

    def __ne__(self, assignment: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.Assignment___ne__(self, assignment)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.Assignment.Activate"><code class="name flex">
<span>def <span class="ident">Activate</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Activate(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_Activate(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Activated"><code class="name flex">
<span>def <span class="ident">Activated</span></span>(<span>self, *args) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Activated(self, *args) -&gt; &#34;bool&#34;:
    return _pywrapcp.Assignment_Activated(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Add"><code class="name flex">
<span>def <span class="ident">Add</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Add(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_Add(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.AddObjective"><code class="name flex">
<span>def <span class="ident">AddObjective</span></span>(<span>self, v: IntVar) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddObjective(self, v: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_AddObjective(self, v)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.BackwardSequence"><code class="name flex">
<span>def <span class="ident">BackwardSequence</span></span>(<span>self, var: SequenceVar) -> 'std::vector< int > const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BackwardSequence(self, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
    return _pywrapcp.Assignment_BackwardSequence(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Bound"><code class="name flex">
<span>def <span class="ident">Bound</span></span>(<span>self, var: IntVar) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Bound(self, var: &#34;IntVar&#34;) -&gt; &#34;bool&#34;:
    return _pywrapcp.Assignment_Bound(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Clear"><code class="name flex">
<span>def <span class="ident">Clear</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Clear(self) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_Clear(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Deactivate"><code class="name flex">
<span>def <span class="ident">Deactivate</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Deactivate(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_Deactivate(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.Assignment_DebugString(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.DurationMax"><code class="name flex">
<span>def <span class="ident">DurationMax</span></span>(<span>self, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DurationMax(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_DurationMax(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.DurationMin"><code class="name flex">
<span>def <span class="ident">DurationMin</span></span>(<span>self, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DurationMin(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_DurationMin(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.DurationValue"><code class="name flex">
<span>def <span class="ident">DurationValue</span></span>(<span>self, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DurationValue(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_DurationValue(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Empty"><code class="name flex">
<span>def <span class="ident">Empty</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Empty(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.Assignment_Empty(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.EndMax"><code class="name flex">
<span>def <span class="ident">EndMax</span></span>(<span>self, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndMax(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_EndMax(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.EndMin"><code class="name flex">
<span>def <span class="ident">EndMin</span></span>(<span>self, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndMin(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_EndMin(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.EndValue"><code class="name flex">
<span>def <span class="ident">EndValue</span></span>(<span>self, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndValue(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_EndValue(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.ForwardSequence"><code class="name flex">
<span>def <span class="ident">ForwardSequence</span></span>(<span>self, var: SequenceVar) -> 'std::vector< int > const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ForwardSequence(self, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
    return _pywrapcp.Assignment_ForwardSequence(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.HasObjective"><code class="name flex">
<span>def <span class="ident">HasObjective</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HasObjective(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.Assignment_HasObjective(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.IntVarContainer"><code class="name flex">
<span>def <span class="ident">IntVarContainer</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a>::IntContainer const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IntVarContainer(self) -&gt; &#34;operations_research::Assignment::IntContainer const &amp;&#34;:
    return _pywrapcp.Assignment_IntVarContainer(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.IntervalVarContainer"><code class="name flex">
<span>def <span class="ident">IntervalVarContainer</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a>::IntervalContainer const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IntervalVarContainer(self) -&gt; &#34;operations_research::Assignment::IntervalContainer const &amp;&#34;:
    return _pywrapcp.Assignment_IntervalVarContainer(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Load"><code class="name flex">
<span>def <span class="ident">Load</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Load(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_Load(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Max"><code class="name flex">
<span>def <span class="ident">Max</span></span>(<span>self, var: IntVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Max(self, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_Max(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Min"><code class="name flex">
<span>def <span class="ident">Min</span></span>(<span>self, var: IntVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Min(self, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_Min(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.MutableIntVarContainer"><code class="name flex">
<span>def <span class="ident">MutableIntVarContainer</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a>::IntContainer *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MutableIntVarContainer(self) -&gt; &#34;operations_research::Assignment::IntContainer *&#34;:
    return _pywrapcp.Assignment_MutableIntVarContainer(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.MutableIntervalVarContainer"><code class="name flex">
<span>def <span class="ident">MutableIntervalVarContainer</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a>::IntervalContainer *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MutableIntervalVarContainer(self) -&gt; &#34;operations_research::Assignment::IntervalContainer *&#34;:
    return _pywrapcp.Assignment_MutableIntervalVarContainer(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.MutableSequenceVarContainer"><code class="name flex">
<span>def <span class="ident">MutableSequenceVarContainer</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a>::SequenceContainer *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MutableSequenceVarContainer(self) -&gt; &#34;operations_research::Assignment::SequenceContainer *&#34;:
    return _pywrapcp.Assignment_MutableSequenceVarContainer(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.NumIntVars"><code class="name flex">
<span>def <span class="ident">NumIntVars</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NumIntVars(self) -&gt; &#34;int&#34;:
    return _pywrapcp.Assignment_NumIntVars(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.NumIntervalVars"><code class="name flex">
<span>def <span class="ident">NumIntervalVars</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NumIntervalVars(self) -&gt; &#34;int&#34;:
    return _pywrapcp.Assignment_NumIntervalVars(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.NumSequenceVars"><code class="name flex">
<span>def <span class="ident">NumSequenceVars</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NumSequenceVars(self) -&gt; &#34;int&#34;:
    return _pywrapcp.Assignment_NumSequenceVars(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Objective"><code class="name flex">
<span>def <span class="ident">Objective</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Objective(self) -&gt; &#34;operations_research::IntVar *&#34;:
    return _pywrapcp.Assignment_Objective(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.ObjectiveBound"><code class="name flex">
<span>def <span class="ident">ObjectiveBound</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ObjectiveBound(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.Assignment_ObjectiveBound(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.ObjectiveMax"><code class="name flex">
<span>def <span class="ident">ObjectiveMax</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ObjectiveMax(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_ObjectiveMax(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.ObjectiveMin"><code class="name flex">
<span>def <span class="ident">ObjectiveMin</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ObjectiveMin(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_ObjectiveMin(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.ObjectiveValue"><code class="name flex">
<span>def <span class="ident">ObjectiveValue</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ObjectiveValue(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_ObjectiveValue(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.PerformedMax"><code class="name flex">
<span>def <span class="ident">PerformedMax</span></span>(<span>self, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PerformedMax(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_PerformedMax(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.PerformedMin"><code class="name flex">
<span>def <span class="ident">PerformedMin</span></span>(<span>self, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PerformedMin(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_PerformedMin(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.PerformedValue"><code class="name flex">
<span>def <span class="ident">PerformedValue</span></span>(<span>self, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PerformedValue(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_PerformedValue(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Restore"><code class="name flex">
<span>def <span class="ident">Restore</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Restore(self) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_Restore(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Save"><code class="name flex">
<span>def <span class="ident">Save</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Save(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_Save(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SequenceVarContainer"><code class="name flex">
<span>def <span class="ident">SequenceVarContainer</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a>::SequenceContainer const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SequenceVarContainer(self) -&gt; &#34;operations_research::Assignment::SequenceContainer const &amp;&#34;:
    return _pywrapcp.Assignment_SequenceVarContainer(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetBackwardSequence"><code class="name flex">
<span>def <span class="ident">SetBackwardSequence</span></span>(<span>self, var: SequenceVar, backward_sequence: std::vector< int > const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetBackwardSequence(self, var: &#34;SequenceVar&#34;, backward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetBackwardSequence(self, var, backward_sequence)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetDurationMax"><code class="name flex">
<span>def <span class="ident">SetDurationMax</span></span>(<span>self, var: IntervalVar, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetDurationMax(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetDurationMax(self, var, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetDurationMin"><code class="name flex">
<span>def <span class="ident">SetDurationMin</span></span>(<span>self, var: IntervalVar, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetDurationMin(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetDurationMin(self, var, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetDurationRange"><code class="name flex">
<span>def <span class="ident">SetDurationRange</span></span>(<span>self, var: IntervalVar, mi: int64, ma: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetDurationRange(self, var: &#34;IntervalVar&#34;, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetDurationRange(self, var, mi, ma)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetDurationValue"><code class="name flex">
<span>def <span class="ident">SetDurationValue</span></span>(<span>self, var: IntervalVar, value: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetDurationValue(self, var: &#34;IntervalVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetDurationValue(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetEndMax"><code class="name flex">
<span>def <span class="ident">SetEndMax</span></span>(<span>self, var: IntervalVar, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetEndMax(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetEndMax(self, var, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetEndMin"><code class="name flex">
<span>def <span class="ident">SetEndMin</span></span>(<span>self, var: IntervalVar, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetEndMin(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetEndMin(self, var, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetEndRange"><code class="name flex">
<span>def <span class="ident">SetEndRange</span></span>(<span>self, var: IntervalVar, mi: int64, ma: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetEndRange(self, var: &#34;IntervalVar&#34;, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetEndRange(self, var, mi, ma)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetEndValue"><code class="name flex">
<span>def <span class="ident">SetEndValue</span></span>(<span>self, var: IntervalVar, value: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetEndValue(self, var: &#34;IntervalVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetEndValue(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetForwardSequence"><code class="name flex">
<span>def <span class="ident">SetForwardSequence</span></span>(<span>self, var: SequenceVar, forward_sequence: std::vector< int > const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetForwardSequence(self, var: &#34;SequenceVar&#34;, forward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetForwardSequence(self, var, forward_sequence)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetMax"><code class="name flex">
<span>def <span class="ident">SetMax</span></span>(<span>self, var: IntVar, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetMax(self, var: &#34;IntVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetMax(self, var, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetMin"><code class="name flex">
<span>def <span class="ident">SetMin</span></span>(<span>self, var: IntVar, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetMin(self, var: &#34;IntVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetMin(self, var, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetObjectiveMax"><code class="name flex">
<span>def <span class="ident">SetObjectiveMax</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetObjectiveMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetObjectiveMax(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetObjectiveMin"><code class="name flex">
<span>def <span class="ident">SetObjectiveMin</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetObjectiveMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetObjectiveMin(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetObjectiveRange"><code class="name flex">
<span>def <span class="ident">SetObjectiveRange</span></span>(<span>self, l: int64, u: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetObjectiveRange(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetObjectiveRange(self, l, u)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetObjectiveValue"><code class="name flex">
<span>def <span class="ident">SetObjectiveValue</span></span>(<span>self, value: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetObjectiveValue(self, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetObjectiveValue(self, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetPerformedMax"><code class="name flex">
<span>def <span class="ident">SetPerformedMax</span></span>(<span>self, var: IntervalVar, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetPerformedMax(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetPerformedMax(self, var, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetPerformedMin"><code class="name flex">
<span>def <span class="ident">SetPerformedMin</span></span>(<span>self, var: IntervalVar, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetPerformedMin(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetPerformedMin(self, var, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetPerformedRange"><code class="name flex">
<span>def <span class="ident">SetPerformedRange</span></span>(<span>self, var: IntervalVar, mi: int64, ma: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetPerformedRange(self, var: &#34;IntervalVar&#34;, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetPerformedRange(self, var, mi, ma)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetPerformedValue"><code class="name flex">
<span>def <span class="ident">SetPerformedValue</span></span>(<span>self, var: IntervalVar, value: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetPerformedValue(self, var: &#34;IntervalVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetPerformedValue(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetRange"><code class="name flex">
<span>def <span class="ident">SetRange</span></span>(<span>self, var: IntVar, l: int64, u: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetRange(self, var: &#34;IntVar&#34;, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetRange(self, var, l, u)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetSequence"><code class="name flex">
<span>def <span class="ident">SetSequence</span></span>(<span>self, var: SequenceVar, forward_sequence: std::vector< int > const &, backward_sequence: std::vector< int > const &, unperformed: std::vector< int > const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetSequence(self, var: &#34;SequenceVar&#34;, forward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;, backward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;, unperformed: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetSequence(self, var, forward_sequence, backward_sequence, unperformed)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetStartMax"><code class="name flex">
<span>def <span class="ident">SetStartMax</span></span>(<span>self, var: IntervalVar, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetStartMax(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetStartMax(self, var, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetStartMin"><code class="name flex">
<span>def <span class="ident">SetStartMin</span></span>(<span>self, var: IntervalVar, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetStartMin(self, var: &#34;IntervalVar&#34;, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetStartMin(self, var, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetStartRange"><code class="name flex">
<span>def <span class="ident">SetStartRange</span></span>(<span>self, var: IntervalVar, mi: int64, ma: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetStartRange(self, var: &#34;IntervalVar&#34;, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetStartRange(self, var, mi, ma)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetStartValue"><code class="name flex">
<span>def <span class="ident">SetStartValue</span></span>(<span>self, var: IntervalVar, value: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetStartValue(self, var: &#34;IntervalVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetStartValue(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetUnperformed"><code class="name flex">
<span>def <span class="ident">SetUnperformed</span></span>(<span>self, var: SequenceVar, unperformed: std::vector< int > const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetUnperformed(self, var: &#34;SequenceVar&#34;, unperformed: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetUnperformed(self, var, unperformed)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.SetValue"><code class="name flex">
<span>def <span class="ident">SetValue</span></span>(<span>self, var: IntVar, value: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetValue(self, var: &#34;IntVar&#34;, value: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_SetValue(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Size"><code class="name flex">
<span>def <span class="ident">Size</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Size(self) -&gt; &#34;int&#34;:
    return _pywrapcp.Assignment_Size(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.StartMax"><code class="name flex">
<span>def <span class="ident">StartMax</span></span>(<span>self, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartMax(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_StartMax(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.StartMin"><code class="name flex">
<span>def <span class="ident">StartMin</span></span>(<span>self, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartMin(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_StartMin(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.StartValue"><code class="name flex">
<span>def <span class="ident">StartValue</span></span>(<span>self, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartValue(self, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_StartValue(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Store"><code class="name flex">
<span>def <span class="ident">Store</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Store(self) -&gt; &#34;void&#34;:
    return _pywrapcp.Assignment_Store(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Unperformed"><code class="name flex">
<span>def <span class="ident">Unperformed</span></span>(<span>self, var: SequenceVar) -> 'std::vector< int > const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Unperformed(self, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
    return _pywrapcp.Assignment_Unperformed(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Assignment.Value"><code class="name flex">
<span>def <span class="ident">Value</span></span>(<span>self, var: IntVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Value(self, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.Assignment_Value(self, var)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.PropagationBaseObject.Name" href="#pywrapcp.PropagationBaseObject.Name">Name</a></code></li>
<li><code><a title="pywrapcp.PropagationBaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.AssignmentElement"><code class="flex name class">
<span>class <span class="ident">AssignmentElement</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssignmentElement(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Activate(self) -&gt; &#34;void&#34;:
        return _pywrapcp.AssignmentElement_Activate(self)

    def Deactivate(self) -&gt; &#34;void&#34;:
        return _pywrapcp.AssignmentElement_Deactivate(self)

    def Activated(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.AssignmentElement_Activated(self)
    __swig_destroy__ = _pywrapcp.delete_AssignmentElement</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.IntVarElement" href="#pywrapcp.IntVarElement">IntVarElement</a></li>
<li><a title="pywrapcp.IntervalVarElement" href="#pywrapcp.IntervalVarElement">IntervalVarElement</a></li>
<li><a title="pywrapcp.SequenceVarElement" href="#pywrapcp.SequenceVarElement">SequenceVarElement</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapcp.AssignmentElement.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<div class="desc"><p>The membership flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.AssignmentElement.Activate"><code class="name flex">
<span>def <span class="ident">Activate</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Activate(self) -&gt; &#34;void&#34;:
    return _pywrapcp.AssignmentElement_Activate(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.AssignmentElement.Activated"><code class="name flex">
<span>def <span class="ident">Activated</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Activated(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.AssignmentElement_Activated(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.AssignmentElement.Deactivate"><code class="name flex">
<span>def <span class="ident">Deactivate</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Deactivate(self) -&gt; &#34;void&#34;:
    return _pywrapcp.AssignmentElement_Deactivate(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywrapcp.BaseLns"><code class="flex name class">
<span>class <span class="ident">BaseLns</span></span>
<span>(</span><span>vars: std::vector< operations_research::IntVar * > const &)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the base class for building an Lns operator. An Lns fragment is a collection of variables which will be relaxed. Fragments are built with NextFragment(), which returns false if there are no more fragments to build. Optionally one can override InitFragments, which is called from LocalSearchOperator::Start to initialize fragment data. Here's a sample relaxing one variable at a time: class OneVarLns : public BaseLns {
public:
OneVarLns(const std::vector<IntVar*>&amp; vars) : BaseLns(vars), index_(0) {}
virtual ~OneVarLns() {}
virtual void InitFragments() { index_ = 0; }
virtual bool NextFragment() {
const int size = Size();
if (index_ &lt; size) {
AppendToFragment(index_);
++index_;
return true;
} else {
return false;
}
}
private:
int index_; };</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseLns(IntVarLocalSearchOperator):
    r&#34;&#34;&#34; This is the base class for building an Lns operator. An Lns fragment is a collection of variables which will be relaxed. Fragments are built with NextFragment(), which returns false if there are no more fragments to build. Optionally one can override InitFragments, which is called from LocalSearchOperator::Start to initialize fragment data. Here&#39;s a sample relaxing one variable at a time: class OneVarLns : public BaseLns {  public:   OneVarLns(const std::vector&lt;IntVar*&gt;&amp; vars) : BaseLns(vars), index_(0) {}   virtual ~OneVarLns() {}   virtual void InitFragments() { index_ = 0; }   virtual bool NextFragment() {     const int size = Size();     if (index_ &lt; size) {       AppendToFragment(index_);       ++index_;       return true;     } else {       return false;     }   }  private:   int index_; };&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;):
        if self.__class__ == BaseLns:
            _self = None
        else:
            _self = self
        _pywrapcp.BaseLns_swiginit(self, _pywrapcp.new_BaseLns(_self, vars))
    __swig_destroy__ = _pywrapcp.delete_BaseLns

    def InitFragments(self) -&gt; &#34;void&#34;:
        return _pywrapcp.BaseLns_InitFragments(self)

    def NextFragment(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.BaseLns_NextFragment(self)

    def AppendToFragment(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BaseLns_AppendToFragment(self, index)

    def FragmentSize(self) -&gt; &#34;int&#34;:
        return _pywrapcp.BaseLns_FragmentSize(self)

    def __getitem__(self, index: &#34;int&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.BaseLns___getitem__(self, index)

    def __len__(self) -&gt; &#34;int&#34;:
        return _pywrapcp.BaseLns___len__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_BaseLns(self)
        return weakref.proxy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.IntVarLocalSearchOperator" href="#pywrapcp.IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></li>
<li><a title="pywrapcp.IntVarLocalSearchOperatorTemplate" href="#pywrapcp.IntVarLocalSearchOperatorTemplate">IntVarLocalSearchOperatorTemplate</a></li>
<li><a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.BaseLns.AppendToFragment"><code class="name flex">
<span>def <span class="ident">AppendToFragment</span></span>(<span>self, index: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AppendToFragment(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.BaseLns_AppendToFragment(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.BaseLns.FragmentSize"><code class="name flex">
<span>def <span class="ident">FragmentSize</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FragmentSize(self) -&gt; &#34;int&#34;:
    return _pywrapcp.BaseLns_FragmentSize(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.BaseLns.InitFragments"><code class="name flex">
<span>def <span class="ident">InitFragments</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def InitFragments(self) -&gt; &#34;void&#34;:
    return _pywrapcp.BaseLns_InitFragments(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.BaseLns.NextFragment"><code class="name flex">
<span>def <span class="ident">NextFragment</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NextFragment(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.BaseLns_NextFragment(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.IntVarLocalSearchOperator" href="#pywrapcp.IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.NextNeighbor" href="#pywrapcp.IntVarLocalSearchOperator.NextNeighbor">NextNeighbor</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.OnStart" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.OnStart">OnStart</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.OneNeighbor" href="#pywrapcp.IntVarLocalSearchOperator.OneNeighbor">OneNeighbor</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.Start" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.Start">Start</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.Value" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.Value">Value</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.BaseObject"><code class="flex name class">
<span>class <span class="ident">BaseObject</span></span>
</code></dt>
<dd>
<div class="desc"><p>A BaseObject is the root of all reversibly allocated objects. A DebugString method and the associated.. code-block:: c++</p>
<p>operator&lt;are implemented as a convenience.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseObject(object):
    r&#34;&#34;&#34;
    A BaseObject is the root of all reversibly allocated objects. A DebugString method and the associated.. code-block:: c++

       operator&lt;are implemented as a convenience.
    &#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self):
        if self.__class__ == BaseObject:
            _self = None
        else:
            _self = self
        _pywrapcp.BaseObject_swiginit(self, _pywrapcp.new_BaseObject(_self, ))
    __swig_destroy__ = _pywrapcp.delete_BaseObject

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.BaseObject_DebugString(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.BaseObject___str__(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.BaseObject___repr__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_BaseObject(self)
        return weakref.proxy(self)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a></li>
<li><a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a></li>
<li><a title="pywrapcp.Demon" href="#pywrapcp.Demon">Demon</a></li>
<li><a title="pywrapcp.IntVarIterator" href="#pywrapcp.IntVarIterator">IntVarIterator</a></li>
<li><a title="pywrapcp.LocalSearchFilter" href="#pywrapcp.LocalSearchFilter">LocalSearchFilter</a></li>
<li><a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a></li>
<li><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></li>
<li><a title="pywrapcp.RoutingModelVisitor" href="#pywrapcp.RoutingModelVisitor">RoutingModelVisitor</a></li>
<li><a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapcp.BaseObject.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<div class="desc"><p>The membership flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.BaseObject.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.BaseObject_DebugString(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywrapcp.BasePathFilter"><code class="flex name class">
<span>class <span class="ident">BasePathFilter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic path-based filter class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasePathFilter(IntVarLocalSearchFilter):
    r&#34;&#34;&#34; Generic path-based filter class.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_BasePathFilter

    def Accept(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;, objective_min: &#34;int64&#34;, objective_max: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.BasePathFilter_Accept(self, delta, deltadelta, objective_min, objective_max)

    def OnSynchronize(self, delta: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BasePathFilter_OnSynchronize(self, delta)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.IntVarLocalSearchFilter" href="#pywrapcp.IntVarLocalSearchFilter">IntVarLocalSearchFilter</a></li>
<li><a title="pywrapcp.LocalSearchFilter" href="#pywrapcp.LocalSearchFilter">LocalSearchFilter</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.BasePathFilter.OnSynchronize"><code class="name flex">
<span>def <span class="ident">OnSynchronize</span></span>(<span>self, delta: Assignment) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OnSynchronize(self, delta: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.BasePathFilter_OnSynchronize(self, delta)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.IntVarLocalSearchFilter" href="#pywrapcp.IntVarLocalSearchFilter">IntVarLocalSearchFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.IntVarLocalSearchFilter.Accept" href="#pywrapcp.LocalSearchFilter.Accept">Accept</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchFilter.Synchronize" href="#pywrapcp.IntVarLocalSearchFilter.Synchronize">Synchronize</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchFilter.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.BooleanVar"><code class="flex name class">
<span>class <span class="ident">BooleanVar</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The class IntVar is a subset of IntExpr. In addition to the IntExpr protocol, it offers persistence, removing values from the domains, and a finer model for events.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BooleanVar(IntVar):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def Min(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.BooleanVar_Min(self)

    def SetMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_SetMin(self, m)

    def Max(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.BooleanVar_Max(self)

    def SetMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_SetMax(self, m)

    def SetRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_SetRange(self, mi, ma)

    def Bound(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.BooleanVar_Bound(self)

    def Value(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.BooleanVar_Value(self)

    def RemoveValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_RemoveValue(self, v)

    def RemoveInterval(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_RemoveInterval(self, l, u)

    def WhenBound(self, d: &#34;Demon&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_WhenBound(self, d)

    def WhenRange(self, d: &#34;Demon&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_WhenRange(self, d)

    def WhenDomain(self, d: &#34;Demon&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.BooleanVar_WhenDomain(self, d)

    def Size(self) -&gt; &#34;uint64&#34;:
        return _pywrapcp.BooleanVar_Size(self)

    def Contains(self, v: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.BooleanVar_Contains(self, v)

    def HoleIteratorAux(self, reversible: &#34;bool&#34;) -&gt; &#34;operations_research::IntVarIterator *&#34;:
        return _pywrapcp.BooleanVar_HoleIteratorAux(self, reversible)

    def DomainIteratorAux(self, reversible: &#34;bool&#34;) -&gt; &#34;operations_research::IntVarIterator *&#34;:
        return _pywrapcp.BooleanVar_DomainIteratorAux(self, reversible)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.BooleanVar_DebugString(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a></li>
<li><a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a></li>
<li><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.BooleanVar.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.BooleanVar_DebugString(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.BooleanVar.Max"><code class="name flex">
<span>def <span class="ident">Max</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Max(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.BooleanVar_Max(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.BooleanVar.Min"><code class="name flex">
<span>def <span class="ident">Min</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Min(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.BooleanVar_Min(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.BooleanVar.SetMax"><code class="name flex">
<span>def <span class="ident">SetMax</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.BooleanVar_SetMax(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.BooleanVar.SetMin"><code class="name flex">
<span>def <span class="ident">SetMin</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.BooleanVar_SetMin(self, m)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.IntVar.Bound" href="#pywrapcp.IntExpr.Bound">Bound</a></code></li>
<li><code><a title="pywrapcp.IntVar.Contains" href="#pywrapcp.IntVar.Contains">Contains</a></code></li>
<li><code><a title="pywrapcp.IntVar.DomainIteratorAux" href="#pywrapcp.IntVar.DomainIteratorAux">DomainIteratorAux</a></code></li>
<li><code><a title="pywrapcp.IntVar.HoleIteratorAux" href="#pywrapcp.IntVar.HoleIteratorAux">HoleIteratorAux</a></code></li>
<li><code><a title="pywrapcp.IntVar.IsVar" href="#pywrapcp.IntExpr.IsVar">IsVar</a></code></li>
<li><code><a title="pywrapcp.IntVar.Name" href="#pywrapcp.PropagationBaseObject.Name">Name</a></code></li>
<li><code><a title="pywrapcp.IntVar.OldMax" href="#pywrapcp.IntVar.OldMax">OldMax</a></code></li>
<li><code><a title="pywrapcp.IntVar.OldMin" href="#pywrapcp.IntVar.OldMin">OldMin</a></code></li>
<li><code><a title="pywrapcp.IntVar.RemoveInterval" href="#pywrapcp.IntVar.RemoveInterval">RemoveInterval</a></code></li>
<li><code><a title="pywrapcp.IntVar.RemoveValue" href="#pywrapcp.IntVar.RemoveValue">RemoveValue</a></code></li>
<li><code><a title="pywrapcp.IntVar.RemoveValues" href="#pywrapcp.IntVar.RemoveValues">RemoveValues</a></code></li>
<li><code><a title="pywrapcp.IntVar.SetRange" href="#pywrapcp.IntExpr.SetRange">SetRange</a></code></li>
<li><code><a title="pywrapcp.IntVar.SetValue" href="#pywrapcp.IntExpr.SetValue">SetValue</a></code></li>
<li><code><a title="pywrapcp.IntVar.SetValues" href="#pywrapcp.IntVar.SetValues">SetValues</a></code></li>
<li><code><a title="pywrapcp.IntVar.Size" href="#pywrapcp.IntVar.Size">Size</a></code></li>
<li><code><a title="pywrapcp.IntVar.Value" href="#pywrapcp.IntVar.Value">Value</a></code></li>
<li><code><a title="pywrapcp.IntVar.Var" href="#pywrapcp.IntExpr.Var">Var</a></code></li>
<li><code><a title="pywrapcp.IntVar.VarWithName" href="#pywrapcp.IntExpr.VarWithName">VarWithName</a></code></li>
<li><code><a title="pywrapcp.IntVar.WhenBound" href="#pywrapcp.IntVar.WhenBound">WhenBound</a></code></li>
<li><code><a title="pywrapcp.IntVar.WhenDomain" href="#pywrapcp.IntVar.WhenDomain">WhenDomain</a></code></li>
<li><code><a title="pywrapcp.IntVar.WhenRange" href="#pywrapcp.IntExpr.WhenRange">WhenRange</a></code></li>
<li><code><a title="pywrapcp.IntVar.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.CPFeasibilityFilter"><code class="flex name class">
<span>class <span class="ident">CPFeasibilityFilter</span></span>
<span>(</span><span>routing_model: RoutingModel)</span>
</code></dt>
<dd>
<div class="desc"><p>This filter accepts deltas for which the assignment satisfies the constraints of the Solver. This is verified by keeping an internal copy of the assignment with all Next vars and their updated values, and calling RestoreAssignment() on the assignment+delta. exception of Next Vars (woud fail on large instances). WARNING: In the case of mandatory nodes, when all vehicles are currently being used in the solution but uninserted nodes still remain, this filter will reject the solution, even if the node could be inserted on one of these routes, because all Next vars of vehicle starts are already instantiated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CPFeasibilityFilter(IntVarLocalSearchFilter):
    r&#34;&#34;&#34; This filter accepts deltas for which the assignment satisfies the constraints of the Solver. This is verified by keeping an internal copy of the assignment with all Next vars and their updated values, and calling RestoreAssignment() on the assignment+delta. exception of Next Vars (woud fail on large instances). WARNING: In the case of mandatory nodes, when all vehicles are currently being used in the solution but uninserted nodes still remain, this filter will reject the solution, even if the node could be inserted on one of these routes, because all Next vars of vehicle starts are already instantiated.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, routing_model: &#34;RoutingModel&#34;):
        _pywrapcp.CPFeasibilityFilter_swiginit(self, _pywrapcp.new_CPFeasibilityFilter(routing_model))
    __swig_destroy__ = _pywrapcp.delete_CPFeasibilityFilter

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.CPFeasibilityFilter_DebugString(self)

    def Accept(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;, objective_min: &#34;int64&#34;, objective_max: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.CPFeasibilityFilter_Accept(self, delta, deltadelta, objective_min, objective_max)

    def OnSynchronize(self, delta: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.CPFeasibilityFilter_OnSynchronize(self, delta)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.IntVarLocalSearchFilter" href="#pywrapcp.IntVarLocalSearchFilter">IntVarLocalSearchFilter</a></li>
<li><a title="pywrapcp.LocalSearchFilter" href="#pywrapcp.LocalSearchFilter">LocalSearchFilter</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.CPFeasibilityFilter.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.CPFeasibilityFilter_DebugString(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.CPFeasibilityFilter.OnSynchronize"><code class="name flex">
<span>def <span class="ident">OnSynchronize</span></span>(<span>self, delta: Assignment) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OnSynchronize(self, delta: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.CPFeasibilityFilter_OnSynchronize(self, delta)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.IntVarLocalSearchFilter" href="#pywrapcp.IntVarLocalSearchFilter">IntVarLocalSearchFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.IntVarLocalSearchFilter.Accept" href="#pywrapcp.LocalSearchFilter.Accept">Accept</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchFilter.Synchronize" href="#pywrapcp.IntVarLocalSearchFilter.Synchronize">Synchronize</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchFilter.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.ChangeValue"><code class="flex name class">
<span>class <span class="ident">ChangeValue</span></span>
<span>(</span><span>vars: std::vector< operations_research::IntVar * > const &)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines operators which change the value of variables; each neighbor corresponds to <em>one</em> modified variable. Sub-classes have to define ModifyValue which determines what the new variable value is going to be (given the current value and the variable).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChangeValue(IntVarLocalSearchOperator):
    r&#34;&#34;&#34; Defines operators which change the value of variables; each neighbor corresponds to *one* modified variable. Sub-classes have to define ModifyValue which determines what the new variable value is going to be (given the current value and the variable).&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;):
        if self.__class__ == ChangeValue:
            _self = None
        else:
            _self = self
        _pywrapcp.ChangeValue_swiginit(self, _pywrapcp.new_ChangeValue(_self, vars))
    __swig_destroy__ = _pywrapcp.delete_ChangeValue

    def ModifyValue(self, index: &#34;int64&#34;, value: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.ChangeValue_ModifyValue(self, index, value)

    def OneNeighbor(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; This method should not be overridden. Override ModifyValue() instead.&#34;&#34;&#34;
        return _pywrapcp.ChangeValue_OneNeighbor(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_ChangeValue(self)
        return weakref.proxy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.IntVarLocalSearchOperator" href="#pywrapcp.IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></li>
<li><a title="pywrapcp.IntVarLocalSearchOperatorTemplate" href="#pywrapcp.IntVarLocalSearchOperatorTemplate">IntVarLocalSearchOperatorTemplate</a></li>
<li><a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.ChangeValue.ModifyValue"><code class="name flex">
<span>def <span class="ident">ModifyValue</span></span>(<span>self, index: int64, value: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ModifyValue(self, index: &#34;int64&#34;, value: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.ChangeValue_ModifyValue(self, index, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.ChangeValue.OneNeighbor"><code class="name flex">
<span>def <span class="ident">OneNeighbor</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>This method should not be overridden. Override ModifyValue() instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OneNeighbor(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; This method should not be overridden. Override ModifyValue() instead.&#34;&#34;&#34;
    return _pywrapcp.ChangeValue_OneNeighbor(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.IntVarLocalSearchOperator" href="#pywrapcp.IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.NextNeighbor" href="#pywrapcp.IntVarLocalSearchOperator.NextNeighbor">NextNeighbor</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.OnStart" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.OnStart">OnStart</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.Start" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.Start">Start</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.Value" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.Value">Value</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.Constraint"><code class="flex name class">
<span>class <span class="ident">Constraint</span></span>
<span>(</span><span>solver: Solver)</span>
</code></dt>
<dd>
<div class="desc"><p>A constraint is the main modeling object. It provides two methods:
- Post() is responsible for creating the demons and attaching them to
immediate demons().
- InitialPropagate() is called once just after Post and performs
the initial propagation. The subsequent propagations will be performed
by the demons Posted during the post() method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Constraint(PropagationBaseObject):
    r&#34;&#34;&#34; A constraint is the main modeling object. It provides two methods:   - Post() is responsible for creating the demons and attaching them to     immediate demons().   - InitialPropagate() is called once just after Post and performs     the initial propagation. The subsequent propagations will be performed     by the demons Posted during the post() method.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, solver: &#34;Solver&#34;):
        if self.__class__ == Constraint:
            _self = None
        else:
            _self = self
        _pywrapcp.Constraint_swiginit(self, _pywrapcp.new_Constraint(_self, solver))
    __swig_destroy__ = _pywrapcp.delete_Constraint

    def Post(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method is called when the constraint is processed by the solver. Its main usage is to attach demons to variables.&#34;&#34;&#34;
        return _pywrapcp.Constraint_Post(self)

    def InitialPropagateWrapper(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method performs the initial propagation of the constraint. It is called just after the post.&#34;&#34;&#34;
        return _pywrapcp.Constraint_InitialPropagateWrapper(self)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Constraint_DebugString(self)

    def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Creates a Boolean variable representing the status of the constraint (false = constraint is violated, true = constraint is satisfied). It returns nullptr if the constraint does not support this API.&#34;&#34;&#34;
        return _pywrapcp.Constraint_Var(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Constraint___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Constraint___str__(self)

    def __add__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___add__(self, *args)

    def __radd__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___radd__(self, v)

    def __sub__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___sub__(self, *args)

    def __rsub__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___rsub__(self, v)

    def __mul__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___mul__(self, *args)

    def __rmul__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___rmul__(self, v)

    def __floordiv__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___floordiv__(self, v)

    def __neg__(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___neg__(self)

    def __abs__(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint___abs__(self)

    def Square(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint_Square(self)

    def __eq__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint___eq__(self, *args)

    def __ne__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint___ne__(self, *args)

    def __ge__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint___ge__(self, *args)

    def __gt__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint___gt__(self, *args)

    def __le__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint___le__(self, *args)

    def __lt__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint___lt__(self, *args)

    def MapTo(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Constraint_MapTo(self, vars)

    def IndexOf(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Constraint_IndexOf(self, *args)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_Constraint(self)
        return weakref.proxy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.DisjunctiveConstraint" href="#pywrapcp.DisjunctiveConstraint">DisjunctiveConstraint</a></li>
<li><a title="pywrapcp.GlobalVehicleBreaksConstraint" href="#pywrapcp.GlobalVehicleBreaksConstraint">GlobalVehicleBreaksConstraint</a></li>
<li><a title="pywrapcp.Pack" href="#pywrapcp.Pack">Pack</a></li>
<li><a title="pywrapcp.PyConstraint" href="#pywrapcp.PyConstraint">PyConstraint</a></li>
<li><a title="pywrapcp.TypeRegulationsConstraint" href="#pywrapcp.TypeRegulationsConstraint">TypeRegulationsConstraint</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.Constraint.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.Constraint_DebugString(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Constraint.IndexOf"><code class="name flex">
<span>def <span class="ident">IndexOf</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IndexOf(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
    return _pywrapcp.Constraint_IndexOf(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Constraint.InitialPropagateWrapper"><code class="name flex">
<span>def <span class="ident">InitialPropagateWrapper</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method performs the initial propagation of the constraint. It is called just after the post.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def InitialPropagateWrapper(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method performs the initial propagation of the constraint. It is called just after the post.&#34;&#34;&#34;
    return _pywrapcp.Constraint_InitialPropagateWrapper(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Constraint.MapTo"><code class="name flex">
<span>def <span class="ident">MapTo</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MapTo(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Constraint_MapTo(self, vars)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Constraint.Post"><code class="name flex">
<span>def <span class="ident">Post</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method is called when the constraint is processed by the solver. Its main usage is to attach demons to variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Post(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method is called when the constraint is processed by the solver. Its main usage is to attach demons to variables.&#34;&#34;&#34;
    return _pywrapcp.Constraint_Post(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Constraint.Square"><code class="name flex">
<span>def <span class="ident">Square</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Square(self) -&gt; &#34;operations_research::IntExpr *&#34;:
    return _pywrapcp.Constraint_Square(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Constraint.Var"><code class="name flex">
<span>def <span class="ident">Var</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Boolean variable representing the status of the constraint (false = constraint is violated, true = constraint is satisfied). It returns nullptr if the constraint does not support this API.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; Creates a Boolean variable representing the status of the constraint (false = constraint is violated, true = constraint is satisfied). It returns nullptr if the constraint does not support this API.&#34;&#34;&#34;
    return _pywrapcp.Constraint_Var(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.PropagationBaseObject.Name" href="#pywrapcp.PropagationBaseObject.Name">Name</a></code></li>
<li><code><a title="pywrapcp.PropagationBaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.Decision"><code class="flex name class">
<span>class <span class="ident">Decision</span></span>
</code></dt>
<dd>
<div class="desc"><p>A Decision represents a choice point in the search tree. The two main methods are Apply() to go left, or Refute() to go right.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Decision(BaseObject):
    r&#34;&#34;&#34; A Decision represents a choice point in the search tree. The two main methods are Apply() to go left, or Refute() to go right.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self):
        if self.__class__ == Decision:
            _self = None
        else:
            _self = self
        _pywrapcp.Decision_swiginit(self, _pywrapcp.new_Decision(_self, ))
    __swig_destroy__ = _pywrapcp.delete_Decision

    def ApplyWrapper(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Apply will be called first when the decision is executed.&#34;&#34;&#34;
        return _pywrapcp.Decision_ApplyWrapper(self, s)

    def RefuteWrapper(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Refute will be called after a backtrack.&#34;&#34;&#34;
        return _pywrapcp.Decision_RefuteWrapper(self, s)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Decision_DebugString(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Decision___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Decision___str__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_Decision(self)
        return weakref.proxy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.PyDecision" href="#pywrapcp.PyDecision">PyDecision</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.Decision.ApplyWrapper"><code class="name flex">
<span>def <span class="ident">ApplyWrapper</span></span>(<span>self, s: Solver) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Apply will be called first when the decision is executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ApplyWrapper(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Apply will be called first when the decision is executed.&#34;&#34;&#34;
    return _pywrapcp.Decision_ApplyWrapper(self, s)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Decision.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.Decision_DebugString(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Decision.RefuteWrapper"><code class="name flex">
<span>def <span class="ident">RefuteWrapper</span></span>(<span>self, s: Solver) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Refute will be called after a backtrack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RefuteWrapper(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Refute will be called after a backtrack.&#34;&#34;&#34;
    return _pywrapcp.Decision_RefuteWrapper(self, s)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.BaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.DecisionBuilder"><code class="flex name class">
<span>class <span class="ident">DecisionBuilder</span></span>
</code></dt>
<dd>
<div class="desc"><p>A DecisionBuilder is responsible for creating the search tree. The important method is Next(), which returns the next decision to execute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DecisionBuilder(BaseObject):
    r&#34;&#34;&#34; A DecisionBuilder is responsible for creating the search tree. The important method is Next(), which returns the next decision to execute.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self):
        if self.__class__ == DecisionBuilder:
            _self = None
        else:
            _self = self
        _pywrapcp.DecisionBuilder_swiginit(self, _pywrapcp.new_DecisionBuilder(_self, ))
    __swig_destroy__ = _pywrapcp.delete_DecisionBuilder

    def NextWrapper(self, s: &#34;Solver&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        r&#34;&#34;&#34; This is the main method of the decision builder class. It must return a decision (an instance of the class Decision). If it returns nullptr, this means that the decision builder has finished its work.&#34;&#34;&#34;
        return _pywrapcp.DecisionBuilder_NextWrapper(self, s)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.DecisionBuilder_DebugString(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.DecisionBuilder___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.DecisionBuilder___str__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_DecisionBuilder(self)
        return weakref.proxy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.PyDecisionBuilder" href="#pywrapcp.PyDecisionBuilder">PyDecisionBuilder</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.DecisionBuilder.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.DecisionBuilder_DebugString(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.DecisionBuilder.NextWrapper"><code class="name flex">
<span>def <span class="ident">NextWrapper</span></span>(<span>self, s: Solver) -> 'operations_research::<a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>This is the main method of the decision builder class. It must return a decision (an instance of the class Decision). If it returns nullptr, this means that the decision builder has finished its work.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NextWrapper(self, s: &#34;Solver&#34;) -&gt; &#34;operations_research::Decision *&#34;:
    r&#34;&#34;&#34; This is the main method of the decision builder class. It must return a decision (an instance of the class Decision). If it returns nullptr, this means that the decision builder has finished its work.&#34;&#34;&#34;
    return _pywrapcp.DecisionBuilder_NextWrapper(self, s)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.BaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters"><code class="flex name class">
<span>class <span class="ident">DefaultPhaseParameters</span></span>
</code></dt>
<dd>
<div class="desc"><p>This struct holds all parameters for the default search. DefaultPhaseParameters is only used by Solver::MakeDefaultPhase methods. Note this is for advanced users only.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DefaultPhaseParameters(object):
    r&#34;&#34;&#34; This struct holds all parameters for the default search. DefaultPhaseParameters is only used by Solver::MakeDefaultPhase methods. Note this is for advanced users only.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr
    CHOOSE_MAX_SUM_IMPACT = _pywrapcp.DefaultPhaseParameters_CHOOSE_MAX_SUM_IMPACT
    CHOOSE_MAX_AVERAGE_IMPACT = _pywrapcp.DefaultPhaseParameters_CHOOSE_MAX_AVERAGE_IMPACT
    CHOOSE_MAX_VALUE_IMPACT = _pywrapcp.DefaultPhaseParameters_CHOOSE_MAX_VALUE_IMPACT
    SELECT_MIN_IMPACT = _pywrapcp.DefaultPhaseParameters_SELECT_MIN_IMPACT
    SELECT_MAX_IMPACT = _pywrapcp.DefaultPhaseParameters_SELECT_MAX_IMPACT
    NONE = _pywrapcp.DefaultPhaseParameters_NONE
    NORMAL = _pywrapcp.DefaultPhaseParameters_NORMAL
    VERBOSE = _pywrapcp.DefaultPhaseParameters_VERBOSE
    var_selection_schema = property(_pywrapcp.DefaultPhaseParameters_var_selection_schema_get, _pywrapcp.DefaultPhaseParameters_var_selection_schema_set, doc=r&#34;&#34;&#34; This parameter describes how the next variable to instantiate will be chosen.&#34;&#34;&#34;)
    value_selection_schema = property(_pywrapcp.DefaultPhaseParameters_value_selection_schema_get, _pywrapcp.DefaultPhaseParameters_value_selection_schema_set, doc=r&#34;&#34;&#34; This parameter describes which value to select for a given var.&#34;&#34;&#34;)
    initialization_splits = property(_pywrapcp.DefaultPhaseParameters_initialization_splits_get, _pywrapcp.DefaultPhaseParameters_initialization_splits_set, doc=r&#34;&#34;&#34; Maximum number of intervals that the initialization of impacts will scan per variable.&#34;&#34;&#34;)
    run_all_heuristics = property(_pywrapcp.DefaultPhaseParameters_run_all_heuristics_get, _pywrapcp.DefaultPhaseParameters_run_all_heuristics_set, doc=r&#34;&#34;&#34; The default phase will run heuristics periodically. This parameter indicates if we should run all heuristics, or a randomly selected one.&#34;&#34;&#34;)
    heuristic_period = property(_pywrapcp.DefaultPhaseParameters_heuristic_period_get, _pywrapcp.DefaultPhaseParameters_heuristic_period_set, doc=r&#34;&#34;&#34; The distance in nodes between each run of the heuristics. A negative or null value will mean that we will not run heuristics at all.&#34;&#34;&#34;)
    heuristic_num_failures_limit = property(_pywrapcp.DefaultPhaseParameters_heuristic_num_failures_limit_get, _pywrapcp.DefaultPhaseParameters_heuristic_num_failures_limit_set, doc=r&#34;&#34;&#34; The failure limit for each heuristic that we run.&#34;&#34;&#34;)
    persistent_impact = property(_pywrapcp.DefaultPhaseParameters_persistent_impact_get, _pywrapcp.DefaultPhaseParameters_persistent_impact_set, doc=r&#34;&#34;&#34; Whether to keep the impact from the first search for other searches, or to recompute the impact for each new search.&#34;&#34;&#34;)
    random_seed = property(_pywrapcp.DefaultPhaseParameters_random_seed_get, _pywrapcp.DefaultPhaseParameters_random_seed_set, doc=r&#34;&#34;&#34; Seed used to initialize the random part in some heuristics.&#34;&#34;&#34;)
    display_level = property(_pywrapcp.DefaultPhaseParameters_display_level_get, _pywrapcp.DefaultPhaseParameters_display_level_set, doc=r&#34;&#34;&#34; This represents the amount of information displayed by the default search. NONE means no display, VERBOSE means extra information.&#34;&#34;&#34;)
    decision_builder = property(_pywrapcp.DefaultPhaseParameters_decision_builder_get, _pywrapcp.DefaultPhaseParameters_decision_builder_set, doc=r&#34;&#34;&#34; When defined, this overrides the default impact based decision builder.&#34;&#34;&#34;)

    def __init__(self):
        _pywrapcp.DefaultPhaseParameters_swiginit(self, _pywrapcp.new_DefaultPhaseParameters())
    __swig_destroy__ = _pywrapcp.delete_DefaultPhaseParameters</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pywrapcp.DefaultPhaseParameters.CHOOSE_MAX_AVERAGE_IMPACT"><code class="name">var <span class="ident">CHOOSE_MAX_AVERAGE_IMPACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.CHOOSE_MAX_SUM_IMPACT"><code class="name">var <span class="ident">CHOOSE_MAX_SUM_IMPACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.CHOOSE_MAX_VALUE_IMPACT"><code class="name">var <span class="ident">CHOOSE_MAX_VALUE_IMPACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.NONE"><code class="name">var <span class="ident">NONE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.NORMAL"><code class="name">var <span class="ident">NORMAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.SELECT_MAX_IMPACT"><code class="name">var <span class="ident">SELECT_MAX_IMPACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.SELECT_MIN_IMPACT"><code class="name">var <span class="ident">SELECT_MIN_IMPACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.VERBOSE"><code class="name">var <span class="ident">VERBOSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapcp.DefaultPhaseParameters.decision_builder"><code class="name">var <span class="ident">decision_builder</span></code></dt>
<dd>
<div class="desc"><p>When defined, this overrides the default impact based decision builder.</p></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.display_level"><code class="name">var <span class="ident">display_level</span></code></dt>
<dd>
<div class="desc"><p>This represents the amount of information displayed by the default search. NONE means no display, VERBOSE means extra information.</p></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.heuristic_num_failures_limit"><code class="name">var <span class="ident">heuristic_num_failures_limit</span></code></dt>
<dd>
<div class="desc"><p>The failure limit for each heuristic that we run.</p></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.heuristic_period"><code class="name">var <span class="ident">heuristic_period</span></code></dt>
<dd>
<div class="desc"><p>The distance in nodes between each run of the heuristics. A negative or null value will mean that we will not run heuristics at all.</p></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.initialization_splits"><code class="name">var <span class="ident">initialization_splits</span></code></dt>
<dd>
<div class="desc"><p>Maximum number of intervals that the initialization of impacts will scan per variable.</p></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.persistent_impact"><code class="name">var <span class="ident">persistent_impact</span></code></dt>
<dd>
<div class="desc"><p>Whether to keep the impact from the first search for other searches, or to recompute the impact for each new search.</p></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.random_seed"><code class="name">var <span class="ident">random_seed</span></code></dt>
<dd>
<div class="desc"><p>Seed used to initialize the random part in some heuristics.</p></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.run_all_heuristics"><code class="name">var <span class="ident">run_all_heuristics</span></code></dt>
<dd>
<div class="desc"><p>The default phase will run heuristics periodically. This parameter indicates if we should run all heuristics, or a randomly selected one.</p></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<div class="desc"><p>The membership flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.value_selection_schema"><code class="name">var <span class="ident">value_selection_schema</span></code></dt>
<dd>
<div class="desc"><p>This parameter describes which value to select for a given var.</p></div>
</dd>
<dt id="pywrapcp.DefaultPhaseParameters.var_selection_schema"><code class="name">var <span class="ident">var_selection_schema</span></code></dt>
<dd>
<div class="desc"><p>This parameter describes how the next variable to instantiate will be chosen.</p></div>
</dd>
</dl>
</dd>
<dt id="pywrapcp.Demon"><code class="flex name class">
<span>class <span class="ident">Demon</span></span>
</code></dt>
<dd>
<div class="desc"><p>A Demon is the base element of a propagation queue. It is the main
object responsible for implementing the actual propagation
of the constraint and pruning the inconsistent values in the domains
of the variables. The main concept is that demons are listeners that are
attached to the variables and listen to their modifications. There are two methods:
- Run() is the actual method called when the demon is processed.
- priority() returns its priority. Standard priorities are slow, normal
or fast. "immediate" is reserved for variables and is treated separately.</p>
<p>This indicates the priority of a demon. Immediate demons are treated separately and corresponds to variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Demon(BaseObject):
    r&#34;&#34;&#34; A Demon is the base element of a propagation queue. It is the main   object responsible for implementing the actual propagation   of the constraint and pruning the inconsistent values in the domains   of the variables. The main concept is that demons are listeners that are   attached to the variables and listen to their modifications. There are two methods:  - Run() is the actual method called when the demon is processed.  - priority() returns its priority. Standard priorities are slow, normal    or fast. &#34;immediate&#34; is reserved for variables and is treated separately.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self):
        r&#34;&#34;&#34; This indicates the priority of a demon. Immediate demons are treated separately and corresponds to variables.&#34;&#34;&#34;
        if self.__class__ == Demon:
            _self = None
        else:
            _self = self
        _pywrapcp.Demon_swiginit(self, _pywrapcp.new_Demon(_self, ))
    __swig_destroy__ = _pywrapcp.delete_Demon

    def RunWrapper(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This is the main callback of the demon.&#34;&#34;&#34;
        return _pywrapcp.Demon_RunWrapper(self, s)

    def Priority(self) -&gt; &#34;operations_research::Solver::DemonPriority&#34;:
        r&#34;&#34;&#34; This method returns the priority of the demon. Usually a demon is fast, slow or normal. Immediate demons are reserved for internal use to maintain variables.&#34;&#34;&#34;
        return _pywrapcp.Demon_Priority(self)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Demon_DebugString(self)

    def Inhibit(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method inhibits the demon in the search tree below the current position.&#34;&#34;&#34;
        return _pywrapcp.Demon_Inhibit(self, s)

    def Desinhibit(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method un-inhibits the demon that was previously inhibited.&#34;&#34;&#34;
        return _pywrapcp.Demon_Desinhibit(self, s)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_Demon(self)
        return weakref.proxy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.PyDemon" href="#pywrapcp.PyDemon">PyDemon</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.Demon.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.Demon_DebugString(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Demon.Desinhibit"><code class="name flex">
<span>def <span class="ident">Desinhibit</span></span>(<span>self, s: Solver) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method un-inhibits the demon that was previously inhibited.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Desinhibit(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method un-inhibits the demon that was previously inhibited.&#34;&#34;&#34;
    return _pywrapcp.Demon_Desinhibit(self, s)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Demon.Inhibit"><code class="name flex">
<span>def <span class="ident">Inhibit</span></span>(<span>self, s: Solver) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method inhibits the demon in the search tree below the current position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Inhibit(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method inhibits the demon in the search tree below the current position.&#34;&#34;&#34;
    return _pywrapcp.Demon_Inhibit(self, s)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Demon.Priority"><code class="name flex">
<span>def <span class="ident">Priority</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Solver" href="#pywrapcp.Solver">Solver</a>::DemonPriority'</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the priority of the demon. Usually a demon is fast, slow or normal. Immediate demons are reserved for internal use to maintain variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Priority(self) -&gt; &#34;operations_research::Solver::DemonPriority&#34;:
    r&#34;&#34;&#34; This method returns the priority of the demon. Usually a demon is fast, slow or normal. Immediate demons are reserved for internal use to maintain variables.&#34;&#34;&#34;
    return _pywrapcp.Demon_Priority(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Demon.RunWrapper"><code class="name flex">
<span>def <span class="ident">RunWrapper</span></span>(<span>self, s: Solver) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This is the main callback of the demon.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RunWrapper(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This is the main callback of the demon.&#34;&#34;&#34;
    return _pywrapcp.Demon_RunWrapper(self, s)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.BaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.DisjunctiveConstraint"><code class="flex name class">
<span>class <span class="ident">DisjunctiveConstraint</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A constraint is the main modeling object. It provides two methods:
- Post() is responsible for creating the demons and attaching them to
immediate demons().
- InitialPropagate() is called once just after Post and performs
the initial propagation. The subsequent propagations will be performed
by the demons Posted during the post() method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DisjunctiveConstraint(Constraint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def SequenceVar(self) -&gt; &#34;operations_research::SequenceVar *&#34;:
        r&#34;&#34;&#34; Creates a sequence variable from the constraint.&#34;&#34;&#34;
        return _pywrapcp.DisjunctiveConstraint_SequenceVar(self)

    def SetTransitionTime(self, transition_time: &#34;operations_research::Solver::IndexEvaluator2&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Add a transition time between intervals.  It forces the distance between the end of interval a and start of interval b that follows it to be at least transition_time(a, b). This function must always return a positive or null value.&#34;&#34;&#34;
        return _pywrapcp.DisjunctiveConstraint_SetTransitionTime(self, transition_time)

    def TransitionTime(self, before_index: &#34;int&#34;, after_index: &#34;int&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.DisjunctiveConstraint_TransitionTime(self, before_index, after_index)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a></li>
<li><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.DisjunctiveConstraint.SequenceVar"><code class="name flex">
<span>def <span class="ident">SequenceVar</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.SequenceVar" href="#pywrapcp.SequenceVar">SequenceVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a sequence variable from the constraint.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SequenceVar(self) -&gt; &#34;operations_research::SequenceVar *&#34;:
    r&#34;&#34;&#34; Creates a sequence variable from the constraint.&#34;&#34;&#34;
    return _pywrapcp.DisjunctiveConstraint_SequenceVar(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.DisjunctiveConstraint.SetTransitionTime"><code class="name flex">
<span>def <span class="ident">SetTransitionTime</span></span>(<span>self, transition_time: operations_research::Solver::IndexEvaluator2) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Add a transition time between intervals.
It forces the distance between the end of interval a and start of interval b that follows it to be at least transition_time(a, b). This function must always return a positive or null value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetTransitionTime(self, transition_time: &#34;operations_research::Solver::IndexEvaluator2&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Add a transition time between intervals.  It forces the distance between the end of interval a and start of interval b that follows it to be at least transition_time(a, b). This function must always return a positive or null value.&#34;&#34;&#34;
    return _pywrapcp.DisjunctiveConstraint_SetTransitionTime(self, transition_time)</code></pre>
</details>
</dd>
<dt id="pywrapcp.DisjunctiveConstraint.TransitionTime"><code class="name flex">
<span>def <span class="ident">TransitionTime</span></span>(<span>self, before_index: int, after_index: int) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TransitionTime(self, before_index: &#34;int&#34;, after_index: &#34;int&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.DisjunctiveConstraint_TransitionTime(self, before_index, after_index)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.Constraint.InitialPropagateWrapper" href="#pywrapcp.Constraint.InitialPropagateWrapper">InitialPropagateWrapper</a></code></li>
<li><code><a title="pywrapcp.Constraint.Name" href="#pywrapcp.PropagationBaseObject.Name">Name</a></code></li>
<li><code><a title="pywrapcp.Constraint.Post" href="#pywrapcp.Constraint.Post">Post</a></code></li>
<li><code><a title="pywrapcp.Constraint.Var" href="#pywrapcp.Constraint.Var">Var</a></code></li>
<li><code><a title="pywrapcp.Constraint.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.GlobalVehicleBreaksConstraint"><code class="flex name class">
<span>class <span class="ident">GlobalVehicleBreaksConstraint</span></span>
<span>(</span><span>dimension: RoutingDimension)</span>
</code></dt>
<dd>
<div class="desc"><p>GlobalVehicleBreaksConstraint ensures breaks constraints are enforced on all vehicles in the dimension passed to its constructor. It is intended to be used for dimensions representing time. A break constraint ensures break intervals fit on the route of a vehicle. For a given vehicle, it forces break intervals to be disjoint from visit intervals, where visit intervals start at CumulVar(node) and last for node_visit_transit[node]. Moreover, it ensures that there is enough time between two consecutive nodes of a route to do transit and vehicle breaks, i.e. if Next(nodeA) = nodeB, CumulVar(nodeA) = tA and CumulVar(nodeB) = tB, then SlackVar(nodeA) &gt;= sum_{breaks [tA, tB)} duration(break).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GlobalVehicleBreaksConstraint(Constraint):
    r&#34;&#34;&#34; GlobalVehicleBreaksConstraint ensures breaks constraints are enforced on all vehicles in the dimension passed to its constructor. It is intended to be used for dimensions representing time. A break constraint ensures break intervals fit on the route of a vehicle. For a given vehicle, it forces break intervals to be disjoint from visit intervals, where visit intervals start at CumulVar(node) and last for node_visit_transit[node]. Moreover, it ensures that there is enough time between two consecutive nodes of a route to do transit and vehicle breaks, i.e. if Next(nodeA) = nodeB, CumulVar(nodeA) = tA and CumulVar(nodeB) = tB, then SlackVar(nodeA) &gt;= sum_{breaks [tA, tB)} duration(break).&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, dimension: &#34;RoutingDimension&#34;):
        _pywrapcp.GlobalVehicleBreaksConstraint_swiginit(self, _pywrapcp.new_GlobalVehicleBreaksConstraint(dimension))

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.GlobalVehicleBreaksConstraint_DebugString(self)

    def Post(self) -&gt; &#34;void&#34;:
        return _pywrapcp.GlobalVehicleBreaksConstraint_Post(self)

    def InitialPropagateWrapper(self) -&gt; &#34;void&#34;:
        return _pywrapcp.GlobalVehicleBreaksConstraint_InitialPropagateWrapper(self)
    __swig_destroy__ = _pywrapcp.delete_GlobalVehicleBreaksConstraint</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a></li>
<li><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.GlobalVehicleBreaksConstraint.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.GlobalVehicleBreaksConstraint_DebugString(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.Constraint.InitialPropagateWrapper" href="#pywrapcp.Constraint.InitialPropagateWrapper">InitialPropagateWrapper</a></code></li>
<li><code><a title="pywrapcp.Constraint.Name" href="#pywrapcp.PropagationBaseObject.Name">Name</a></code></li>
<li><code><a title="pywrapcp.Constraint.Post" href="#pywrapcp.Constraint.Post">Post</a></code></li>
<li><code><a title="pywrapcp.Constraint.Var" href="#pywrapcp.Constraint.Var">Var</a></code></li>
<li><code><a title="pywrapcp.Constraint.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.IntExpr"><code class="flex name class">
<span>class <span class="ident">IntExpr</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The class IntExpr is the base of all integer expressions in constraint programming. It contains the basic protocol for an expression:
- setting and modifying its bound
- querying if it is bound
- listening to events modifying its bounds
- casting it into a variable (instance of IntVar)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntExpr(PropagationBaseObject):
    r&#34;&#34;&#34; The class IntExpr is the base of all integer expressions in constraint programming. It contains the basic protocol for an expression:   - setting and modifying its bound   - querying if it is bound   - listening to events modifying its bounds   - casting it into a variable (instance of IntVar)&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)

    def Min(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntExpr_Min(self)

    def SetMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntExpr_SetMin(self, m)

    def Max(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntExpr_Max(self)

    def SetMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntExpr_SetMax(self, m)

    def SetRange(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method sets both the min and the max of the expression.&#34;&#34;&#34;
        return _pywrapcp.IntExpr_SetRange(self, l, u)

    def SetValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method sets the value of the expression.&#34;&#34;&#34;
        return _pywrapcp.IntExpr_SetValue(self, v)

    def Bound(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if the min and the max of the expression are equal.&#34;&#34;&#34;
        return _pywrapcp.IntExpr_Bound(self)

    def IsVar(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if the expression is indeed a variable.&#34;&#34;&#34;
        return _pywrapcp.IntExpr_IsVar(self)

    def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Creates a variable from the expression.&#34;&#34;&#34;
        return _pywrapcp.IntExpr_Var(self)

    def VarWithName(self, name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Creates a variable from the expression and set the name of the resulting var. If the expression is already a variable, then it will set the name of the expression, possibly overwriting it. This is just a shortcut to Var() followed by set_name().&#34;&#34;&#34;
        return _pywrapcp.IntExpr_VarWithName(self, name)

    def WhenRange(self, *args) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Attach a demon that will watch the min or the max of the expression.

        |

        *Overload 2:*
        Attach a demon that will watch the min or the max of the expression.
        &#34;&#34;&#34;
        return _pywrapcp.IntExpr_WhenRange(self, *args)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.IntExpr___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.IntExpr___str__(self)

    def __add__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___add__(self, *args)

    def __radd__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___radd__(self, v)

    def __sub__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___sub__(self, *args)

    def __rsub__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___rsub__(self, v)

    def __mul__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___mul__(self, *args)

    def __rmul__(self, v: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___rmul__(self, v)

    def __floordiv__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___floordiv__(self, *args)

    def __mod__(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___mod__(self, *args)

    def __neg__(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___neg__(self)

    def __abs__(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr___abs__(self)

    def Square(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr_Square(self)

    def __eq__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr___eq__(self, *args)

    def __ne__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr___ne__(self, *args)

    def __ge__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr___ge__(self, *args)

    def __gt__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr___gt__(self, *args)

    def __le__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr___le__(self, *args)

    def __lt__(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr___lt__(self, *args)

    def MapTo(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr_MapTo(self, vars)

    def IndexOf(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntExpr_IndexOf(self, *args)

    def IsMember(self, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.IntExpr_IsMember(self, values)

    def Member(self, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr_Member(self, values)

    def NotMember(self, starts: &#34;std::vector&lt; int64 &gt; const &amp;&#34;, ends: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntExpr_NotMember(self, starts, ends)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.IntExpr.Bound"><code class="name flex">
<span>def <span class="ident">Bound</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the min and the max of the expression are equal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Bound(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true if the min and the max of the expression are equal.&#34;&#34;&#34;
    return _pywrapcp.IntExpr_Bound(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.IndexOf"><code class="name flex">
<span>def <span class="ident">IndexOf</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IndexOf(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
    return _pywrapcp.IntExpr_IndexOf(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.IsMember"><code class="name flex">
<span>def <span class="ident">IsMember</span></span>(<span>self, values: std::vector< int64 > const &) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsMember(self, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    return _pywrapcp.IntExpr_IsMember(self, values)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.IsVar"><code class="name flex">
<span>def <span class="ident">IsVar</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the expression is indeed a variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsVar(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true if the expression is indeed a variable.&#34;&#34;&#34;
    return _pywrapcp.IntExpr_IsVar(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.MapTo"><code class="name flex">
<span>def <span class="ident">MapTo</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MapTo(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntExpr_MapTo(self, vars)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.Max"><code class="name flex">
<span>def <span class="ident">Max</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Max(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntExpr_Max(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.Member"><code class="name flex">
<span>def <span class="ident">Member</span></span>(<span>self, values: std::vector< int64 > const &) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Member(self, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntExpr_Member(self, values)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.Min"><code class="name flex">
<span>def <span class="ident">Min</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Min(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntExpr_Min(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.NotMember"><code class="name flex">
<span>def <span class="ident">NotMember</span></span>(<span>self, starts: std::vector< int64 > const &, ends: std::vector< int64 > const &) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NotMember(self, starts: &#34;std::vector&lt; int64 &gt; const &amp;&#34;, ends: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntExpr_NotMember(self, starts, ends)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.SetMax"><code class="name flex">
<span>def <span class="ident">SetMax</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntExpr_SetMax(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.SetMin"><code class="name flex">
<span>def <span class="ident">SetMin</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntExpr_SetMin(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.SetRange"><code class="name flex">
<span>def <span class="ident">SetRange</span></span>(<span>self, l: int64, u: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method sets both the min and the max of the expression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetRange(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method sets both the min and the max of the expression.&#34;&#34;&#34;
    return _pywrapcp.IntExpr_SetRange(self, l, u)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.SetValue"><code class="name flex">
<span>def <span class="ident">SetValue</span></span>(<span>self, v: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method sets the value of the expression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method sets the value of the expression.&#34;&#34;&#34;
    return _pywrapcp.IntExpr_SetValue(self, v)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.Square"><code class="name flex">
<span>def <span class="ident">Square</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Square(self) -&gt; &#34;operations_research::IntExpr *&#34;:
    return _pywrapcp.IntExpr_Square(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.Var"><code class="name flex">
<span>def <span class="ident">Var</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a variable from the expression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; Creates a variable from the expression.&#34;&#34;&#34;
    return _pywrapcp.IntExpr_Var(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.VarWithName"><code class="name flex">
<span>def <span class="ident">VarWithName</span></span>(<span>self, name: std::string const &) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a variable from the expression and set the name of the resulting var. If the expression is already a variable, then it will set the name of the expression, possibly overwriting it. This is just a shortcut to Var() followed by set_name().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VarWithName(self, name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; Creates a variable from the expression and set the name of the resulting var. If the expression is already a variable, then it will set the name of the expression, possibly overwriting it. This is just a shortcut to Var() followed by set_name().&#34;&#34;&#34;
    return _pywrapcp.IntExpr_VarWithName(self, name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntExpr.WhenRange"><code class="name flex">
<span>def <span class="ident">WhenRange</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Attach a demon that will watch the min or the max of the expression.</p>
<p>|</p>
<p><em>Overload 2:</em>
Attach a demon that will watch the min or the max of the expression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WhenRange(self, *args) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Attach a demon that will watch the min or the max of the expression.

    |

    *Overload 2:*
    Attach a demon that will watch the min or the max of the expression.
    &#34;&#34;&#34;
    return _pywrapcp.IntExpr_WhenRange(self, *args)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.PropagationBaseObject.Name" href="#pywrapcp.PropagationBaseObject.Name">Name</a></code></li>
<li><code><a title="pywrapcp.PropagationBaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.IntVar"><code class="flex name class">
<span>class <span class="ident">IntVar</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The class IntVar is a subset of IntExpr. In addition to the IntExpr protocol, it offers persistence, removing values from the domains, and a finer model for events.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntVar(IntExpr):
    r&#34;&#34;&#34; The class IntVar is a subset of IntExpr. In addition to the IntExpr protocol, it offers persistence, removing values from the domains, and a finer model for events.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)

    def IsVar(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVar_IsVar(self)

    def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.IntVar_Var(self)

    def Value(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This method returns the value of the variable. This method checks before that the variable is bound.&#34;&#34;&#34;
        return _pywrapcp.IntVar_Value(self)

    def RemoveValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method removes the value &#39;v&#39; from the domain of the variable.&#34;&#34;&#34;
        return _pywrapcp.IntVar_RemoveValue(self, v)

    def RemoveInterval(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method removes the interval &#39;l&#39; .. &#39;u&#39; from the domain of the variable. It assumes that &#39;l&#39; &lt;= &#39;u&#39;.&#34;&#34;&#34;
        return _pywrapcp.IntVar_RemoveInterval(self, l, u)

    def RemoveValues(self, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method remove the values from the domain of the variable.&#34;&#34;&#34;
        return _pywrapcp.IntVar_RemoveValues(self, values)

    def SetValues(self, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method intersects the current domain with the values in the array.&#34;&#34;&#34;
        return _pywrapcp.IntVar_SetValues(self, values)

    def WhenBound(self, *args) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This method attaches a demon that will be awakened when the variable is bound.

        |

        *Overload 2:*
        This method attaches a closure that will be awakened when the variable is bound.
        &#34;&#34;&#34;
        return _pywrapcp.IntVar_WhenBound(self, *args)

    def WhenDomain(self, *args) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This method attaches a demon that will watch any domain modification of the domain of the variable.

        |

        *Overload 2:*
        This method attaches a closure that will watch any domain modification of the domain of the variable.
        &#34;&#34;&#34;
        return _pywrapcp.IntVar_WhenDomain(self, *args)

    def Size(self) -&gt; &#34;uint64&#34;:
        r&#34;&#34;&#34; This method returns the number of values in the domain of the variable.&#34;&#34;&#34;
        return _pywrapcp.IntVar_Size(self)

    def Contains(self, v: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; This method returns whether the value &#39;v&#39; is in the domain of the variable.&#34;&#34;&#34;
        return _pywrapcp.IntVar_Contains(self, v)

    def HoleIteratorAux(self, reversible: &#34;bool&#34;) -&gt; &#34;operations_research::IntVarIterator *&#34;:
        r&#34;&#34;&#34; Creates a hole iterator. When &#39;reversible&#39; is false, the returned object is created on the normal C++ heap and the solver does NOT take ownership of the object.&#34;&#34;&#34;
        return _pywrapcp.IntVar_HoleIteratorAux(self, reversible)

    def DomainIteratorAux(self, reversible: &#34;bool&#34;) -&gt; &#34;operations_research::IntVarIterator *&#34;:
        r&#34;&#34;&#34; Creates a domain iterator. When &#39;reversible&#39; is false, the returned object is created on the normal C++ heap and the solver does NOT take ownership of the object.&#34;&#34;&#34;
        return _pywrapcp.IntVar_DomainIteratorAux(self, reversible)

    def OldMin(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the previous min.&#34;&#34;&#34;
        return _pywrapcp.IntVar_OldMin(self)

    def OldMax(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the previous max.&#34;&#34;&#34;
        return _pywrapcp.IntVar_OldMax(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.IntVar___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.IntVar___str__(self)

    def DomainIterator(self):
      return iter(self.DomainIteratorAux(False))

    def HoleIterator(self):
      return iter(self.HoleIteratorAux(False))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a></li>
<li><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.BooleanVar" href="#pywrapcp.BooleanVar">BooleanVar</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.IntVar.Contains"><code class="name flex">
<span>def <span class="ident">Contains</span></span>(<span>self, v: int64) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns whether the value 'v' is in the domain of the variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Contains(self, v: &#34;int64&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; This method returns whether the value &#39;v&#39; is in the domain of the variable.&#34;&#34;&#34;
    return _pywrapcp.IntVar_Contains(self, v)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.DomainIterator"><code class="name flex">
<span>def <span class="ident">DomainIterator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DomainIterator(self):
  return iter(self.DomainIteratorAux(False))</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.DomainIteratorAux"><code class="name flex">
<span>def <span class="ident">DomainIteratorAux</span></span>(<span>self, reversible: bool) -> 'operations_research::<a title="pywrapcp.IntVarIterator" href="#pywrapcp.IntVarIterator">IntVarIterator</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a domain iterator. When 'reversible' is false, the returned object is created on the normal C++ heap and the solver does NOT take ownership of the object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DomainIteratorAux(self, reversible: &#34;bool&#34;) -&gt; &#34;operations_research::IntVarIterator *&#34;:
    r&#34;&#34;&#34; Creates a domain iterator. When &#39;reversible&#39; is false, the returned object is created on the normal C++ heap and the solver does NOT take ownership of the object.&#34;&#34;&#34;
    return _pywrapcp.IntVar_DomainIteratorAux(self, reversible)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.HoleIterator"><code class="name flex">
<span>def <span class="ident">HoleIterator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HoleIterator(self):
  return iter(self.HoleIteratorAux(False))</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.HoleIteratorAux"><code class="name flex">
<span>def <span class="ident">HoleIteratorAux</span></span>(<span>self, reversible: bool) -> 'operations_research::<a title="pywrapcp.IntVarIterator" href="#pywrapcp.IntVarIterator">IntVarIterator</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a hole iterator. When 'reversible' is false, the returned object is created on the normal C++ heap and the solver does NOT take ownership of the object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HoleIteratorAux(self, reversible: &#34;bool&#34;) -&gt; &#34;operations_research::IntVarIterator *&#34;:
    r&#34;&#34;&#34; Creates a hole iterator. When &#39;reversible&#39; is false, the returned object is created on the normal C++ heap and the solver does NOT take ownership of the object.&#34;&#34;&#34;
    return _pywrapcp.IntVar_HoleIteratorAux(self, reversible)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.OldMax"><code class="name flex">
<span>def <span class="ident">OldMax</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the previous max.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OldMax(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the previous max.&#34;&#34;&#34;
    return _pywrapcp.IntVar_OldMax(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.OldMin"><code class="name flex">
<span>def <span class="ident">OldMin</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the previous min.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OldMin(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the previous min.&#34;&#34;&#34;
    return _pywrapcp.IntVar_OldMin(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.RemoveInterval"><code class="name flex">
<span>def <span class="ident">RemoveInterval</span></span>(<span>self, l: int64, u: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method removes the interval 'l' .. 'u' from the domain of the variable. It assumes that 'l' &lt;= 'u'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RemoveInterval(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method removes the interval &#39;l&#39; .. &#39;u&#39; from the domain of the variable. It assumes that &#39;l&#39; &lt;= &#39;u&#39;.&#34;&#34;&#34;
    return _pywrapcp.IntVar_RemoveInterval(self, l, u)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.RemoveValue"><code class="name flex">
<span>def <span class="ident">RemoveValue</span></span>(<span>self, v: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method removes the value 'v' from the domain of the variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RemoveValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method removes the value &#39;v&#39; from the domain of the variable.&#34;&#34;&#34;
    return _pywrapcp.IntVar_RemoveValue(self, v)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.RemoveValues"><code class="name flex">
<span>def <span class="ident">RemoveValues</span></span>(<span>self, values: std::vector< int64 > const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method remove the values from the domain of the variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RemoveValues(self, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method remove the values from the domain of the variable.&#34;&#34;&#34;
    return _pywrapcp.IntVar_RemoveValues(self, values)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.SetValues"><code class="name flex">
<span>def <span class="ident">SetValues</span></span>(<span>self, values: std::vector< int64 > const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method intersects the current domain with the values in the array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetValues(self, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method intersects the current domain with the values in the array.&#34;&#34;&#34;
    return _pywrapcp.IntVar_SetValues(self, values)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.Size"><code class="name flex">
<span>def <span class="ident">Size</span></span>(<span>self) -> 'uint64'</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the number of values in the domain of the variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Size(self) -&gt; &#34;uint64&#34;:
    r&#34;&#34;&#34; This method returns the number of values in the domain of the variable.&#34;&#34;&#34;
    return _pywrapcp.IntVar_Size(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.Value"><code class="name flex">
<span>def <span class="ident">Value</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the value of the variable. This method checks before that the variable is bound.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Value(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; This method returns the value of the variable. This method checks before that the variable is bound.&#34;&#34;&#34;
    return _pywrapcp.IntVar_Value(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.WhenBound"><code class="name flex">
<span>def <span class="ident">WhenBound</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
This method attaches a demon that will be awakened when the variable is bound.</p>
<p>|</p>
<p><em>Overload 2:</em>
This method attaches a closure that will be awakened when the variable is bound.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WhenBound(self, *args) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    This method attaches a demon that will be awakened when the variable is bound.

    |

    *Overload 2:*
    This method attaches a closure that will be awakened when the variable is bound.
    &#34;&#34;&#34;
    return _pywrapcp.IntVar_WhenBound(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVar.WhenDomain"><code class="name flex">
<span>def <span class="ident">WhenDomain</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
This method attaches a demon that will watch any domain modification of the domain of the variable.</p>
<p>|</p>
<p><em>Overload 2:</em>
This method attaches a closure that will watch any domain modification of the domain of the variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WhenDomain(self, *args) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    This method attaches a demon that will watch any domain modification of the domain of the variable.

    |

    *Overload 2:*
    This method attaches a closure that will watch any domain modification of the domain of the variable.
    &#34;&#34;&#34;
    return _pywrapcp.IntVar_WhenDomain(self, *args)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.IntExpr.Bound" href="#pywrapcp.IntExpr.Bound">Bound</a></code></li>
<li><code><a title="pywrapcp.IntExpr.IsVar" href="#pywrapcp.IntExpr.IsVar">IsVar</a></code></li>
<li><code><a title="pywrapcp.IntExpr.Name" href="#pywrapcp.PropagationBaseObject.Name">Name</a></code></li>
<li><code><a title="pywrapcp.IntExpr.SetRange" href="#pywrapcp.IntExpr.SetRange">SetRange</a></code></li>
<li><code><a title="pywrapcp.IntExpr.SetValue" href="#pywrapcp.IntExpr.SetValue">SetValue</a></code></li>
<li><code><a title="pywrapcp.IntExpr.Var" href="#pywrapcp.IntExpr.Var">Var</a></code></li>
<li><code><a title="pywrapcp.IntExpr.VarWithName" href="#pywrapcp.IntExpr.VarWithName">VarWithName</a></code></li>
<li><code><a title="pywrapcp.IntExpr.WhenRange" href="#pywrapcp.IntExpr.WhenRange">WhenRange</a></code></li>
<li><code><a title="pywrapcp.IntExpr.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.IntVarContainer"><code class="flex name class">
<span>class <span class="ident">IntVarContainer</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntVarContainer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Contains(self, var: &#34;IntVar&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVarContainer_Contains(self, var)

    def Element(self, index: &#34;int&#34;) -&gt; &#34;operations_research::IntVarElement *&#34;:
        return _pywrapcp.IntVarContainer_Element(self, index)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.IntVarContainer_Size(self)

    def Store(self) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarContainer_Store(self)

    def Restore(self) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarContainer_Restore(self)

    def __eq__(self, container: &#34;IntVarContainer&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if this and &#39;container&#39; both represent the same V* -&gt; E map. Runs in linear time; requires that the == operator on the type E is well defined.&#34;&#34;&#34;
        return _pywrapcp.IntVarContainer___eq__(self, container)

    def __ne__(self, container: &#34;IntVarContainer&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVarContainer___ne__(self, container)
    __swig_destroy__ = _pywrapcp.delete_IntVarContainer</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapcp.IntVarContainer.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<div class="desc"><p>The membership flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.IntVarContainer.Contains"><code class="name flex">
<span>def <span class="ident">Contains</span></span>(<span>self, var: IntVar) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Contains(self, var: &#34;IntVar&#34;) -&gt; &#34;bool&#34;:
    return _pywrapcp.IntVarContainer_Contains(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarContainer.Element"><code class="name flex">
<span>def <span class="ident">Element</span></span>(<span>self, index: int) -> 'operations_research::<a title="pywrapcp.IntVarElement" href="#pywrapcp.IntVarElement">IntVarElement</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Element(self, index: &#34;int&#34;) -&gt; &#34;operations_research::IntVarElement *&#34;:
    return _pywrapcp.IntVarContainer_Element(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarContainer.Restore"><code class="name flex">
<span>def <span class="ident">Restore</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Restore(self) -&gt; &#34;void&#34;:
    return _pywrapcp.IntVarContainer_Restore(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarContainer.Size"><code class="name flex">
<span>def <span class="ident">Size</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Size(self) -&gt; &#34;int&#34;:
    return _pywrapcp.IntVarContainer_Size(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarContainer.Store"><code class="name flex">
<span>def <span class="ident">Store</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Store(self) -&gt; &#34;void&#34;:
    return _pywrapcp.IntVarContainer_Store(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywrapcp.IntVarElement"><code class="flex name class">
<span>class <span class="ident">IntVarElement</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntVarElement(AssignmentElement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.IntVarElement_Var(self)

    def Min(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntVarElement_Min(self)

    def SetMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarElement_SetMin(self, m)

    def Max(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntVarElement_Max(self)

    def SetMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarElement_SetMax(self, m)

    def Value(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntVarElement_Value(self)

    def Bound(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVarElement_Bound(self)

    def SetRange(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarElement_SetRange(self, l, u)

    def SetValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarElement_SetValue(self, v)

    def __eq__(self, element: &#34;IntVarElement&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVarElement___eq__(self, element)

    def __ne__(self, element: &#34;IntVarElement&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVarElement___ne__(self, element)
    __swig_destroy__ = _pywrapcp.delete_IntVarElement</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.AssignmentElement" href="#pywrapcp.AssignmentElement">AssignmentElement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.IntVarElement.Bound"><code class="name flex">
<span>def <span class="ident">Bound</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Bound(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.IntVarElement_Bound(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarElement.Max"><code class="name flex">
<span>def <span class="ident">Max</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Max(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntVarElement_Max(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarElement.Min"><code class="name flex">
<span>def <span class="ident">Min</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Min(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntVarElement_Min(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarElement.SetMax"><code class="name flex">
<span>def <span class="ident">SetMax</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntVarElement_SetMax(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarElement.SetMin"><code class="name flex">
<span>def <span class="ident">SetMin</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntVarElement_SetMin(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarElement.SetRange"><code class="name flex">
<span>def <span class="ident">SetRange</span></span>(<span>self, l: int64, u: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetRange(self, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntVarElement_SetRange(self, l, u)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarElement.SetValue"><code class="name flex">
<span>def <span class="ident">SetValue</span></span>(<span>self, v: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntVarElement_SetValue(self, v)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarElement.Value"><code class="name flex">
<span>def <span class="ident">Value</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Value(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntVarElement_Value(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarElement.Var"><code class="name flex">
<span>def <span class="ident">Var</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
    return _pywrapcp.IntVarElement_Var(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.AssignmentElement" href="#pywrapcp.AssignmentElement">AssignmentElement</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.AssignmentElement.thisown" href="#pywrapcp.AssignmentElement.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.IntVarIterator"><code class="flex name class">
<span>class <span class="ident">IntVarIterator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The class Iterator has two direct subclasses. HoleIterators iterates over all holes, that is value removed between the current min and max of the variable since the last time the variable was processed in the queue. DomainIterators iterates over all elements of the variable domain. Both iterators are not robust to domain changes. Hole iterators can also report values outside the current min and max of the variable. HoleIterators should only be called from a demon attached to the variable that has created this iterator. IntVar* current_var; std::unique_ptr<IntVarIterator> it(current_var-&gt;MakeHoleIterator(false)); for (const int64 hole : InitAndGetValues(it)) {
/// use the hole }</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntVarIterator(BaseObject):
    r&#34;&#34;&#34; The class Iterator has two direct subclasses. HoleIterators iterates over all holes, that is value removed between the current min and max of the variable since the last time the variable was processed in the queue. DomainIterators iterates over all elements of the variable domain. Both iterators are not robust to domain changes. Hole iterators can also report values outside the current min and max of the variable. HoleIterators should only be called from a demon attached to the variable that has created this iterator. IntVar* current_var; std::unique_ptr&lt;IntVarIterator&gt; it(current_var-&gt;MakeHoleIterator(false)); for (const int64 hole : InitAndGetValues(it)) {   /// use the hole }&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def Init(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method must be called before each loop.&#34;&#34;&#34;
        return _pywrapcp.IntVarIterator_Init(self)

    def Ok(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; This method indicates if we can call Value() or not.&#34;&#34;&#34;
        return _pywrapcp.IntVarIterator_Ok(self)

    def Value(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This method returns the current value of the iterator.&#34;&#34;&#34;
        return _pywrapcp.IntVarIterator_Value(self)

    def Next(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method moves the iterator to the next value.&#34;&#34;&#34;
        return _pywrapcp.IntVarIterator_Next(self)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        r&#34;&#34;&#34; Pretty Print.&#34;&#34;&#34;
        return _pywrapcp.IntVarIterator_DebugString(self)

    def __iter__(self):
      self.Init()
      return self

    def next(self):
      if self.Ok():
        result = self.Value()
        self.Next()
        return result
      else:
        raise StopIteration()

    def __next__(self):
      return self.next()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.IntVarIterator.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty Print.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    r&#34;&#34;&#34; Pretty Print.&#34;&#34;&#34;
    return _pywrapcp.IntVarIterator_DebugString(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarIterator.Init"><code class="name flex">
<span>def <span class="ident">Init</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method must be called before each loop.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Init(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method must be called before each loop.&#34;&#34;&#34;
    return _pywrapcp.IntVarIterator_Init(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarIterator.Next"><code class="name flex">
<span>def <span class="ident">Next</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method moves the iterator to the next value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Next(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method moves the iterator to the next value.&#34;&#34;&#34;
    return _pywrapcp.IntVarIterator_Next(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarIterator.Ok"><code class="name flex">
<span>def <span class="ident">Ok</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>This method indicates if we can call Value() or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Ok(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; This method indicates if we can call Value() or not.&#34;&#34;&#34;
    return _pywrapcp.IntVarIterator_Ok(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarIterator.Value"><code class="name flex">
<span>def <span class="ident">Value</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the current value of the iterator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Value(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; This method returns the current value of the iterator.&#34;&#34;&#34;
    return _pywrapcp.IntVarIterator_Value(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarIterator.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next(self):
  if self.Ok():
    result = self.Value()
    self.Next()
    return result
  else:
    raise StopIteration()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.BaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.IntVarLocalSearchFilter"><code class="flex name class">
<span>class <span class="ident">IntVarLocalSearchFilter</span></span>
<span>(</span><span>vars: std::vector< operations_research::IntVar * > const &)</span>
</code></dt>
<dd>
<div class="desc"><p>Local Search Filters are used for fast neighbor pruning. Filtering a move is done in several phases: - in the Relax phase, filters determine which parts of their internals
will be changed by the candidate, and modify intermediary State - in the Accept phase, filters check that the candidate is feasible, - if the Accept phase succeeds, the solver may decide to trigger a
Synchronize phase that makes filters change their internal representation
to the last candidate, - otherwise (Accept fails or the solver does not want to synchronize),
a Revert phase makes filters erase any intermediary State generated by the
Relax and Accept phases. A given filter has phases called with the following pattern: (Relax.Accept.Synchronize | Relax.Accept.Revert | Relax.Revert)*. Filters's Revert() is always called in the reverse order their Accept() was called, to allow late filters to use state done/undone by early filters' Accept()/Revert().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntVarLocalSearchFilter(LocalSearchFilter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;):
        if self.__class__ == IntVarLocalSearchFilter:
            _self = None
        else:
            _self = self
        _pywrapcp.IntVarLocalSearchFilter_swiginit(self, _pywrapcp.new_IntVarLocalSearchFilter(_self, vars))
    __swig_destroy__ = _pywrapcp.delete_IntVarLocalSearchFilter

    def Synchronize(self, assignment: &#34;Assignment&#34;, delta: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method should not be overridden. Override OnSynchronize() instead which is called before exiting this method.&#34;&#34;&#34;
        return _pywrapcp.IntVarLocalSearchFilter_Synchronize(self, assignment, delta)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.IntVarLocalSearchFilter_Size(self)

    def Value(self, index: &#34;int&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntVarLocalSearchFilter_Value(self, index)

    def IndexFromVar(self, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntVarLocalSearchFilter_IndexFromVar(self, var)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_IntVarLocalSearchFilter(self)
        return weakref.proxy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.LocalSearchFilter" href="#pywrapcp.LocalSearchFilter">LocalSearchFilter</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.BasePathFilter" href="#pywrapcp.BasePathFilter">BasePathFilter</a></li>
<li><a title="pywrapcp.CPFeasibilityFilter" href="#pywrapcp.CPFeasibilityFilter">CPFeasibilityFilter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.IntVarLocalSearchFilter.IndexFromVar"><code class="name flex">
<span>def <span class="ident">IndexFromVar</span></span>(<span>self, var: IntVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IndexFromVar(self, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntVarLocalSearchFilter_IndexFromVar(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarLocalSearchFilter.Size"><code class="name flex">
<span>def <span class="ident">Size</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Size(self) -&gt; &#34;int&#34;:
    return _pywrapcp.IntVarLocalSearchFilter_Size(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarLocalSearchFilter.Synchronize"><code class="name flex">
<span>def <span class="ident">Synchronize</span></span>(<span>self, assignment: Assignment, delta: Assignment) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method should not be overridden. Override OnSynchronize() instead which is called before exiting this method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Synchronize(self, assignment: &#34;Assignment&#34;, delta: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method should not be overridden. Override OnSynchronize() instead which is called before exiting this method.&#34;&#34;&#34;
    return _pywrapcp.IntVarLocalSearchFilter_Synchronize(self, assignment, delta)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarLocalSearchFilter.Value"><code class="name flex">
<span>def <span class="ident">Value</span></span>(<span>self, index: int) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Value(self, index: &#34;int&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntVarLocalSearchFilter_Value(self, index)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.LocalSearchFilter" href="#pywrapcp.LocalSearchFilter">LocalSearchFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.LocalSearchFilter.Accept" href="#pywrapcp.LocalSearchFilter.Accept">Accept</a></code></li>
<li><code><a title="pywrapcp.LocalSearchFilter.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.IntVarLocalSearchOperator"><code class="flex name class">
<span>class <span class="ident">IntVarLocalSearchOperator</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Base operator class for operators manipulating variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntVarLocalSearchOperator(IntVarLocalSearchOperatorTemplate):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, *args):
        if self.__class__ == IntVarLocalSearchOperator:
            _self = None
        else:
            _self = self
        _pywrapcp.IntVarLocalSearchOperator_swiginit(self, _pywrapcp.new_IntVarLocalSearchOperator(_self, *args))
    __swig_destroy__ = _pywrapcp.delete_IntVarLocalSearchOperator

    def NextNeighbor(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Redefines MakeNextNeighbor to export a simpler interface. The calls to ApplyChanges() and RevertChanges() are factored in this method, hiding both delta and deltadelta from subclasses which only need to override MakeOneNeighbor(). Therefore this method should not be overridden. Override MakeOneNeighbor() instead.&#34;&#34;&#34;
        return _pywrapcp.IntVarLocalSearchOperator_NextNeighbor(self, delta, deltadelta)

    def OneNeighbor(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Creates a new neighbor. It returns false when the neighborhood is completely explored. MakeNextNeighbor() in a subclass of IntVarLocalSearchOperator.&#34;&#34;&#34;
        return _pywrapcp.IntVarLocalSearchOperator_OneNeighbor(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_IntVarLocalSearchOperator(self)
        return weakref.proxy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.IntVarLocalSearchOperatorTemplate" href="#pywrapcp.IntVarLocalSearchOperatorTemplate">IntVarLocalSearchOperatorTemplate</a></li>
<li><a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.BaseLns" href="#pywrapcp.BaseLns">BaseLns</a></li>
<li><a title="pywrapcp.ChangeValue" href="#pywrapcp.ChangeValue">ChangeValue</a></li>
<li><a title="pywrapcp.PathOperator" href="#pywrapcp.PathOperator">PathOperator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.IntVarLocalSearchOperator.NextNeighbor"><code class="name flex">
<span>def <span class="ident">NextNeighbor</span></span>(<span>self, delta: Assignment, deltadelta: Assignment) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Redefines MakeNextNeighbor to export a simpler interface. The calls to ApplyChanges() and RevertChanges() are factored in this method, hiding both delta and deltadelta from subclasses which only need to override MakeOneNeighbor(). Therefore this method should not be overridden. Override MakeOneNeighbor() instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NextNeighbor(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Redefines MakeNextNeighbor to export a simpler interface. The calls to ApplyChanges() and RevertChanges() are factored in this method, hiding both delta and deltadelta from subclasses which only need to override MakeOneNeighbor(). Therefore this method should not be overridden. Override MakeOneNeighbor() instead.&#34;&#34;&#34;
    return _pywrapcp.IntVarLocalSearchOperator_NextNeighbor(self, delta, deltadelta)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarLocalSearchOperator.OneNeighbor"><code class="name flex">
<span>def <span class="ident">OneNeighbor</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new neighbor. It returns false when the neighborhood is completely explored. MakeNextNeighbor() in a subclass of IntVarLocalSearchOperator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OneNeighbor(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Creates a new neighbor. It returns false when the neighborhood is completely explored. MakeNextNeighbor() in a subclass of IntVarLocalSearchOperator.&#34;&#34;&#34;
    return _pywrapcp.IntVarLocalSearchOperator_OneNeighbor(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.IntVarLocalSearchOperatorTemplate" href="#pywrapcp.IntVarLocalSearchOperatorTemplate">IntVarLocalSearchOperatorTemplate</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.IntVarLocalSearchOperatorTemplate.OnStart" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.OnStart">OnStart</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperatorTemplate.Start" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.Start">Start</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperatorTemplate.Value" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.Value">Value</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperatorTemplate.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.IntVarLocalSearchOperatorTemplate"><code class="flex name class">
<span>class <span class="ident">IntVarLocalSearchOperatorTemplate</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base operator class for operators manipulating variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntVarLocalSearchOperatorTemplate(LocalSearchOperator):
    r&#34;&#34;&#34; Base operator class for operators manipulating variables.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def Start(self, assignment: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method should not be overridden. Override OnStart() instead which is called before exiting this method.&#34;&#34;&#34;
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_Start(self, assignment)

    def IsIncremental(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_IsIncremental(self)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_Size(self)

    def Value(self, index: &#34;int64&#34;) -&gt; &#34;long const &amp;&#34;:
        r&#34;&#34;&#34; Returns the value in the current assignment of the variable of given index.&#34;&#34;&#34;
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_Value(self, index)

    def OldValue(self, index: &#34;int64&#34;) -&gt; &#34;long const &amp;&#34;:
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_OldValue(self, index)

    def SetValue(self, index: &#34;int64&#34;, value: &#34;long const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_SetValue(self, index, value)

    def OnStart(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Called by Start() after synchronizing the operator with the current assignment. Should be overridden instead of Start() to avoid calling VarLocalSearchOperator::Start explicitly.&#34;&#34;&#34;
        return _pywrapcp.IntVarLocalSearchOperatorTemplate_OnStart(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.IntVarLocalSearchOperator" href="#pywrapcp.IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.IntVarLocalSearchOperatorTemplate.IsIncremental"><code class="name flex">
<span>def <span class="ident">IsIncremental</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsIncremental(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.IntVarLocalSearchOperatorTemplate_IsIncremental(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarLocalSearchOperatorTemplate.OldValue"><code class="name flex">
<span>def <span class="ident">OldValue</span></span>(<span>self, index: int64) -> 'long const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OldValue(self, index: &#34;int64&#34;) -&gt; &#34;long const &amp;&#34;:
    return _pywrapcp.IntVarLocalSearchOperatorTemplate_OldValue(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarLocalSearchOperatorTemplate.OnStart"><code class="name flex">
<span>def <span class="ident">OnStart</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Called by Start() after synchronizing the operator with the current assignment. Should be overridden instead of Start() to avoid calling VarLocalSearchOperator::Start explicitly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OnStart(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Called by Start() after synchronizing the operator with the current assignment. Should be overridden instead of Start() to avoid calling VarLocalSearchOperator::Start explicitly.&#34;&#34;&#34;
    return _pywrapcp.IntVarLocalSearchOperatorTemplate_OnStart(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarLocalSearchOperatorTemplate.SetValue"><code class="name flex">
<span>def <span class="ident">SetValue</span></span>(<span>self, index: int64, value: long const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetValue(self, index: &#34;int64&#34;, value: &#34;long const &amp;&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntVarLocalSearchOperatorTemplate_SetValue(self, index, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarLocalSearchOperatorTemplate.Size"><code class="name flex">
<span>def <span class="ident">Size</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Size(self) -&gt; &#34;int&#34;:
    return _pywrapcp.IntVarLocalSearchOperatorTemplate_Size(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarLocalSearchOperatorTemplate.Start"><code class="name flex">
<span>def <span class="ident">Start</span></span>(<span>self, assignment: Assignment) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method should not be overridden. Override OnStart() instead which is called before exiting this method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Start(self, assignment: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method should not be overridden. Override OnStart() instead which is called before exiting this method.&#34;&#34;&#34;
    return _pywrapcp.IntVarLocalSearchOperatorTemplate_Start(self, assignment)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntVarLocalSearchOperatorTemplate.Value"><code class="name flex">
<span>def <span class="ident">Value</span></span>(<span>self, index: int64) -> 'long const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the value in the current assignment of the variable of given index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Value(self, index: &#34;int64&#34;) -&gt; &#34;long const &amp;&#34;:
    r&#34;&#34;&#34; Returns the value in the current assignment of the variable of given index.&#34;&#34;&#34;
    return _pywrapcp.IntVarLocalSearchOperatorTemplate_Value(self, index)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.LocalSearchOperator.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.IntervalVar"><code class="flex name class">
<span>class <span class="ident">IntervalVar</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Interval variables are often used in scheduling. The main characteristics of an IntervalVar are the start position, duration, and end date. All these characteristics can be queried and set, and demons can be posted on their modifications. An important aspect is optionality: an IntervalVar can be performed or not. If unperformed, then it simply does not exist, and its characteristics cannot be accessed any more. An interval var is automatically marked as unperformed when it is not consistent anymore (start greater than end, duration &lt; 0&hellip;)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntervalVar(PropagationBaseObject):
    r&#34;&#34;&#34; Interval variables are often used in scheduling. The main characteristics of an IntervalVar are the start position, duration, and end date. All these characteristics can be queried and set, and demons can be posted on their modifications. An important aspect is optionality: an IntervalVar can be performed or not. If unperformed, then it simply does not exist, and its characteristics cannot be accessed any more. An interval var is automatically marked as unperformed when it is not consistent anymore (start greater than end, duration &lt; 0...)&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)

    def StartMin(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; These methods query, set, and watch the start position of the interval var.&#34;&#34;&#34;
        return _pywrapcp.IntervalVar_StartMin(self)

    def StartMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_StartMax(self)

    def SetStartMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetStartMin(self, m)

    def SetStartMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetStartMax(self, m)

    def SetStartRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetStartRange(self, mi, ma)

    def OldStartMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_OldStartMin(self)

    def OldStartMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_OldStartMax(self)

    def WhenStartRange(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenStartRange(self, *args)

    def WhenStartBound(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenStartBound(self, *args)

    def DurationMin(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; These methods query, set, and watch the duration of the interval var.&#34;&#34;&#34;
        return _pywrapcp.IntervalVar_DurationMin(self)

    def DurationMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_DurationMax(self)

    def SetDurationMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetDurationMin(self, m)

    def SetDurationMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetDurationMax(self, m)

    def SetDurationRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetDurationRange(self, mi, ma)

    def OldDurationMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_OldDurationMin(self)

    def OldDurationMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_OldDurationMax(self)

    def WhenDurationRange(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenDurationRange(self, *args)

    def WhenDurationBound(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenDurationBound(self, *args)

    def EndMin(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; These methods query, set, and watch the end position of the interval var.&#34;&#34;&#34;
        return _pywrapcp.IntervalVar_EndMin(self)

    def EndMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_EndMax(self)

    def SetEndMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetEndMin(self, m)

    def SetEndMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetEndMax(self, m)

    def SetEndRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetEndRange(self, mi, ma)

    def OldEndMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_OldEndMin(self)

    def OldEndMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVar_OldEndMax(self)

    def WhenEndRange(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenEndRange(self, *args)

    def WhenEndBound(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenEndBound(self, *args)

    def MustBePerformed(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; These methods query, set, and watch the performed status of the interval var.&#34;&#34;&#34;
        return _pywrapcp.IntervalVar_MustBePerformed(self)

    def MayBePerformed(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVar_MayBePerformed(self)

    def CannotBePerformed(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVar_CannotBePerformed(self)

    def IsPerformedBound(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVar_IsPerformedBound(self)

    def SetPerformed(self, val: &#34;bool&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_SetPerformed(self, val)

    def WasPerformedBound(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVar_WasPerformedBound(self)

    def WhenPerformedBound(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVar_WhenPerformedBound(self, *args)

    def WhenAnything(self, *args) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Attaches a demon awakened when anything about this interval changes.

        |

        *Overload 2:*
        Attaches a closure awakened when anything about this interval changes.
        &#34;&#34;&#34;
        return _pywrapcp.IntervalVar_WhenAnything(self, *args)

    def StartExpr(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; These methods create expressions encapsulating the start, end and duration of the interval var. Please note that these must not be used if the interval var is unperformed.&#34;&#34;&#34;
        return _pywrapcp.IntervalVar_StartExpr(self)

    def DurationExpr(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntervalVar_DurationExpr(self)

    def EndExpr(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntervalVar_EndExpr(self)

    def PerformedExpr(self) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntervalVar_PerformedExpr(self)

    def SafeStartExpr(self, unperformed_value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; These methods create expressions encapsulating the start, end and duration of the interval var. If the interval var is unperformed, they will return the unperformed_value.&#34;&#34;&#34;
        return _pywrapcp.IntervalVar_SafeStartExpr(self, unperformed_value)

    def SafeDurationExpr(self, unperformed_value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntervalVar_SafeDurationExpr(self, unperformed_value)

    def SafeEndExpr(self, unperformed_value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.IntervalVar_SafeEndExpr(self, unperformed_value)

    def EndsAfterEnd(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAfterEnd(self, other)

    def EndsAfterEndWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAfterEndWithDelay(self, other, delay)

    def EndsAfterStart(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAfterStart(self, other)

    def EndsAfterStartWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAfterStartWithDelay(self, other, delay)

    def EndsAtEnd(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAtEnd(self, other)

    def EndsAtEndWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAtEndWithDelay(self, other, delay)

    def EndsAtStart(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAtStart(self, other)

    def EndsAtStartWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAtStartWithDelay(self, other, delay)

    def StartsAfterEnd(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAfterEnd(self, other)

    def StartsAfterEndWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAfterEndWithDelay(self, other, delay)

    def StartsAfterStart(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAfterStart(self, other)

    def StartsAfterStartWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAfterStartWithDelay(self, other, delay)

    def StartsAtEnd(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAtEnd(self, other)

    def StartsAtEndWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAtEndWithDelay(self, other, delay)

    def StartsAtStart(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAtStart(self, other)

    def StartsAtStartWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAtStartWithDelay(self, other, delay)

    def StaysInSync(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StaysInSync(self, other)

    def StaysInSyncWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StaysInSyncWithDelay(self, other, delay)

    def EndsAfter(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAfter(self, date)

    def EndsAt(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsAt(self, date)

    def EndsBefore(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_EndsBefore(self, date)

    def StartsAfter(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAfter(self, date)

    def StartsAt(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsAt(self, date)

    def StartsBefore(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_StartsBefore(self, date)

    def CrossesDate(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_CrossesDate(self, date)

    def AvoidsDate(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.IntervalVar_AvoidsDate(self, date)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.IntervalVar___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.IntervalVar___str__(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.IntervalVar.AvoidsDate"><code class="name flex">
<span>def <span class="ident">AvoidsDate</span></span>(<span>self, date: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AvoidsDate(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_AvoidsDate(self, date)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.CannotBePerformed"><code class="name flex">
<span>def <span class="ident">CannotBePerformed</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CannotBePerformed(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.IntervalVar_CannotBePerformed(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.CrossesDate"><code class="name flex">
<span>def <span class="ident">CrossesDate</span></span>(<span>self, date: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CrossesDate(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_CrossesDate(self, date)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.DurationExpr"><code class="name flex">
<span>def <span class="ident">DurationExpr</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DurationExpr(self) -&gt; &#34;operations_research::IntExpr *&#34;:
    return _pywrapcp.IntervalVar_DurationExpr(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.DurationMax"><code class="name flex">
<span>def <span class="ident">DurationMax</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DurationMax(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVar_DurationMax(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.DurationMin"><code class="name flex">
<span>def <span class="ident">DurationMin</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>These methods query, set, and watch the duration of the interval var.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DurationMin(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; These methods query, set, and watch the duration of the interval var.&#34;&#34;&#34;
    return _pywrapcp.IntervalVar_DurationMin(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndExpr"><code class="name flex">
<span>def <span class="ident">EndExpr</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndExpr(self) -&gt; &#34;operations_research::IntExpr *&#34;:
    return _pywrapcp.IntervalVar_EndExpr(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndMax"><code class="name flex">
<span>def <span class="ident">EndMax</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndMax(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVar_EndMax(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndMin"><code class="name flex">
<span>def <span class="ident">EndMin</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>These methods query, set, and watch the end position of the interval var.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndMin(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; These methods query, set, and watch the end position of the interval var.&#34;&#34;&#34;
    return _pywrapcp.IntervalVar_EndMin(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndsAfter"><code class="name flex">
<span>def <span class="ident">EndsAfter</span></span>(<span>self, date: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndsAfter(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_EndsAfter(self, date)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndsAfterEnd"><code class="name flex">
<span>def <span class="ident">EndsAfterEnd</span></span>(<span>self, other: IntervalVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndsAfterEnd(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_EndsAfterEnd(self, other)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndsAfterEndWithDelay"><code class="name flex">
<span>def <span class="ident">EndsAfterEndWithDelay</span></span>(<span>self, other: IntervalVar, delay: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndsAfterEndWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_EndsAfterEndWithDelay(self, other, delay)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndsAfterStart"><code class="name flex">
<span>def <span class="ident">EndsAfterStart</span></span>(<span>self, other: IntervalVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndsAfterStart(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_EndsAfterStart(self, other)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndsAfterStartWithDelay"><code class="name flex">
<span>def <span class="ident">EndsAfterStartWithDelay</span></span>(<span>self, other: IntervalVar, delay: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndsAfterStartWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_EndsAfterStartWithDelay(self, other, delay)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndsAt"><code class="name flex">
<span>def <span class="ident">EndsAt</span></span>(<span>self, date: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndsAt(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_EndsAt(self, date)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndsAtEnd"><code class="name flex">
<span>def <span class="ident">EndsAtEnd</span></span>(<span>self, other: IntervalVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndsAtEnd(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_EndsAtEnd(self, other)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndsAtEndWithDelay"><code class="name flex">
<span>def <span class="ident">EndsAtEndWithDelay</span></span>(<span>self, other: IntervalVar, delay: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndsAtEndWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_EndsAtEndWithDelay(self, other, delay)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndsAtStart"><code class="name flex">
<span>def <span class="ident">EndsAtStart</span></span>(<span>self, other: IntervalVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndsAtStart(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_EndsAtStart(self, other)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndsAtStartWithDelay"><code class="name flex">
<span>def <span class="ident">EndsAtStartWithDelay</span></span>(<span>self, other: IntervalVar, delay: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndsAtStartWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_EndsAtStartWithDelay(self, other, delay)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.EndsBefore"><code class="name flex">
<span>def <span class="ident">EndsBefore</span></span>(<span>self, date: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndsBefore(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_EndsBefore(self, date)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.IsPerformedBound"><code class="name flex">
<span>def <span class="ident">IsPerformedBound</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsPerformedBound(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.IntervalVar_IsPerformedBound(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.MayBePerformed"><code class="name flex">
<span>def <span class="ident">MayBePerformed</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MayBePerformed(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.IntervalVar_MayBePerformed(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.MustBePerformed"><code class="name flex">
<span>def <span class="ident">MustBePerformed</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>These methods query, set, and watch the performed status of the interval var.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MustBePerformed(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; These methods query, set, and watch the performed status of the interval var.&#34;&#34;&#34;
    return _pywrapcp.IntervalVar_MustBePerformed(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.OldDurationMax"><code class="name flex">
<span>def <span class="ident">OldDurationMax</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OldDurationMax(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVar_OldDurationMax(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.OldDurationMin"><code class="name flex">
<span>def <span class="ident">OldDurationMin</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OldDurationMin(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVar_OldDurationMin(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.OldEndMax"><code class="name flex">
<span>def <span class="ident">OldEndMax</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OldEndMax(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVar_OldEndMax(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.OldEndMin"><code class="name flex">
<span>def <span class="ident">OldEndMin</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OldEndMin(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVar_OldEndMin(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.OldStartMax"><code class="name flex">
<span>def <span class="ident">OldStartMax</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OldStartMax(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVar_OldStartMax(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.OldStartMin"><code class="name flex">
<span>def <span class="ident">OldStartMin</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OldStartMin(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVar_OldStartMin(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.PerformedExpr"><code class="name flex">
<span>def <span class="ident">PerformedExpr</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PerformedExpr(self) -&gt; &#34;operations_research::IntExpr *&#34;:
    return _pywrapcp.IntervalVar_PerformedExpr(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.SafeDurationExpr"><code class="name flex">
<span>def <span class="ident">SafeDurationExpr</span></span>(<span>self, unperformed_value: int64) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SafeDurationExpr(self, unperformed_value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
    return _pywrapcp.IntervalVar_SafeDurationExpr(self, unperformed_value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.SafeEndExpr"><code class="name flex">
<span>def <span class="ident">SafeEndExpr</span></span>(<span>self, unperformed_value: int64) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SafeEndExpr(self, unperformed_value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
    return _pywrapcp.IntervalVar_SafeEndExpr(self, unperformed_value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.SafeStartExpr"><code class="name flex">
<span>def <span class="ident">SafeStartExpr</span></span>(<span>self, unperformed_value: int64) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>These methods create expressions encapsulating the start, end and duration of the interval var. If the interval var is unperformed, they will return the unperformed_value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SafeStartExpr(self, unperformed_value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
    r&#34;&#34;&#34; These methods create expressions encapsulating the start, end and duration of the interval var. If the interval var is unperformed, they will return the unperformed_value.&#34;&#34;&#34;
    return _pywrapcp.IntervalVar_SafeStartExpr(self, unperformed_value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.SetDurationMax"><code class="name flex">
<span>def <span class="ident">SetDurationMax</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetDurationMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_SetDurationMax(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.SetDurationMin"><code class="name flex">
<span>def <span class="ident">SetDurationMin</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetDurationMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_SetDurationMin(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.SetDurationRange"><code class="name flex">
<span>def <span class="ident">SetDurationRange</span></span>(<span>self, mi: int64, ma: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetDurationRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_SetDurationRange(self, mi, ma)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.SetEndMax"><code class="name flex">
<span>def <span class="ident">SetEndMax</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetEndMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_SetEndMax(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.SetEndMin"><code class="name flex">
<span>def <span class="ident">SetEndMin</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetEndMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_SetEndMin(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.SetEndRange"><code class="name flex">
<span>def <span class="ident">SetEndRange</span></span>(<span>self, mi: int64, ma: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetEndRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_SetEndRange(self, mi, ma)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.SetPerformed"><code class="name flex">
<span>def <span class="ident">SetPerformed</span></span>(<span>self, val: bool) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetPerformed(self, val: &#34;bool&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_SetPerformed(self, val)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.SetStartMax"><code class="name flex">
<span>def <span class="ident">SetStartMax</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetStartMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_SetStartMax(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.SetStartMin"><code class="name flex">
<span>def <span class="ident">SetStartMin</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetStartMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_SetStartMin(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.SetStartRange"><code class="name flex">
<span>def <span class="ident">SetStartRange</span></span>(<span>self, mi: int64, ma: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetStartRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_SetStartRange(self, mi, ma)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartExpr"><code class="name flex">
<span>def <span class="ident">StartExpr</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>These methods create expressions encapsulating the start, end and duration of the interval var. Please note that these must not be used if the interval var is unperformed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartExpr(self) -&gt; &#34;operations_research::IntExpr *&#34;:
    r&#34;&#34;&#34; These methods create expressions encapsulating the start, end and duration of the interval var. Please note that these must not be used if the interval var is unperformed.&#34;&#34;&#34;
    return _pywrapcp.IntervalVar_StartExpr(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartMax"><code class="name flex">
<span>def <span class="ident">StartMax</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartMax(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVar_StartMax(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartMin"><code class="name flex">
<span>def <span class="ident">StartMin</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>These methods query, set, and watch the start position of the interval var.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartMin(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; These methods query, set, and watch the start position of the interval var.&#34;&#34;&#34;
    return _pywrapcp.IntervalVar_StartMin(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartsAfter"><code class="name flex">
<span>def <span class="ident">StartsAfter</span></span>(<span>self, date: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartsAfter(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_StartsAfter(self, date)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartsAfterEnd"><code class="name flex">
<span>def <span class="ident">StartsAfterEnd</span></span>(<span>self, other: IntervalVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartsAfterEnd(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_StartsAfterEnd(self, other)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartsAfterEndWithDelay"><code class="name flex">
<span>def <span class="ident">StartsAfterEndWithDelay</span></span>(<span>self, other: IntervalVar, delay: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartsAfterEndWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_StartsAfterEndWithDelay(self, other, delay)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartsAfterStart"><code class="name flex">
<span>def <span class="ident">StartsAfterStart</span></span>(<span>self, other: IntervalVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartsAfterStart(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_StartsAfterStart(self, other)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartsAfterStartWithDelay"><code class="name flex">
<span>def <span class="ident">StartsAfterStartWithDelay</span></span>(<span>self, other: IntervalVar, delay: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartsAfterStartWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_StartsAfterStartWithDelay(self, other, delay)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartsAt"><code class="name flex">
<span>def <span class="ident">StartsAt</span></span>(<span>self, date: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartsAt(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_StartsAt(self, date)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartsAtEnd"><code class="name flex">
<span>def <span class="ident">StartsAtEnd</span></span>(<span>self, other: IntervalVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartsAtEnd(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_StartsAtEnd(self, other)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartsAtEndWithDelay"><code class="name flex">
<span>def <span class="ident">StartsAtEndWithDelay</span></span>(<span>self, other: IntervalVar, delay: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartsAtEndWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_StartsAtEndWithDelay(self, other, delay)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartsAtStart"><code class="name flex">
<span>def <span class="ident">StartsAtStart</span></span>(<span>self, other: IntervalVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartsAtStart(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_StartsAtStart(self, other)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartsAtStartWithDelay"><code class="name flex">
<span>def <span class="ident">StartsAtStartWithDelay</span></span>(<span>self, other: IntervalVar, delay: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartsAtStartWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_StartsAtStartWithDelay(self, other, delay)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StartsBefore"><code class="name flex">
<span>def <span class="ident">StartsBefore</span></span>(<span>self, date: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartsBefore(self, date: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_StartsBefore(self, date)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StaysInSync"><code class="name flex">
<span>def <span class="ident">StaysInSync</span></span>(<span>self, other: IntervalVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StaysInSync(self, other: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_StaysInSync(self, other)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.StaysInSyncWithDelay"><code class="name flex">
<span>def <span class="ident">StaysInSyncWithDelay</span></span>(<span>self, other: IntervalVar, delay: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StaysInSyncWithDelay(self, other: &#34;IntervalVar&#34;, delay: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.IntervalVar_StaysInSyncWithDelay(self, other, delay)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.WasPerformedBound"><code class="name flex">
<span>def <span class="ident">WasPerformedBound</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WasPerformedBound(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.IntervalVar_WasPerformedBound(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.WhenAnything"><code class="name flex">
<span>def <span class="ident">WhenAnything</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Attaches a demon awakened when anything about this interval changes.</p>
<p>|</p>
<p><em>Overload 2:</em>
Attaches a closure awakened when anything about this interval changes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WhenAnything(self, *args) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Attaches a demon awakened when anything about this interval changes.

    |

    *Overload 2:*
    Attaches a closure awakened when anything about this interval changes.
    &#34;&#34;&#34;
    return _pywrapcp.IntervalVar_WhenAnything(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.WhenDurationBound"><code class="name flex">
<span>def <span class="ident">WhenDurationBound</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WhenDurationBound(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_WhenDurationBound(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.WhenDurationRange"><code class="name flex">
<span>def <span class="ident">WhenDurationRange</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WhenDurationRange(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_WhenDurationRange(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.WhenEndBound"><code class="name flex">
<span>def <span class="ident">WhenEndBound</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WhenEndBound(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_WhenEndBound(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.WhenEndRange"><code class="name flex">
<span>def <span class="ident">WhenEndRange</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WhenEndRange(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_WhenEndRange(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.WhenPerformedBound"><code class="name flex">
<span>def <span class="ident">WhenPerformedBound</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WhenPerformedBound(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_WhenPerformedBound(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.WhenStartBound"><code class="name flex">
<span>def <span class="ident">WhenStartBound</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WhenStartBound(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_WhenStartBound(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVar.WhenStartRange"><code class="name flex">
<span>def <span class="ident">WhenStartRange</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WhenStartRange(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVar_WhenStartRange(self, *args)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.PropagationBaseObject.Name" href="#pywrapcp.PropagationBaseObject.Name">Name</a></code></li>
<li><code><a title="pywrapcp.PropagationBaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.IntervalVarContainer"><code class="flex name class">
<span>class <span class="ident">IntervalVarContainer</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntervalVarContainer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Contains(self, var: &#34;IntervalVar&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVarContainer_Contains(self, var)

    def Element(self, index: &#34;int&#34;) -&gt; &#34;operations_research::IntervalVarElement *&#34;:
        return _pywrapcp.IntervalVarContainer_Element(self, index)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.IntervalVarContainer_Size(self)

    def Store(self) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarContainer_Store(self)

    def Restore(self) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarContainer_Restore(self)

    def __eq__(self, container: &#34;IntervalVarContainer&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if this and &#39;container&#39; both represent the same V* -&gt; E map. Runs in linear time; requires that the == operator on the type E is well defined.&#34;&#34;&#34;
        return _pywrapcp.IntervalVarContainer___eq__(self, container)

    def __ne__(self, container: &#34;IntervalVarContainer&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVarContainer___ne__(self, container)
    __swig_destroy__ = _pywrapcp.delete_IntervalVarContainer</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapcp.IntervalVarContainer.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<div class="desc"><p>The membership flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.IntervalVarContainer.Contains"><code class="name flex">
<span>def <span class="ident">Contains</span></span>(<span>self, var: IntervalVar) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Contains(self, var: &#34;IntervalVar&#34;) -&gt; &#34;bool&#34;:
    return _pywrapcp.IntervalVarContainer_Contains(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarContainer.Element"><code class="name flex">
<span>def <span class="ident">Element</span></span>(<span>self, index: int) -> 'operations_research::<a title="pywrapcp.IntervalVarElement" href="#pywrapcp.IntervalVarElement">IntervalVarElement</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Element(self, index: &#34;int&#34;) -&gt; &#34;operations_research::IntervalVarElement *&#34;:
    return _pywrapcp.IntervalVarContainer_Element(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarContainer.Restore"><code class="name flex">
<span>def <span class="ident">Restore</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Restore(self) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarContainer_Restore(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarContainer.Size"><code class="name flex">
<span>def <span class="ident">Size</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Size(self) -&gt; &#34;int&#34;:
    return _pywrapcp.IntervalVarContainer_Size(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarContainer.Store"><code class="name flex">
<span>def <span class="ident">Store</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Store(self) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarContainer_Store(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywrapcp.IntervalVarElement"><code class="flex name class">
<span>class <span class="ident">IntervalVarElement</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntervalVarElement(AssignmentElement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Var(self) -&gt; &#34;operations_research::IntervalVar *&#34;:
        return _pywrapcp.IntervalVarElement_Var(self)

    def StartMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_StartMin(self)

    def StartMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_StartMax(self)

    def StartValue(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_StartValue(self)

    def DurationMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_DurationMin(self)

    def DurationMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_DurationMax(self)

    def DurationValue(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_DurationValue(self)

    def EndMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_EndMin(self)

    def EndMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_EndMax(self)

    def EndValue(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_EndValue(self)

    def PerformedMin(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_PerformedMin(self)

    def PerformedMax(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_PerformedMax(self)

    def PerformedValue(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.IntervalVarElement_PerformedValue(self)

    def SetStartMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetStartMin(self, m)

    def SetStartMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetStartMax(self, m)

    def SetStartRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetStartRange(self, mi, ma)

    def SetStartValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetStartValue(self, v)

    def SetDurationMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetDurationMin(self, m)

    def SetDurationMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetDurationMax(self, m)

    def SetDurationRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetDurationRange(self, mi, ma)

    def SetDurationValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetDurationValue(self, v)

    def SetEndMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetEndMin(self, m)

    def SetEndMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetEndMax(self, m)

    def SetEndRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetEndRange(self, mi, ma)

    def SetEndValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetEndValue(self, v)

    def SetPerformedMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetPerformedMin(self, m)

    def SetPerformedMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetPerformedMax(self, m)

    def SetPerformedRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetPerformedRange(self, mi, ma)

    def SetPerformedValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.IntervalVarElement_SetPerformedValue(self, v)

    def __eq__(self, element: &#34;IntervalVarElement&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVarElement___eq__(self, element)

    def __ne__(self, element: &#34;IntervalVarElement&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.IntervalVarElement___ne__(self, element)
    __swig_destroy__ = _pywrapcp.delete_IntervalVarElement</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.AssignmentElement" href="#pywrapcp.AssignmentElement">AssignmentElement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.IntervalVarElement.DurationMax"><code class="name flex">
<span>def <span class="ident">DurationMax</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DurationMax(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVarElement_DurationMax(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.DurationMin"><code class="name flex">
<span>def <span class="ident">DurationMin</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DurationMin(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVarElement_DurationMin(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.DurationValue"><code class="name flex">
<span>def <span class="ident">DurationValue</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DurationValue(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVarElement_DurationValue(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.EndMax"><code class="name flex">
<span>def <span class="ident">EndMax</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndMax(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVarElement_EndMax(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.EndMin"><code class="name flex">
<span>def <span class="ident">EndMin</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndMin(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVarElement_EndMin(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.EndValue"><code class="name flex">
<span>def <span class="ident">EndValue</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndValue(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVarElement_EndValue(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.PerformedMax"><code class="name flex">
<span>def <span class="ident">PerformedMax</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PerformedMax(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVarElement_PerformedMax(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.PerformedMin"><code class="name flex">
<span>def <span class="ident">PerformedMin</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PerformedMin(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVarElement_PerformedMin(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.PerformedValue"><code class="name flex">
<span>def <span class="ident">PerformedValue</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PerformedValue(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVarElement_PerformedValue(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetDurationMax"><code class="name flex">
<span>def <span class="ident">SetDurationMax</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetDurationMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetDurationMax(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetDurationMin"><code class="name flex">
<span>def <span class="ident">SetDurationMin</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetDurationMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetDurationMin(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetDurationRange"><code class="name flex">
<span>def <span class="ident">SetDurationRange</span></span>(<span>self, mi: int64, ma: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetDurationRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetDurationRange(self, mi, ma)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetDurationValue"><code class="name flex">
<span>def <span class="ident">SetDurationValue</span></span>(<span>self, v: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetDurationValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetDurationValue(self, v)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetEndMax"><code class="name flex">
<span>def <span class="ident">SetEndMax</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetEndMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetEndMax(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetEndMin"><code class="name flex">
<span>def <span class="ident">SetEndMin</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetEndMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetEndMin(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetEndRange"><code class="name flex">
<span>def <span class="ident">SetEndRange</span></span>(<span>self, mi: int64, ma: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetEndRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetEndRange(self, mi, ma)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetEndValue"><code class="name flex">
<span>def <span class="ident">SetEndValue</span></span>(<span>self, v: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetEndValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetEndValue(self, v)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetPerformedMax"><code class="name flex">
<span>def <span class="ident">SetPerformedMax</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetPerformedMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetPerformedMax(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetPerformedMin"><code class="name flex">
<span>def <span class="ident">SetPerformedMin</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetPerformedMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetPerformedMin(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetPerformedRange"><code class="name flex">
<span>def <span class="ident">SetPerformedRange</span></span>(<span>self, mi: int64, ma: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetPerformedRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetPerformedRange(self, mi, ma)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetPerformedValue"><code class="name flex">
<span>def <span class="ident">SetPerformedValue</span></span>(<span>self, v: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetPerformedValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetPerformedValue(self, v)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetStartMax"><code class="name flex">
<span>def <span class="ident">SetStartMax</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetStartMax(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetStartMax(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetStartMin"><code class="name flex">
<span>def <span class="ident">SetStartMin</span></span>(<span>self, m: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetStartMin(self, m: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetStartMin(self, m)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetStartRange"><code class="name flex">
<span>def <span class="ident">SetStartRange</span></span>(<span>self, mi: int64, ma: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetStartRange(self, mi: &#34;int64&#34;, ma: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetStartRange(self, mi, ma)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.SetStartValue"><code class="name flex">
<span>def <span class="ident">SetStartValue</span></span>(<span>self, v: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetStartValue(self, v: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.IntervalVarElement_SetStartValue(self, v)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.StartMax"><code class="name flex">
<span>def <span class="ident">StartMax</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartMax(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVarElement_StartMax(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.StartMin"><code class="name flex">
<span>def <span class="ident">StartMin</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartMin(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVarElement_StartMin(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.StartValue"><code class="name flex">
<span>def <span class="ident">StartValue</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartValue(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.IntervalVarElement_StartValue(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.IntervalVarElement.Var"><code class="name flex">
<span>def <span class="ident">Var</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Var(self) -&gt; &#34;operations_research::IntervalVar *&#34;:
    return _pywrapcp.IntervalVarElement_Var(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.AssignmentElement" href="#pywrapcp.AssignmentElement">AssignmentElement</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.AssignmentElement.thisown" href="#pywrapcp.AssignmentElement.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.LocalSearchFilter"><code class="flex name class">
<span>class <span class="ident">LocalSearchFilter</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Local Search Filters are used for fast neighbor pruning. Filtering a move is done in several phases: - in the Relax phase, filters determine which parts of their internals
will be changed by the candidate, and modify intermediary State - in the Accept phase, filters check that the candidate is feasible, - if the Accept phase succeeds, the solver may decide to trigger a
Synchronize phase that makes filters change their internal representation
to the last candidate, - otherwise (Accept fails or the solver does not want to synchronize),
a Revert phase makes filters erase any intermediary State generated by the
Relax and Accept phases. A given filter has phases called with the following pattern: (Relax.Accept.Synchronize | Relax.Accept.Revert | Relax.Revert)*. Filters's Revert() is always called in the reverse order their Accept() was called, to allow late filters to use state done/undone by early filters' Accept()/Revert().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocalSearchFilter(BaseObject):
    r&#34;&#34;&#34; Local Search Filters are used for fast neighbor pruning. Filtering a move is done in several phases: - in the Relax phase, filters determine which parts of their internals   will be changed by the candidate, and modify intermediary State - in the Accept phase, filters check that the candidate is feasible, - if the Accept phase succeeds, the solver may decide to trigger a   Synchronize phase that makes filters change their internal representation   to the last candidate, - otherwise (Accept fails or the solver does not want to synchronize),   a Revert phase makes filters erase any intermediary State generated by the   Relax and Accept phases. A given filter has phases called with the following pattern: (Relax.Accept.Synchronize | Relax.Accept.Revert | Relax.Revert)*. Filters&#39;s Revert() is always called in the reverse order their Accept() was called, to allow late filters to use state done/undone by early filters&#39; Accept()/Revert().&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def Accept(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;, objective_min: &#34;int64&#34;, objective_max: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Accepts a &#34;delta&#34; given the assignment with which the filter has been synchronized; the delta holds the variables which have been modified and their new value. If the filter represents a part of the global objective, its contribution must be between objective_min and objective_max. Sample: supposing one wants to maintain a[0,1] + b[0,1] &lt;= 1, for the assignment (a,1), (b,0), the delta (b,1) will be rejected but the delta (a,0) will be accepted. TODO(user): Remove arguments when there are no more need for those.&#34;&#34;&#34;
        return _pywrapcp.LocalSearchFilter_Accept(self, delta, deltadelta, objective_min, objective_max)

    def IsIncremental(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.LocalSearchFilter_IsIncremental(self)

    def Synchronize(self, assignment: &#34;Assignment&#34;, delta: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Synchronizes the filter with the current solution, delta being the difference with the solution passed to the previous call to Synchronize() or IncrementalSynchronize(). &#39;delta&#39; can be used to incrementally synchronizing the filter with the new solution by only considering the changes in delta.&#34;&#34;&#34;
        return _pywrapcp.LocalSearchFilter_Synchronize(self, assignment, delta)
    __swig_destroy__ = _pywrapcp.delete_LocalSearchFilter</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.IntVarLocalSearchFilter" href="#pywrapcp.IntVarLocalSearchFilter">IntVarLocalSearchFilter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.LocalSearchFilter.Accept"><code class="name flex">
<span>def <span class="ident">Accept</span></span>(<span>self, delta: Assignment, deltadelta: Assignment, objective_min: int64, objective_max: int64) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Accepts a "delta" given the assignment with which the filter has been synchronized; the delta holds the variables which have been modified and their new value. If the filter represents a part of the global objective, its contribution must be between objective_min and objective_max. Sample: supposing one wants to maintain a[0,1] + b[0,1] &lt;= 1, for the assignment (a,1), (b,0), the delta (b,1) will be rejected but the delta (a,0) will be accepted. TODO(user): Remove arguments when there are no more need for those.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Accept(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;, objective_min: &#34;int64&#34;, objective_max: &#34;int64&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Accepts a &#34;delta&#34; given the assignment with which the filter has been synchronized; the delta holds the variables which have been modified and their new value. If the filter represents a part of the global objective, its contribution must be between objective_min and objective_max. Sample: supposing one wants to maintain a[0,1] + b[0,1] &lt;= 1, for the assignment (a,1), (b,0), the delta (b,1) will be rejected but the delta (a,0) will be accepted. TODO(user): Remove arguments when there are no more need for those.&#34;&#34;&#34;
    return _pywrapcp.LocalSearchFilter_Accept(self, delta, deltadelta, objective_min, objective_max)</code></pre>
</details>
</dd>
<dt id="pywrapcp.LocalSearchFilter.IsIncremental"><code class="name flex">
<span>def <span class="ident">IsIncremental</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsIncremental(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.LocalSearchFilter_IsIncremental(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.LocalSearchFilter.Synchronize"><code class="name flex">
<span>def <span class="ident">Synchronize</span></span>(<span>self, assignment: Assignment, delta: Assignment) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Synchronizes the filter with the current solution, delta being the difference with the solution passed to the previous call to Synchronize() or IncrementalSynchronize(). 'delta' can be used to incrementally synchronizing the filter with the new solution by only considering the changes in delta.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Synchronize(self, assignment: &#34;Assignment&#34;, delta: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Synchronizes the filter with the current solution, delta being the difference with the solution passed to the previous call to Synchronize() or IncrementalSynchronize(). &#39;delta&#39; can be used to incrementally synchronizing the filter with the new solution by only considering the changes in delta.&#34;&#34;&#34;
    return _pywrapcp.LocalSearchFilter_Synchronize(self, assignment, delta)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.BaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.LocalSearchOperator"><code class="flex name class">
<span>class <span class="ident">LocalSearchOperator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represent a reversible FIFO structure. The main difference w.r.t a standard FIFO structure is that a Solver is given as parameter to the modifiers such that the solver can store the backtrack information Iterator's traversing order should not be changed, as some algorithm depend on it to be consistent. It's main use is to store a list of demons in the various classes of variables. The base class for all local search operators. A local search operator is an object that defines the neighborhood of a solution. In other words, a neighborhood is the set of solutions which can be reached from a given solution using an operator. The behavior of the LocalSearchOperator class is similar to iterators. The operator is synchronized with an assignment (gives the current values of the variables); this is done in the Start() method. Then one can iterate over the neighbors using the MakeNextNeighbor method. This method returns an assignment which represents the incremental changes to the current solution. It also returns a second assignment representing the changes to the last solution defined by the neighborhood operator; this assignment is empty if the neighborhood operator cannot track this information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LocalSearchOperator(BaseObject):
    r&#34;&#34;&#34; This class represent a reversible FIFO structure. The main difference w.r.t a standard FIFO structure is that a Solver is given as parameter to the modifiers such that the solver can store the backtrack information Iterator&#39;s traversing order should not be changed, as some algorithm depend on it to be consistent. It&#39;s main use is to store a list of demons in the various classes of variables. The base class for all local search operators. A local search operator is an object that defines the neighborhood of a solution. In other words, a neighborhood is the set of solutions which can be reached from a given solution using an operator. The behavior of the LocalSearchOperator class is similar to iterators. The operator is synchronized with an assignment (gives the current values of the variables); this is done in the Start() method. Then one can iterate over the neighbors using the MakeNextNeighbor method. This method returns an assignment which represents the incremental changes to the current solution. It also returns a second assignment representing the changes to the last solution defined by the neighborhood operator; this assignment is empty if the neighborhood operator cannot track this information.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def NextNeighbor(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.LocalSearchOperator_NextNeighbor(self, delta, deltadelta)

    def Start(self, assignment: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.LocalSearchOperator_Start(self, assignment)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_LocalSearchOperator(self)
        return weakref.proxy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.IntVarLocalSearchOperatorTemplate" href="#pywrapcp.IntVarLocalSearchOperatorTemplate">IntVarLocalSearchOperatorTemplate</a></li>
<li><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate">SequenceVarLocalSearchOperatorTemplate</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.LocalSearchOperator.NextNeighbor"><code class="name flex">
<span>def <span class="ident">NextNeighbor</span></span>(<span>self, delta: Assignment, deltadelta: Assignment) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NextNeighbor(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
    return _pywrapcp.LocalSearchOperator_NextNeighbor(self, delta, deltadelta)</code></pre>
</details>
</dd>
<dt id="pywrapcp.LocalSearchOperator.Start"><code class="name flex">
<span>def <span class="ident">Start</span></span>(<span>self, assignment: Assignment) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Start(self, assignment: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.LocalSearchOperator_Start(self, assignment)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.BaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.NumericalRevInteger"><code class="flex name class">
<span>class <span class="ident">NumericalRevInteger</span></span>
<span>(</span><span>val: long const &)</span>
</code></dt>
<dd>
<div class="desc"><p>Subclass of Rev<T> which adds numerical operations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NumericalRevInteger(RevInteger):
    r&#34;&#34;&#34; Subclass of Rev&lt;T&gt; which adds numerical operations.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, val: &#34;long const &amp;&#34;):
        _pywrapcp.NumericalRevInteger_swiginit(self, _pywrapcp.new_NumericalRevInteger(val))

    def Add(self, s: &#34;Solver&#34;, to_add: &#34;long const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.NumericalRevInteger_Add(self, s, to_add)

    def Incr(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.NumericalRevInteger_Incr(self, s)

    def Decr(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.NumericalRevInteger_Decr(self, s)
    __swig_destroy__ = _pywrapcp.delete_NumericalRevInteger</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.RevInteger" href="#pywrapcp.RevInteger">RevInteger</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.NumericalRevInteger.Add"><code class="name flex">
<span>def <span class="ident">Add</span></span>(<span>self, s: Solver, to_add: long const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Add(self, s: &#34;Solver&#34;, to_add: &#34;long const &amp;&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.NumericalRevInteger_Add(self, s, to_add)</code></pre>
</details>
</dd>
<dt id="pywrapcp.NumericalRevInteger.Decr"><code class="name flex">
<span>def <span class="ident">Decr</span></span>(<span>self, s: Solver) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Decr(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.NumericalRevInteger_Decr(self, s)</code></pre>
</details>
</dd>
<dt id="pywrapcp.NumericalRevInteger.Incr"><code class="name flex">
<span>def <span class="ident">Incr</span></span>(<span>self, s: Solver) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Incr(self, s: &#34;Solver&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.NumericalRevInteger_Incr(self, s)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.RevInteger" href="#pywrapcp.RevInteger">RevInteger</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.RevInteger.thisown" href="#pywrapcp.RevInteger.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.OptimizeVar"><code class="flex name class">
<span>class <span class="ident">OptimizeVar</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This class encapsulates an objective. It requires the direction (minimize or maximize), the variable to optimize, and the improvement step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptimizeVar(SearchMonitor):
    r&#34;&#34;&#34; This class encapsulates an objective. It requires the direction (minimize or maximize), the variable to optimize, and the improvement step.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Best(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the best value found during search.&#34;&#34;&#34;
        return _pywrapcp.OptimizeVar_Best(self)

    def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the variable that is optimized.&#34;&#34;&#34;
        return _pywrapcp.OptimizeVar_Var(self)

    def AcceptDelta(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Internal methods.&#34;&#34;&#34;
        return _pywrapcp.OptimizeVar_AcceptDelta(self, delta, deltadelta)

    def EnterSearch(self) -&gt; &#34;void&#34;:
        return _pywrapcp.OptimizeVar_EnterSearch(self)

    def BeginNextDecision(self, db: &#34;DecisionBuilder&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.OptimizeVar_BeginNextDecision(self, db)

    def RefuteDecision(self, d: &#34;Decision&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.OptimizeVar_RefuteDecision(self, d)

    def AtSolution(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.OptimizeVar_AtSolution(self)

    def AcceptSolution(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.OptimizeVar_AcceptSolution(self)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.OptimizeVar_DebugString(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.OptimizeVar.AcceptDelta"><code class="name flex">
<span>def <span class="ident">AcceptDelta</span></span>(<span>self, delta: Assignment, deltadelta: Assignment) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Internal methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AcceptDelta(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Internal methods.&#34;&#34;&#34;
    return _pywrapcp.OptimizeVar_AcceptDelta(self, delta, deltadelta)</code></pre>
</details>
</dd>
<dt id="pywrapcp.OptimizeVar.Best"><code class="name flex">
<span>def <span class="ident">Best</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the best value found during search.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Best(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the best value found during search.&#34;&#34;&#34;
    return _pywrapcp.OptimizeVar_Best(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.OptimizeVar.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.OptimizeVar_DebugString(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.OptimizeVar.Var"><code class="name flex">
<span>def <span class="ident">Var</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the variable that is optimized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Var(self) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; Returns the variable that is optimized.&#34;&#34;&#34;
    return _pywrapcp.OptimizeVar_Var(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.SearchMonitor.AcceptNeighbor" href="#pywrapcp.SearchMonitor.AcceptNeighbor">AcceptNeighbor</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.AcceptSolution" href="#pywrapcp.SearchMonitor.AcceptSolution">AcceptSolution</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.AfterDecision" href="#pywrapcp.SearchMonitor.AfterDecision">AfterDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.ApplyDecision" href="#pywrapcp.SearchMonitor.ApplyDecision">ApplyDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.AtSolution" href="#pywrapcp.SearchMonitor.AtSolution">AtSolution</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.BeginFail" href="#pywrapcp.SearchMonitor.BeginFail">BeginFail</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.BeginInitialPropagation" href="#pywrapcp.SearchMonitor.BeginInitialPropagation">BeginInitialPropagation</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.BeginNextDecision" href="#pywrapcp.SearchMonitor.BeginNextDecision">BeginNextDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EndFail" href="#pywrapcp.SearchMonitor.EndFail">EndFail</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EndInitialPropagation" href="#pywrapcp.SearchMonitor.EndInitialPropagation">EndInitialPropagation</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EndNextDecision" href="#pywrapcp.SearchMonitor.EndNextDecision">EndNextDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EnterSearch" href="#pywrapcp.SearchMonitor.EnterSearch">EnterSearch</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.ExitSearch" href="#pywrapcp.SearchMonitor.ExitSearch">ExitSearch</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.LocalOptimum" href="#pywrapcp.SearchMonitor.LocalOptimum">LocalOptimum</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.NoMoreSolutions" href="#pywrapcp.SearchMonitor.NoMoreSolutions">NoMoreSolutions</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.RefuteDecision" href="#pywrapcp.SearchMonitor.RefuteDecision">RefuteDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.RestartSearch" href="#pywrapcp.SearchMonitor.RestartSearch">RestartSearch</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.Pack"><code class="flex name class">
<span>class <span class="ident">Pack</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A constraint is the main modeling object. It provides two methods:
- Post() is responsible for creating the demons and attaching them to
immediate demons().
- InitialPropagate() is called once just after Post and performs
the initial propagation. The subsequent propagations will be performed
by the demons Posted during the post() method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pack(Constraint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def AddWeightedSumLessOrEqualConstantDimension(self, *args) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Dimensions are additional constraints than can restrict what is possible with the pack constraint. It can be used to set capacity limits, to count objects per bin, to compute unassigned penalties... This dimension imposes that for all bins b, the weighted sum (weights[i]) of all objects i assigned to &#39;b&#39; is less or equal &#39;bounds[b]&#39;.

        |

        *Overload 2:*
        This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i)) of all objects i assigned to &#39;b&#39; is less or equal to &#39;bounds[b]&#39;. Ownership of the callback is transferred to the pack constraint.

        |

        *Overload 3:*
        This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i, b) of all objects i assigned to &#39;b&#39; is less or equal to &#39;bounds[b]&#39;. Ownership of the callback is transferred to the pack constraint.
        &#34;&#34;&#34;
        return _pywrapcp.Pack_AddWeightedSumLessOrEqualConstantDimension(self, *args)

    def AddWeightedSumEqualVarDimension(self, *args) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This dimension imposes that for all bins b, the weighted sum (weights[i]) of all objects i assigned to &#39;b&#39; is equal to loads[b].

        |

        *Overload 2:*
        This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i, b)) of all objects i assigned to &#39;b&#39; is equal to loads[b].
        &#34;&#34;&#34;
        return _pywrapcp.Pack_AddWeightedSumEqualVarDimension(self, *args)

    def AddSumVariableWeightsLessOrEqualConstantDimension(self, usage: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, capacity: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This dimension imposes: forall b in bins,    sum (i in items: usage[i] * is_assigned(i, b)) &lt;= capacity[b] where is_assigned(i, b) is true if and only if item i is assigned to the bin b. This can be used to model shapes of items by linking variables of the same item on parallel dimensions with an allowed assignment constraint.&#34;&#34;&#34;
        return _pywrapcp.Pack_AddSumVariableWeightsLessOrEqualConstantDimension(self, usage, capacity)

    def AddWeightedSumOfAssignedDimension(self, weights: &#34;std::vector&lt; int64 &gt; const &amp;&#34;, cost_var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This dimension enforces that cost_var == sum of weights[i] for all objects &#39;i&#39; assigned to a bin.&#34;&#34;&#34;
        return _pywrapcp.Pack_AddWeightedSumOfAssignedDimension(self, weights, cost_var)

    def AddCountUsedBinDimension(self, count_var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This dimension links &#39;count_var&#39; to the actual number of bins used in the pack.&#34;&#34;&#34;
        return _pywrapcp.Pack_AddCountUsedBinDimension(self, count_var)

    def AddCountAssignedItemsDimension(self, count_var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This dimension links &#39;count_var&#39; to the actual number of items assigned to a bin in the pack.&#34;&#34;&#34;
        return _pywrapcp.Pack_AddCountAssignedItemsDimension(self, count_var)

    def Post(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Pack_Post(self)

    def InitialPropagateWrapper(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Pack_InitialPropagateWrapper(self)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Pack_DebugString(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a></li>
<li><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.Pack.AddCountAssignedItemsDimension"><code class="name flex">
<span>def <span class="ident">AddCountAssignedItemsDimension</span></span>(<span>self, count_var: IntVar) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This dimension links 'count_var' to the actual number of items assigned to a bin in the pack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddCountAssignedItemsDimension(self, count_var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This dimension links &#39;count_var&#39; to the actual number of items assigned to a bin in the pack.&#34;&#34;&#34;
    return _pywrapcp.Pack_AddCountAssignedItemsDimension(self, count_var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Pack.AddCountUsedBinDimension"><code class="name flex">
<span>def <span class="ident">AddCountUsedBinDimension</span></span>(<span>self, count_var: IntVar) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This dimension links 'count_var' to the actual number of bins used in the pack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddCountUsedBinDimension(self, count_var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This dimension links &#39;count_var&#39; to the actual number of bins used in the pack.&#34;&#34;&#34;
    return _pywrapcp.Pack_AddCountUsedBinDimension(self, count_var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Pack.AddSumVariableWeightsLessOrEqualConstantDimension"><code class="name flex">
<span>def <span class="ident">AddSumVariableWeightsLessOrEqualConstantDimension</span></span>(<span>self, usage: std::vector< operations_research::IntVar * > const &, capacity: std::vector< int64 > const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This dimension imposes: forall b in bins,
sum (i in items: usage[i] * is_assigned(i, b)) &lt;= capacity[b] where is_assigned(i, b) is true if and only if item i is assigned to the bin b. This can be used to model shapes of items by linking variables of the same item on parallel dimensions with an allowed assignment constraint.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddSumVariableWeightsLessOrEqualConstantDimension(self, usage: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, capacity: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This dimension imposes: forall b in bins,    sum (i in items: usage[i] * is_assigned(i, b)) &lt;= capacity[b] where is_assigned(i, b) is true if and only if item i is assigned to the bin b. This can be used to model shapes of items by linking variables of the same item on parallel dimensions with an allowed assignment constraint.&#34;&#34;&#34;
    return _pywrapcp.Pack_AddSumVariableWeightsLessOrEqualConstantDimension(self, usage, capacity)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Pack.AddWeightedSumEqualVarDimension"><code class="name flex">
<span>def <span class="ident">AddWeightedSumEqualVarDimension</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
This dimension imposes that for all bins b, the weighted sum (weights[i]) of all objects i assigned to 'b' is equal to loads[b].</p>
<p>|</p>
<p><em>Overload 2:</em>
This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i, b)) of all objects i assigned to 'b' is equal to loads[b].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddWeightedSumEqualVarDimension(self, *args) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    This dimension imposes that for all bins b, the weighted sum (weights[i]) of all objects i assigned to &#39;b&#39; is equal to loads[b].

    |

    *Overload 2:*
    This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i, b)) of all objects i assigned to &#39;b&#39; is equal to loads[b].
    &#34;&#34;&#34;
    return _pywrapcp.Pack_AddWeightedSumEqualVarDimension(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Pack.AddWeightedSumLessOrEqualConstantDimension"><code class="name flex">
<span>def <span class="ident">AddWeightedSumLessOrEqualConstantDimension</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Dimensions are additional constraints than can restrict what is possible with the pack constraint. It can be used to set capacity limits, to count objects per bin, to compute unassigned penalties&hellip; This dimension imposes that for all bins b, the weighted sum (weights[i]) of all objects i assigned to 'b' is less or equal 'bounds[b]'.</p>
<p>|</p>
<p><em>Overload 2:</em>
This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i)) of all objects i assigned to 'b' is less or equal to 'bounds[b]'. Ownership of the callback is transferred to the pack constraint.</p>
<p>|</p>
<p><em>Overload 3:</em>
This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i, b) of all objects i assigned to 'b' is less or equal to 'bounds[b]'. Ownership of the callback is transferred to the pack constraint.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddWeightedSumLessOrEqualConstantDimension(self, *args) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Dimensions are additional constraints than can restrict what is possible with the pack constraint. It can be used to set capacity limits, to count objects per bin, to compute unassigned penalties... This dimension imposes that for all bins b, the weighted sum (weights[i]) of all objects i assigned to &#39;b&#39; is less or equal &#39;bounds[b]&#39;.

    |

    *Overload 2:*
    This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i)) of all objects i assigned to &#39;b&#39; is less or equal to &#39;bounds[b]&#39;. Ownership of the callback is transferred to the pack constraint.

    |

    *Overload 3:*
    This dimension imposes that for all bins b, the weighted sum (weights-&gt;Run(i, b) of all objects i assigned to &#39;b&#39; is less or equal to &#39;bounds[b]&#39;. Ownership of the callback is transferred to the pack constraint.
    &#34;&#34;&#34;
    return _pywrapcp.Pack_AddWeightedSumLessOrEqualConstantDimension(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Pack.AddWeightedSumOfAssignedDimension"><code class="name flex">
<span>def <span class="ident">AddWeightedSumOfAssignedDimension</span></span>(<span>self, weights: std::vector< int64 > const &, cost_var: IntVar) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This dimension enforces that cost_var == sum of weights[i] for all objects 'i' assigned to a bin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddWeightedSumOfAssignedDimension(self, weights: &#34;std::vector&lt; int64 &gt; const &amp;&#34;, cost_var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This dimension enforces that cost_var == sum of weights[i] for all objects &#39;i&#39; assigned to a bin.&#34;&#34;&#34;
    return _pywrapcp.Pack_AddWeightedSumOfAssignedDimension(self, weights, cost_var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Pack.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.Pack_DebugString(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.Constraint.InitialPropagateWrapper" href="#pywrapcp.Constraint.InitialPropagateWrapper">InitialPropagateWrapper</a></code></li>
<li><code><a title="pywrapcp.Constraint.Name" href="#pywrapcp.PropagationBaseObject.Name">Name</a></code></li>
<li><code><a title="pywrapcp.Constraint.Post" href="#pywrapcp.Constraint.Post">Post</a></code></li>
<li><code><a title="pywrapcp.Constraint.Var" href="#pywrapcp.Constraint.Var">Var</a></code></li>
<li><code><a title="pywrapcp.Constraint.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.PathOperator"><code class="flex name class">
<span>class <span class="ident">PathOperator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class of the local search operators dedicated to path modifications (a path is a set of nodes linked together by arcs). This family of neighborhoods supposes they are handling next variables representing the arcs (var[i] represents the node immediately after i on a path). Several services are provided: - arc manipulators (SetNext(), ReverseChain(), MoveChain()) - path inspectors (Next(), Prev(), IsPathEnd()) - path iterators: operators need a given number of nodes to define a
neighbor; this class provides the iteration on a given number of (base)
nodes which can be used to define a neighbor (through the BaseNode method) Subclasses only need to override MakeNeighbor to create neighbors using the services above (no direct manipulation of assignments).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PathOperator(IntVarLocalSearchOperator):
    r&#34;&#34;&#34; Base class of the local search operators dedicated to path modifications (a path is a set of nodes linked together by arcs). This family of neighborhoods supposes they are handling next variables representing the arcs (var[i] represents the node immediately after i on a path). Several services are provided: - arc manipulators (SetNext(), ReverseChain(), MoveChain()) - path inspectors (Next(), Prev(), IsPathEnd()) - path iterators: operators need a given number of nodes to define a   neighbor; this class provides the iteration on a given number of (base)   nodes which can be used to define a neighbor (through the BaseNode method) Subclasses only need to override MakeNeighbor to create neighbors using the services above (no direct manipulation of assignments).&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def Neighbor(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.PathOperator_Neighbor(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.IntVarLocalSearchOperator" href="#pywrapcp.IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></li>
<li><a title="pywrapcp.IntVarLocalSearchOperatorTemplate" href="#pywrapcp.IntVarLocalSearchOperatorTemplate">IntVarLocalSearchOperatorTemplate</a></li>
<li><a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.PathOperator.Neighbor"><code class="name flex">
<span>def <span class="ident">Neighbor</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Neighbor(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.PathOperator_Neighbor(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.IntVarLocalSearchOperator" href="#pywrapcp.IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.NextNeighbor" href="#pywrapcp.IntVarLocalSearchOperator.NextNeighbor">NextNeighbor</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.OnStart" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.OnStart">OnStart</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.OneNeighbor" href="#pywrapcp.IntVarLocalSearchOperator.OneNeighbor">OneNeighbor</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.Start" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.Start">Start</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.Value" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.Value">Value</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.PropagationBaseObject"><code class="flex name class">
<span>class <span class="ident">PropagationBaseObject</span></span>
<span>(</span><span>s: Solver)</span>
</code></dt>
<dd>
<div class="desc"><p>NOLINT The PropagationBaseObject is a subclass of BaseObject that is also friend to the Solver class. It allows accessing methods useful when writing new constraints or new expressions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PropagationBaseObject(BaseObject):
    r&#34;&#34;&#34; NOLINT The PropagationBaseObject is a subclass of BaseObject that is also friend to the Solver class. It allows accessing methods useful when writing new constraints or new expressions.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, s: &#34;Solver&#34;):
        if self.__class__ == PropagationBaseObject:
            _self = None
        else:
            _self = self
        _pywrapcp.PropagationBaseObject_swiginit(self, _pywrapcp.new_PropagationBaseObject(_self, s))
    __swig_destroy__ = _pywrapcp.delete_PropagationBaseObject

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.PropagationBaseObject_DebugString(self)

    def solver(self) -&gt; &#34;operations_research::Solver *&#34;:
        return _pywrapcp.PropagationBaseObject_solver(self)

    def Name(self) -&gt; &#34;std::string&#34;:
        r&#34;&#34;&#34; Object naming.&#34;&#34;&#34;
        return _pywrapcp.PropagationBaseObject_Name(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_PropagationBaseObject(self)
        return weakref.proxy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a></li>
<li><a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a></li>
<li><a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a></li>
<li><a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a></li>
<li><a title="pywrapcp.SequenceVar" href="#pywrapcp.SequenceVar">SequenceVar</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.PropagationBaseObject.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.PropagationBaseObject_DebugString(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.PropagationBaseObject.Name"><code class="name flex">
<span>def <span class="ident">Name</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"><p>Object naming.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Name(self) -&gt; &#34;std::string&#34;:
    r&#34;&#34;&#34; Object naming.&#34;&#34;&#34;
    return _pywrapcp.PropagationBaseObject_Name(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.PropagationBaseObject.solver"><code class="name flex">
<span>def <span class="ident">solver</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Solver" href="#pywrapcp.Solver">Solver</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solver(self) -&gt; &#34;operations_research::Solver *&#34;:
    return _pywrapcp.PropagationBaseObject_solver(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.BaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.PyConstraint"><code class="flex name class">
<span>class <span class="ident">PyConstraint</span></span>
<span>(</span><span>solver)</span>
</code></dt>
<dd>
<div class="desc"><p>A constraint is the main modeling object. It provides two methods:
- Post() is responsible for creating the demons and attaching them to
immediate demons().
- InitialPropagate() is called once just after Post and performs
the initial propagation. The subsequent propagations will be performed
by the demons Posted during the post() method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PyConstraint(Constraint):

  def __init__(self, solver):
    Constraint.__init__(self, solver)
    self.__demons = []

  def Demon(self, method, *args):
    demon = PyConstraintDemon(self, method, False, *args)
    self.__demons.append(demon)
    return demon

  def DelayedDemon(self, method, *args):
    demon = PyConstraintDemon(self, method, True, *args)
    self.__demons.append(demon)
    return demon

  def InitialPropagateDemon(self):
    return self.solver().ConstraintInitialPropagateCallback(self)

  def DelayedInitialPropagateDemon(self):
    return self.solver().DelayedConstraintInitialPropagateCallback(self)

  def InitialPropagateWrapper(self):
    try:
      self.InitialPropagate()
    except Exception as e:
      if &#39;CP Solver fail&#39; in str(e):
        self.solver().ShouldFail()
      else:
        raise

  def DebugString(self):
    return &#34;PyConstraint&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a></li>
<li><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.PyConstraint.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self):
  return &#34;PyConstraint&#34;</code></pre>
</details>
</dd>
<dt id="pywrapcp.PyConstraint.DelayedDemon"><code class="name flex">
<span>def <span class="ident">DelayedDemon</span></span>(<span>self, method, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DelayedDemon(self, method, *args):
  demon = PyConstraintDemon(self, method, True, *args)
  self.__demons.append(demon)
  return demon</code></pre>
</details>
</dd>
<dt id="pywrapcp.PyConstraint.DelayedInitialPropagateDemon"><code class="name flex">
<span>def <span class="ident">DelayedInitialPropagateDemon</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DelayedInitialPropagateDemon(self):
  return self.solver().DelayedConstraintInitialPropagateCallback(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.PyConstraint.Demon"><code class="name flex">
<span>def <span class="ident">Demon</span></span>(<span>self, method, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Demon(self, method, *args):
  demon = PyConstraintDemon(self, method, False, *args)
  self.__demons.append(demon)
  return demon</code></pre>
</details>
</dd>
<dt id="pywrapcp.PyConstraint.InitialPropagateDemon"><code class="name flex">
<span>def <span class="ident">InitialPropagateDemon</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def InitialPropagateDemon(self):
  return self.solver().ConstraintInitialPropagateCallback(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.Constraint.InitialPropagateWrapper" href="#pywrapcp.Constraint.InitialPropagateWrapper">InitialPropagateWrapper</a></code></li>
<li><code><a title="pywrapcp.Constraint.Name" href="#pywrapcp.PropagationBaseObject.Name">Name</a></code></li>
<li><code><a title="pywrapcp.Constraint.Post" href="#pywrapcp.Constraint.Post">Post</a></code></li>
<li><code><a title="pywrapcp.Constraint.Var" href="#pywrapcp.Constraint.Var">Var</a></code></li>
<li><code><a title="pywrapcp.Constraint.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.PyConstraintDemon"><code class="flex name class">
<span>class <span class="ident">PyConstraintDemon</span></span>
<span>(</span><span>ct, method, delayed, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>A Demon is the base element of a propagation queue. It is the main
object responsible for implementing the actual propagation
of the constraint and pruning the inconsistent values in the domains
of the variables. The main concept is that demons are listeners that are
attached to the variables and listen to their modifications. There are two methods:
- Run() is the actual method called when the demon is processed.
- priority() returns its priority. Standard priorities are slow, normal
or fast. "immediate" is reserved for variables and is treated separately.</p>
<p>This indicates the priority of a demon. Immediate demons are treated separately and corresponds to variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PyConstraintDemon(PyDemon):

  def __init__(self, ct, method, delayed, *args):
    PyDemon.__init__(self)
    self.__constraint = ct
    self.__method = method
    self.__delayed = delayed
    self.__args = args

  def Run(self, solver):
    self.__method(self.__constraint, *self.__args)

  def Priority(self):
    return Solver.DELAYED_PRIORITY if self.__delayed else Solver.NORMAL_PRIORITY

  def DebugString(self):
    return &#39;PyConstraintDemon&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.PyDemon" href="#pywrapcp.PyDemon">PyDemon</a></li>
<li><a title="pywrapcp.Demon" href="#pywrapcp.Demon">Demon</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.PyConstraintDemon.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self):
  return &#39;PyConstraintDemon&#39;</code></pre>
</details>
</dd>
<dt id="pywrapcp.PyConstraintDemon.Run"><code class="name flex">
<span>def <span class="ident">Run</span></span>(<span>self, solver)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Run(self, solver):
  self.__method(self.__constraint, *self.__args)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.PyDemon" href="#pywrapcp.PyDemon">PyDemon</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.PyDemon.Desinhibit" href="#pywrapcp.Demon.Desinhibit">Desinhibit</a></code></li>
<li><code><a title="pywrapcp.PyDemon.Inhibit" href="#pywrapcp.Demon.Inhibit">Inhibit</a></code></li>
<li><code><a title="pywrapcp.PyDemon.Priority" href="#pywrapcp.Demon.Priority">Priority</a></code></li>
<li><code><a title="pywrapcp.PyDemon.RunWrapper" href="#pywrapcp.Demon.RunWrapper">RunWrapper</a></code></li>
<li><code><a title="pywrapcp.PyDemon.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.PyDecision"><code class="flex name class">
<span>class <span class="ident">PyDecision</span></span>
</code></dt>
<dd>
<div class="desc"><p>A Decision represents a choice point in the search tree. The two main methods are Apply() to go left, or Refute() to go right.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PyDecision(Decision):

  def __init__(self):
    Decision.__init__(self)

  def ApplyWrapper(self, solver):
    try:
       self.Apply(solver)
    except Exception as e:
      if &#39;CP Solver fail&#39; in str(e):
        solver.ShouldFail()
      else:
        raise

  def RefuteWrapper(self, solver):
    try:
       self.Refute(solver)
    except Exception as e:
      if &#39;CP Solver fail&#39; in str(e):
        solver.ShouldFail()
      else:
        raise

  def DebugString(self):
    return &#34;PyDecision&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.PyDecision.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self):
  return &#34;PyDecision&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.Decision.ApplyWrapper" href="#pywrapcp.Decision.ApplyWrapper">ApplyWrapper</a></code></li>
<li><code><a title="pywrapcp.Decision.RefuteWrapper" href="#pywrapcp.Decision.RefuteWrapper">RefuteWrapper</a></code></li>
<li><code><a title="pywrapcp.Decision.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.PyDecisionBuilder"><code class="flex name class">
<span>class <span class="ident">PyDecisionBuilder</span></span>
</code></dt>
<dd>
<div class="desc"><p>A DecisionBuilder is responsible for creating the search tree. The important method is Next(), which returns the next decision to execute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PyDecisionBuilder(DecisionBuilder):

  def __init__(self):
    DecisionBuilder.__init__(self)

  def NextWrapper(self, solver):
    try:
      return self.Next(solver)
    except Exception as e:
      if &#39;CP Solver fail&#39; in str(e):
        return solver.FailDecision()
      else:
        raise

  def DebugString(self):
    return &#34;PyDecisionBuilder&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.PyDecisionBuilder.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self):
  return &#34;PyDecisionBuilder&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.DecisionBuilder.NextWrapper" href="#pywrapcp.DecisionBuilder.NextWrapper">NextWrapper</a></code></li>
<li><code><a title="pywrapcp.DecisionBuilder.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.PyDemon"><code class="flex name class">
<span>class <span class="ident">PyDemon</span></span>
</code></dt>
<dd>
<div class="desc"><p>A Demon is the base element of a propagation queue. It is the main
object responsible for implementing the actual propagation
of the constraint and pruning the inconsistent values in the domains
of the variables. The main concept is that demons are listeners that are
attached to the variables and listen to their modifications. There are two methods:
- Run() is the actual method called when the demon is processed.
- priority() returns its priority. Standard priorities are slow, normal
or fast. "immediate" is reserved for variables and is treated separately.</p>
<p>This indicates the priority of a demon. Immediate demons are treated separately and corresponds to variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PyDemon(Demon):

  def RunWrapper(self, solver):
    try:
      self.Run(solver)
    except Exception as e:
      if &#39;CP Solver fail&#39; in str(e):
        solver.ShouldFail()
      else:
        raise

  def DebugString(self):
    return &#34;PyDemon&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.Demon" href="#pywrapcp.Demon">Demon</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.PyConstraintDemon" href="#pywrapcp.PyConstraintDemon">PyConstraintDemon</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.PyDemon.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self):
  return &#34;PyDemon&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.Demon" href="#pywrapcp.Demon">Demon</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.Demon.Desinhibit" href="#pywrapcp.Demon.Desinhibit">Desinhibit</a></code></li>
<li><code><a title="pywrapcp.Demon.Inhibit" href="#pywrapcp.Demon.Inhibit">Inhibit</a></code></li>
<li><code><a title="pywrapcp.Demon.Priority" href="#pywrapcp.Demon.Priority">Priority</a></code></li>
<li><code><a title="pywrapcp.Demon.RunWrapper" href="#pywrapcp.Demon.RunWrapper">RunWrapper</a></code></li>
<li><code><a title="pywrapcp.Demon.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.RevBool"><code class="flex name class">
<span>class <span class="ident">RevBool</span></span>
<span>(</span><span>val: bool const &)</span>
</code></dt>
<dd>
<div class="desc"><p>This class adds reversibility to a POD type. It contains the stamp optimization. i.e. the SaveValue call is done only once per node of the search tree.
Please note that actual stamps always starts at 1, thus an initial value of 0 will always trigger the first SaveValue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RevBool(object):
    r&#34;&#34;&#34; This class adds reversibility to a POD type. It contains the stamp optimization. i.e. the SaveValue call is done only once per node of the search tree.  Please note that actual stamps always starts at 1, thus an initial value of 0 will always trigger the first SaveValue.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, val: &#34;bool const &amp;&#34;):
        _pywrapcp.RevBool_swiginit(self, _pywrapcp.new_RevBool(val))

    def Value(self) -&gt; &#34;bool const &amp;&#34;:
        return _pywrapcp.RevBool_Value(self)

    def SetValue(self, s: &#34;Solver&#34;, val: &#34;bool const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RevBool_SetValue(self, s, val)
    __swig_destroy__ = _pywrapcp.delete_RevBool</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapcp.RevBool.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<div class="desc"><p>The membership flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.RevBool.SetValue"><code class="name flex">
<span>def <span class="ident">SetValue</span></span>(<span>self, s: Solver, val: bool const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetValue(self, s: &#34;Solver&#34;, val: &#34;bool const &amp;&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.RevBool_SetValue(self, s, val)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RevBool.Value"><code class="name flex">
<span>def <span class="ident">Value</span></span>(<span>self) -> 'bool const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Value(self) -&gt; &#34;bool const &amp;&#34;:
    return _pywrapcp.RevBool_Value(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywrapcp.RevInteger"><code class="flex name class">
<span>class <span class="ident">RevInteger</span></span>
<span>(</span><span>val: long const &)</span>
</code></dt>
<dd>
<div class="desc"><p>This class adds reversibility to a POD type. It contains the stamp optimization. i.e. the SaveValue call is done only once per node of the search tree.
Please note that actual stamps always starts at 1, thus an initial value of 0 will always trigger the first SaveValue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RevInteger(object):
    r&#34;&#34;&#34; This class adds reversibility to a POD type. It contains the stamp optimization. i.e. the SaveValue call is done only once per node of the search tree.  Please note that actual stamps always starts at 1, thus an initial value of 0 will always trigger the first SaveValue.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, val: &#34;long const &amp;&#34;):
        _pywrapcp.RevInteger_swiginit(self, _pywrapcp.new_RevInteger(val))

    def Value(self) -&gt; &#34;long const &amp;&#34;:
        return _pywrapcp.RevInteger_Value(self)

    def SetValue(self, s: &#34;Solver&#34;, val: &#34;long const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RevInteger_SetValue(self, s, val)
    __swig_destroy__ = _pywrapcp.delete_RevInteger</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.NumericalRevInteger" href="#pywrapcp.NumericalRevInteger">NumericalRevInteger</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapcp.RevInteger.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<div class="desc"><p>The membership flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.RevInteger.SetValue"><code class="name flex">
<span>def <span class="ident">SetValue</span></span>(<span>self, s: Solver, val: long const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetValue(self, s: &#34;Solver&#34;, val: &#34;long const &amp;&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.RevInteger_SetValue(self, s, val)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RevInteger.Value"><code class="name flex">
<span>def <span class="ident">Value</span></span>(<span>self) -> 'long const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Value(self) -&gt; &#34;long const &amp;&#34;:
    return _pywrapcp.RevInteger_Value(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywrapcp.RoutingDimension"><code class="flex name class">
<span>class <span class="ident">RoutingDimension</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Dimensions represent quantities accumulated at nodes along the routes. They represent quantities such as weights or volumes carried along the route, or distance or times. Quantities at a node are represented by "cumul" variables and the increase or decrease of quantities between nodes are represented by "transit" variables. These variables are linked as follows: if j == next(i), cumuls(j) = cumuls(i) + transits(i) + slacks(i) +
state_dependent_transits(i) where slack is a positive slack variable (can represent waiting times for a time dimension), and state_dependent_transits is a non-purely functional version of transits_. Favour transits over state_dependent_transits when possible, because purely functional callbacks allow more optimisations and make the model faster and easier to solve. for a given vehicle, it is passed as an external vector, it would be better to have this information here.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoutingDimension(object):
    r&#34;&#34;&#34; Dimensions represent quantities accumulated at nodes along the routes. They represent quantities such as weights or volumes carried along the route, or distance or times. Quantities at a node are represented by &#34;cumul&#34; variables and the increase or decrease of quantities between nodes are represented by &#34;transit&#34; variables. These variables are linked as follows: if j == next(i), cumuls(j) = cumuls(i) + transits(i) + slacks(i) +             state_dependent_transits(i) where slack is a positive slack variable (can represent waiting times for a time dimension), and state_dependent_transits is a non-purely functional version of transits_. Favour transits over state_dependent_transits when possible, because purely functional callbacks allow more optimisations and make the model faster and easier to solve. for a given vehicle, it is passed as an external vector, it would be better to have this information here.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_RoutingDimension

    def model(self) -&gt; &#34;operations_research::RoutingModel *&#34;:
        r&#34;&#34;&#34; Returns the model on which the dimension was created.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_model(self)

    def GetTransitValue(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;, vehicle: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the transition value for a given pair of nodes (as var index); this value is the one taken by the corresponding transit variable when the &#39;next&#39; variable for &#39;from_index&#39; is bound to &#39;to_index&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_GetTransitValue(self, from_index, to_index, vehicle)

    def GetTransitValueFromClass(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;, vehicle_class: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Same as above but taking a vehicle class of the dimension instead of a vehicle (the class of a vehicle can be obtained with vehicle_to_class()).&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_GetTransitValueFromClass(self, from_index, to_index, vehicle_class)

    def CumulVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Get the cumul, transit and slack variables for the given node (given as int64 var index).&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_CumulVar(self, index)

    def TransitVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.RoutingDimension_TransitVar(self, index)

    def FixedTransitVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.RoutingDimension_FixedTransitVar(self, index)

    def SlackVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.RoutingDimension_SlackVar(self, index)

    def SetSpanUpperBoundForVehicle(self, upper_bound: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets an upper bound on the dimension span on a given vehicle. This is the preferred way to limit the &#34;length&#34; of the route of a vehicle according to a dimension.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetSpanUpperBoundForVehicle(self, upper_bound, vehicle)

    def SetSpanCostCoefficientForVehicle(self, coefficient: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets a cost proportional to the dimension span on a given vehicle, or on all vehicles at once. &#34;coefficient&#34; must be nonnegative. This is handy to model costs proportional to idle time when the dimension represents time. The cost for a vehicle is   span_cost = coefficient * (dimension end value - dimension start value).&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetSpanCostCoefficientForVehicle(self, coefficient, vehicle)

    def SetSpanCostCoefficientForAllVehicles(self, coefficient: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingDimension_SetSpanCostCoefficientForAllVehicles(self, coefficient)

    def SetGlobalSpanCostCoefficient(self, coefficient: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets a cost proportional to the *global* dimension span, that is the difference between the largest value of route end cumul variables and the smallest value of route start cumul variables. In other words: global_span_cost =   coefficient * (Max(dimension end value) - Min(dimension start value)).&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetGlobalSpanCostCoefficient(self, coefficient)

    def SetCumulVarSoftUpperBound(self, index: &#34;int64&#34;, upper_bound: &#34;int64&#34;, coefficient: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets a soft upper bound to the cumul variable of a given variable index. If the value of the cumul variable is greater than the bound, a cost proportional to the difference between this value and the bound is added to the cost function of the model:   cumulVar &lt;= upper_bound -&gt; cost = 0    cumulVar &gt; upper_bound -&gt; cost = coefficient * (cumulVar - upper_bound) This is also handy to model tardiness costs when the dimension represents time.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetCumulVarSoftUpperBound(self, index, upper_bound, coefficient)

    def HasCumulVarSoftUpperBound(self, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if a soft upper bound has been set for a given variable index.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_HasCumulVarSoftUpperBound(self, index)

    def GetCumulVarSoftUpperBound(self, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the soft upper bound of a cumul variable for a given variable index. The &#34;hard&#34; upper bound of the variable is returned if no soft upper bound has been set.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_GetCumulVarSoftUpperBound(self, index)

    def GetCumulVarSoftUpperBoundCoefficient(self, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the cost coefficient of the soft upper bound of a cumul variable for a given variable index. If no soft upper bound has been set, 0 is returned.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_GetCumulVarSoftUpperBoundCoefficient(self, index)

    def SetCumulVarSoftLowerBound(self, index: &#34;int64&#34;, lower_bound: &#34;int64&#34;, coefficient: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets a soft lower bound to the cumul variable of a given variable index. If the value of the cumul variable is less than the bound, a cost proportional to the difference between this value and the bound is added to the cost function of the model:   cumulVar &gt; lower_bound -&gt; cost = 0   cumulVar &lt;= lower_bound -&gt; cost = coefficient * (lower_bound -               cumulVar). This is also handy to model earliness costs when the dimension represents time. Note: Using soft lower and upper bounds or span costs together is, as of 6/2014, not well supported in the sense that an optimal schedule is not guaranteed.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetCumulVarSoftLowerBound(self, index, lower_bound, coefficient)

    def HasCumulVarSoftLowerBound(self, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if a soft lower bound has been set for a given variable index.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_HasCumulVarSoftLowerBound(self, index)

    def GetCumulVarSoftLowerBound(self, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the soft lower bound of a cumul variable for a given variable index. The &#34;hard&#34; lower bound of the variable is returned if no soft lower bound has been set.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_GetCumulVarSoftLowerBound(self, index)

    def GetCumulVarSoftLowerBoundCoefficient(self, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the cost coefficient of the soft lower bound of a cumul variable for a given variable index. If no soft lower bound has been set, 0 is returned.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_GetCumulVarSoftLowerBoundCoefficient(self, index)

    def SetBreakIntervalsOfVehicle(self, breaks: &#34;std::vector&lt; operations_research::IntervalVar * &gt;&#34;, vehicle: &#34;int&#34;, node_visit_transits: &#34;std::vector&lt; int64 &gt;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the breaks for a given vehicle. Breaks are represented by IntervalVars. They may interrupt transits between nodes and increase the value of corresponding slack variables. A break may take place before the start of a vehicle, after the end of a vehicle, or during a travel i -&gt; j. In that case, the interval [break.Start(), break.End()) must be a subset of [CumulVar(i) + pre_travel(i, j), CumulVar(j) - post_travel(i, j)). In other words, a break may not overlap any node n&#39;s visit, given by [CumulVar(n) - post_travel(_, n), CumulVar(n) + pre_travel(n, _)). This formula considers post_travel(_, start) and pre_travel(end, _) to be 0; pre_travel will never be called on any (_, start) and post_travel will never we called on any (end, _). If pre_travel_evaluator or post_travel_evaluator is -1, it will be taken as a function that always returns 0. Deprecated, sets pre_travel(i, j) = node_visit_transit[i].&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetBreakIntervalsOfVehicle(self, breaks, vehicle, node_visit_transits)

    def SetBreakDistanceDurationOfVehicle(self, distance: &#34;int64&#34;, duration: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; With breaks supposed to be consecutive, this forces the distance between breaks of size at least minimum_break_duration to be at least distance. This supposes that the time until route start and after route end are infinite breaks.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_SetBreakDistanceDurationOfVehicle(self, distance, duration, vehicle)

    def InitializeBreaks(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets up vehicle_break_intervals_, vehicle_break_distance_duration_, pre_travel_evaluators and post_travel_evaluators.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_InitializeBreaks(self)

    def HasBreakConstraints(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if any break interval or break distance was defined.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_HasBreakConstraints(self)

    def GetPreTravelEvaluatorOfVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingDimension_GetPreTravelEvaluatorOfVehicle(self, vehicle)

    def GetPostTravelEvaluatorOfVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingDimension_GetPostTravelEvaluatorOfVehicle(self, vehicle)

    def base_dimension(self) -&gt; &#34;operations_research::RoutingDimension const *&#34;:
        r&#34;&#34;&#34; Returns the parent in the dependency tree if any or nullptr otherwise.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_base_dimension(self)

    def ShortestTransitionSlack(self, node: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; It makes sense to use the function only for self-dependent dimension. For such dimensions the value of the slack of a node determines the transition cost of the next transit. Provided that   1. cumul[node] is fixed,   2. next[node] and next[next[node]] (if exists) are fixed, the value of slack[node] for which cumul[next[node]] + transit[next[node]] is minimized can be found in O(1) using this function.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_ShortestTransitionSlack(self, node)

    def name(self) -&gt; &#34;std::string const &amp;&#34;:
        r&#34;&#34;&#34; Returns the name of the dimension.&#34;&#34;&#34;
        return _pywrapcp.RoutingDimension_name(self)

    def SetPickupToDeliveryLimitFunctionForPair(self, limit_function: &#34;operations_research::RoutingDimension::PickupToDeliveryLimitFunction&#34;, pair_index: &#34;int&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingDimension_SetPickupToDeliveryLimitFunctionForPair(self, limit_function, pair_index)

    def HasPickupToDeliveryLimits(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingDimension_HasPickupToDeliveryLimits(self)

    def AddNodePrecedence(self, first_node: &#34;int64&#34;, second_node: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingDimension_AddNodePrecedence(self, first_node, second_node, offset)

    def GetSpanUpperBoundForVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingDimension_GetSpanUpperBoundForVehicle(self, vehicle)

    def GetSpanCostCoefficientForVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingDimension_GetSpanCostCoefficientForVehicle(self, vehicle)

    def global_span_cost_coefficient(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingDimension_global_span_cost_coefficient(self)

    def GetGlobalOptimizerOffset(self) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingDimension_GetGlobalOptimizerOffset(self)

    def GetLocalOptimizerOffsetForVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingDimension_GetLocalOptimizerOffsetForVehicle(self, vehicle)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapcp.RoutingDimension.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<div class="desc"><p>The membership flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.RoutingDimension.AddNodePrecedence"><code class="name flex">
<span>def <span class="ident">AddNodePrecedence</span></span>(<span>self, first_node: int64, second_node: int64, offset: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddNodePrecedence(self, first_node: &#34;int64&#34;, second_node: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.RoutingDimension_AddNodePrecedence(self, first_node, second_node, offset)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.CumulVar"><code class="name flex">
<span>def <span class="ident">CumulVar</span></span>(<span>self, index: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Get the cumul, transit and slack variables for the given node (given as int64 var index).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CumulVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; Get the cumul, transit and slack variables for the given node (given as int64 var index).&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_CumulVar(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.FixedTransitVar"><code class="name flex">
<span>def <span class="ident">FixedTransitVar</span></span>(<span>self, index: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FixedTransitVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    return _pywrapcp.RoutingDimension_FixedTransitVar(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.GetCumulVarSoftLowerBound"><code class="name flex">
<span>def <span class="ident">GetCumulVarSoftLowerBound</span></span>(<span>self, index: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the soft lower bound of a cumul variable for a given variable index. The "hard" lower bound of the variable is returned if no soft lower bound has been set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetCumulVarSoftLowerBound(self, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the soft lower bound of a cumul variable for a given variable index. The &#34;hard&#34; lower bound of the variable is returned if no soft lower bound has been set.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_GetCumulVarSoftLowerBound(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.GetCumulVarSoftLowerBoundCoefficient"><code class="name flex">
<span>def <span class="ident">GetCumulVarSoftLowerBoundCoefficient</span></span>(<span>self, index: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the cost coefficient of the soft lower bound of a cumul variable for a given variable index. If no soft lower bound has been set, 0 is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetCumulVarSoftLowerBoundCoefficient(self, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the cost coefficient of the soft lower bound of a cumul variable for a given variable index. If no soft lower bound has been set, 0 is returned.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_GetCumulVarSoftLowerBoundCoefficient(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.GetCumulVarSoftUpperBound"><code class="name flex">
<span>def <span class="ident">GetCumulVarSoftUpperBound</span></span>(<span>self, index: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the soft upper bound of a cumul variable for a given variable index. The "hard" upper bound of the variable is returned if no soft upper bound has been set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetCumulVarSoftUpperBound(self, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the soft upper bound of a cumul variable for a given variable index. The &#34;hard&#34; upper bound of the variable is returned if no soft upper bound has been set.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_GetCumulVarSoftUpperBound(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.GetCumulVarSoftUpperBoundCoefficient"><code class="name flex">
<span>def <span class="ident">GetCumulVarSoftUpperBoundCoefficient</span></span>(<span>self, index: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the cost coefficient of the soft upper bound of a cumul variable for a given variable index. If no soft upper bound has been set, 0 is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetCumulVarSoftUpperBoundCoefficient(self, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the cost coefficient of the soft upper bound of a cumul variable for a given variable index. If no soft upper bound has been set, 0 is returned.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_GetCumulVarSoftUpperBoundCoefficient(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.GetGlobalOptimizerOffset"><code class="name flex">
<span>def <span class="ident">GetGlobalOptimizerOffset</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetGlobalOptimizerOffset(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.RoutingDimension_GetGlobalOptimizerOffset(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.GetLocalOptimizerOffsetForVehicle"><code class="name flex">
<span>def <span class="ident">GetLocalOptimizerOffsetForVehicle</span></span>(<span>self, vehicle: int) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetLocalOptimizerOffsetForVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.RoutingDimension_GetLocalOptimizerOffsetForVehicle(self, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.GetPostTravelEvaluatorOfVehicle"><code class="name flex">
<span>def <span class="ident">GetPostTravelEvaluatorOfVehicle</span></span>(<span>self, vehicle: int) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetPostTravelEvaluatorOfVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int&#34;:
    return _pywrapcp.RoutingDimension_GetPostTravelEvaluatorOfVehicle(self, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.GetPreTravelEvaluatorOfVehicle"><code class="name flex">
<span>def <span class="ident">GetPreTravelEvaluatorOfVehicle</span></span>(<span>self, vehicle: int) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetPreTravelEvaluatorOfVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int&#34;:
    return _pywrapcp.RoutingDimension_GetPreTravelEvaluatorOfVehicle(self, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.GetSpanCostCoefficientForVehicle"><code class="name flex">
<span>def <span class="ident">GetSpanCostCoefficientForVehicle</span></span>(<span>self, vehicle: int) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetSpanCostCoefficientForVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.RoutingDimension_GetSpanCostCoefficientForVehicle(self, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.GetSpanUpperBoundForVehicle"><code class="name flex">
<span>def <span class="ident">GetSpanUpperBoundForVehicle</span></span>(<span>self, vehicle: int) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetSpanUpperBoundForVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.RoutingDimension_GetSpanUpperBoundForVehicle(self, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.GetTransitValue"><code class="name flex">
<span>def <span class="ident">GetTransitValue</span></span>(<span>self, from_index: int64, to_index: int64, vehicle: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the transition value for a given pair of nodes (as var index); this value is the one taken by the corresponding transit variable when the 'next' variable for 'from_index' is bound to 'to_index'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetTransitValue(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;, vehicle: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the transition value for a given pair of nodes (as var index); this value is the one taken by the corresponding transit variable when the &#39;next&#39; variable for &#39;from_index&#39; is bound to &#39;to_index&#39;.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_GetTransitValue(self, from_index, to_index, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.GetTransitValueFromClass"><code class="name flex">
<span>def <span class="ident">GetTransitValueFromClass</span></span>(<span>self, from_index: int64, to_index: int64, vehicle_class: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Same as above but taking a vehicle class of the dimension instead of a vehicle (the class of a vehicle can be obtained with vehicle_to_class()).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetTransitValueFromClass(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;, vehicle_class: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Same as above but taking a vehicle class of the dimension instead of a vehicle (the class of a vehicle can be obtained with vehicle_to_class()).&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_GetTransitValueFromClass(self, from_index, to_index, vehicle_class)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.HasBreakConstraints"><code class="name flex">
<span>def <span class="ident">HasBreakConstraints</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if any break interval or break distance was defined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HasBreakConstraints(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true if any break interval or break distance was defined.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_HasBreakConstraints(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.HasCumulVarSoftLowerBound"><code class="name flex">
<span>def <span class="ident">HasCumulVarSoftLowerBound</span></span>(<span>self, index: int64) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if a soft lower bound has been set for a given variable index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HasCumulVarSoftLowerBound(self, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true if a soft lower bound has been set for a given variable index.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_HasCumulVarSoftLowerBound(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.HasCumulVarSoftUpperBound"><code class="name flex">
<span>def <span class="ident">HasCumulVarSoftUpperBound</span></span>(<span>self, index: int64) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if a soft upper bound has been set for a given variable index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HasCumulVarSoftUpperBound(self, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true if a soft upper bound has been set for a given variable index.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_HasCumulVarSoftUpperBound(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.HasPickupToDeliveryLimits"><code class="name flex">
<span>def <span class="ident">HasPickupToDeliveryLimits</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HasPickupToDeliveryLimits(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.RoutingDimension_HasPickupToDeliveryLimits(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.InitializeBreaks"><code class="name flex">
<span>def <span class="ident">InitializeBreaks</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up vehicle_break_intervals_, vehicle_break_distance_duration_, pre_travel_evaluators and post_travel_evaluators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def InitializeBreaks(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets up vehicle_break_intervals_, vehicle_break_distance_duration_, pre_travel_evaluators and post_travel_evaluators.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_InitializeBreaks(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.SetBreakDistanceDurationOfVehicle"><code class="name flex">
<span>def <span class="ident">SetBreakDistanceDurationOfVehicle</span></span>(<span>self, distance: int64, duration: int64, vehicle: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>With breaks supposed to be consecutive, this forces the distance between breaks of size at least minimum_break_duration to be at least distance. This supposes that the time until route start and after route end are infinite breaks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetBreakDistanceDurationOfVehicle(self, distance: &#34;int64&#34;, duration: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; With breaks supposed to be consecutive, this forces the distance between breaks of size at least minimum_break_duration to be at least distance. This supposes that the time until route start and after route end are infinite breaks.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_SetBreakDistanceDurationOfVehicle(self, distance, duration, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.SetBreakIntervalsOfVehicle"><code class="name flex">
<span>def <span class="ident">SetBreakIntervalsOfVehicle</span></span>(<span>self, breaks: std::vector< operations_research::IntervalVar * >, vehicle: int, node_visit_transits: std::vector< int64 >) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the breaks for a given vehicle. Breaks are represented by IntervalVars. They may interrupt transits between nodes and increase the value of corresponding slack variables. A break may take place before the start of a vehicle, after the end of a vehicle, or during a travel i -&gt; j. In that case, the interval [break.Start(), break.End()) must be a subset of [CumulVar(i) + pre_travel(i, j), CumulVar(j) - post_travel(i, j)). In other words, a break may not overlap any node n's visit, given by [CumulVar(n) - post_travel(<em>, n), CumulVar(n) + pre_travel(n, </em>)). This formula considers post_travel(<em>, start) and pre_travel(end, </em>) to be 0; pre_travel will never be called on any (<em>, start) and post_travel will never we called on any (end, </em>). If pre_travel_evaluator or post_travel_evaluator is -1, it will be taken as a function that always returns 0. Deprecated, sets pre_travel(i, j) = node_visit_transit[i].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetBreakIntervalsOfVehicle(self, breaks: &#34;std::vector&lt; operations_research::IntervalVar * &gt;&#34;, vehicle: &#34;int&#34;, node_visit_transits: &#34;std::vector&lt; int64 &gt;&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets the breaks for a given vehicle. Breaks are represented by IntervalVars. They may interrupt transits between nodes and increase the value of corresponding slack variables. A break may take place before the start of a vehicle, after the end of a vehicle, or during a travel i -&gt; j. In that case, the interval [break.Start(), break.End()) must be a subset of [CumulVar(i) + pre_travel(i, j), CumulVar(j) - post_travel(i, j)). In other words, a break may not overlap any node n&#39;s visit, given by [CumulVar(n) - post_travel(_, n), CumulVar(n) + pre_travel(n, _)). This formula considers post_travel(_, start) and pre_travel(end, _) to be 0; pre_travel will never be called on any (_, start) and post_travel will never we called on any (end, _). If pre_travel_evaluator or post_travel_evaluator is -1, it will be taken as a function that always returns 0. Deprecated, sets pre_travel(i, j) = node_visit_transit[i].&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_SetBreakIntervalsOfVehicle(self, breaks, vehicle, node_visit_transits)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.SetCumulVarSoftLowerBound"><code class="name flex">
<span>def <span class="ident">SetCumulVarSoftLowerBound</span></span>(<span>self, index: int64, lower_bound: int64, coefficient: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a soft lower bound to the cumul variable of a given variable index. If the value of the cumul variable is less than the bound, a cost proportional to the difference between this value and the bound is added to the cost function of the model:
cumulVar &gt; lower_bound -&gt; cost = 0
cumulVar &lt;= lower_bound -&gt; cost = coefficient * (lower_bound -
cumulVar). This is also handy to model earliness costs when the dimension represents time. Note: Using soft lower and upper bounds or span costs together is, as of 6/2014, not well supported in the sense that an optimal schedule is not guaranteed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetCumulVarSoftLowerBound(self, index: &#34;int64&#34;, lower_bound: &#34;int64&#34;, coefficient: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets a soft lower bound to the cumul variable of a given variable index. If the value of the cumul variable is less than the bound, a cost proportional to the difference between this value and the bound is added to the cost function of the model:   cumulVar &gt; lower_bound -&gt; cost = 0   cumulVar &lt;= lower_bound -&gt; cost = coefficient * (lower_bound -               cumulVar). This is also handy to model earliness costs when the dimension represents time. Note: Using soft lower and upper bounds or span costs together is, as of 6/2014, not well supported in the sense that an optimal schedule is not guaranteed.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_SetCumulVarSoftLowerBound(self, index, lower_bound, coefficient)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.SetCumulVarSoftUpperBound"><code class="name flex">
<span>def <span class="ident">SetCumulVarSoftUpperBound</span></span>(<span>self, index: int64, upper_bound: int64, coefficient: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a soft upper bound to the cumul variable of a given variable index. If the value of the cumul variable is greater than the bound, a cost proportional to the difference between this value and the bound is added to the cost function of the model:
cumulVar &lt;= upper_bound -&gt; cost = 0
cumulVar &gt; upper_bound -&gt; cost = coefficient * (cumulVar - upper_bound) This is also handy to model tardiness costs when the dimension represents time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetCumulVarSoftUpperBound(self, index: &#34;int64&#34;, upper_bound: &#34;int64&#34;, coefficient: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets a soft upper bound to the cumul variable of a given variable index. If the value of the cumul variable is greater than the bound, a cost proportional to the difference between this value and the bound is added to the cost function of the model:   cumulVar &lt;= upper_bound -&gt; cost = 0    cumulVar &gt; upper_bound -&gt; cost = coefficient * (cumulVar - upper_bound) This is also handy to model tardiness costs when the dimension represents time.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_SetCumulVarSoftUpperBound(self, index, upper_bound, coefficient)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.SetGlobalSpanCostCoefficient"><code class="name flex">
<span>def <span class="ident">SetGlobalSpanCostCoefficient</span></span>(<span>self, coefficient: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a cost proportional to the <em>global</em> dimension span, that is the difference between the largest value of route end cumul variables and the smallest value of route start cumul variables. In other words: global_span_cost =
coefficient * (Max(dimension end value) - Min(dimension start value)).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetGlobalSpanCostCoefficient(self, coefficient: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets a cost proportional to the *global* dimension span, that is the difference between the largest value of route end cumul variables and the smallest value of route start cumul variables. In other words: global_span_cost =   coefficient * (Max(dimension end value) - Min(dimension start value)).&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_SetGlobalSpanCostCoefficient(self, coefficient)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.SetPickupToDeliveryLimitFunctionForPair"><code class="name flex">
<span>def <span class="ident">SetPickupToDeliveryLimitFunctionForPair</span></span>(<span>self, limit_function: operations_research::RoutingDimension::PickupToDeliveryLimitFunction, pair_index: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetPickupToDeliveryLimitFunctionForPair(self, limit_function: &#34;operations_research::RoutingDimension::PickupToDeliveryLimitFunction&#34;, pair_index: &#34;int&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.RoutingDimension_SetPickupToDeliveryLimitFunctionForPair(self, limit_function, pair_index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.SetSpanCostCoefficientForAllVehicles"><code class="name flex">
<span>def <span class="ident">SetSpanCostCoefficientForAllVehicles</span></span>(<span>self, coefficient: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetSpanCostCoefficientForAllVehicles(self, coefficient: &#34;int64&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.RoutingDimension_SetSpanCostCoefficientForAllVehicles(self, coefficient)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.SetSpanCostCoefficientForVehicle"><code class="name flex">
<span>def <span class="ident">SetSpanCostCoefficientForVehicle</span></span>(<span>self, coefficient: int64, vehicle: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a cost proportional to the dimension span on a given vehicle, or on all vehicles at once. "coefficient" must be nonnegative. This is handy to model costs proportional to idle time when the dimension represents time. The cost for a vehicle is
span_cost = coefficient * (dimension end value - dimension start value).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetSpanCostCoefficientForVehicle(self, coefficient: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets a cost proportional to the dimension span on a given vehicle, or on all vehicles at once. &#34;coefficient&#34; must be nonnegative. This is handy to model costs proportional to idle time when the dimension represents time. The cost for a vehicle is   span_cost = coefficient * (dimension end value - dimension start value).&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_SetSpanCostCoefficientForVehicle(self, coefficient, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.SetSpanUpperBoundForVehicle"><code class="name flex">
<span>def <span class="ident">SetSpanUpperBoundForVehicle</span></span>(<span>self, upper_bound: int64, vehicle: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets an upper bound on the dimension span on a given vehicle. This is the preferred way to limit the "length" of the route of a vehicle according to a dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetSpanUpperBoundForVehicle(self, upper_bound: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets an upper bound on the dimension span on a given vehicle. This is the preferred way to limit the &#34;length&#34; of the route of a vehicle according to a dimension.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_SetSpanUpperBoundForVehicle(self, upper_bound, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.ShortestTransitionSlack"><code class="name flex">
<span>def <span class="ident">ShortestTransitionSlack</span></span>(<span>self, node: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>It makes sense to use the function only for self-dependent dimension. For such dimensions the value of the slack of a node determines the transition cost of the next transit. Provided that
1. cumul[node] is fixed,
2. next[node] and next[next[node]] (if exists) are fixed, the value of slack[node] for which cumul[next[node]] + transit[next[node]] is minimized can be found in O(1) using this function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ShortestTransitionSlack(self, node: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; It makes sense to use the function only for self-dependent dimension. For such dimensions the value of the slack of a node determines the transition cost of the next transit. Provided that   1. cumul[node] is fixed,   2. next[node] and next[next[node]] (if exists) are fixed, the value of slack[node] for which cumul[next[node]] + transit[next[node]] is minimized can be found in O(1) using this function.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_ShortestTransitionSlack(self, node)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.SlackVar"><code class="name flex">
<span>def <span class="ident">SlackVar</span></span>(<span>self, index: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SlackVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    return _pywrapcp.RoutingDimension_SlackVar(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.TransitVar"><code class="name flex">
<span>def <span class="ident">TransitVar</span></span>(<span>self, index: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TransitVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    return _pywrapcp.RoutingDimension_TransitVar(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.base_dimension"><code class="name flex">
<span>def <span class="ident">base_dimension</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.RoutingDimension" href="#pywrapcp.RoutingDimension">RoutingDimension</a> const *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the parent in the dependency tree if any or nullptr otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_dimension(self) -&gt; &#34;operations_research::RoutingDimension const *&#34;:
    r&#34;&#34;&#34; Returns the parent in the dependency tree if any or nullptr otherwise.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_base_dimension(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.global_span_cost_coefficient"><code class="name flex">
<span>def <span class="ident">global_span_cost_coefficient</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def global_span_cost_coefficient(self) -&gt; &#34;int64&#34;:
    return _pywrapcp.RoutingDimension_global_span_cost_coefficient(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.model"><code class="name flex">
<span>def <span class="ident">model</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.RoutingModel" href="#pywrapcp.RoutingModel">RoutingModel</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the model on which the dimension was created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model(self) -&gt; &#34;operations_research::RoutingModel *&#34;:
    r&#34;&#34;&#34; Returns the model on which the dimension was created.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_model(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingDimension.name"><code class="name flex">
<span>def <span class="ident">name</span></span>(<span>self) -> 'std::string const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def name(self) -&gt; &#34;std::string const &amp;&#34;:
    r&#34;&#34;&#34; Returns the name of the dimension.&#34;&#34;&#34;
    return _pywrapcp.RoutingDimension_name(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywrapcp.RoutingIndexManager"><code class="flex name class">
<span>class <span class="ident">RoutingIndexManager</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Manager for any NodeIndex &lt;-&gt; variable index conversion. The routing solver uses variable indices internally and through its API. These variable indices are tricky to manage directly because one Node can correspond to a multitude of variables, depending on the number of times they appear in the model, and if they're used as start and/or end points. This class aims to simplify variable index usage, allowing users to use NodeIndex instead. Usage:
.cpp}
auto starts_ends = &hellip;;
/// These are NodeIndex.
RoutingIndexManager manager(10, 4, starts_ends);
// 10 nodes, 4 vehicles.
RoutingModel model(manager);</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoutingIndexManager(object):
    r&#34;&#34;&#34; Manager for any NodeIndex &lt;-&gt; variable index conversion. The routing solver uses variable indices internally and through its API. These variable indices are tricky to manage directly because one Node can correspond to a multitude of variables, depending on the number of times they appear in the model, and if they&#39;re used as start and/or end points. This class aims to simplify variable index usage, allowing users to use NodeIndex instead. Usage:   .cpp}   auto starts_ends = ...;  /// These are NodeIndex.   RoutingIndexManager manager(10, 4, starts_ends);  // 10 nodes, 4 vehicles.   RoutingModel model(manager);&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pywrapcp.RoutingIndexManager_swiginit(self, _pywrapcp.new_RoutingIndexManager(*args))
    __swig_destroy__ = _pywrapcp.delete_RoutingIndexManager

    def GetNumberOfNodes(self) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingIndexManager_GetNumberOfNodes(self)

    def GetNumberOfVehicles(self) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingIndexManager_GetNumberOfVehicles(self)

    def GetNumberOfIndices(self) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingIndexManager_GetNumberOfIndices(self)

    def NodeToIndex(self, node: &#34;operations_research::RoutingIndexManager::NodeIndex&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingIndexManager_NodeToIndex(self, node)

    def IndexToNode(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::RoutingIndexManager::NodeIndex&#34;:
        return _pywrapcp.RoutingIndexManager_IndexToNode(self, index)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapcp.RoutingIndexManager.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<div class="desc"><p>The membership flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.RoutingIndexManager.GetNumberOfIndices"><code class="name flex">
<span>def <span class="ident">GetNumberOfIndices</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetNumberOfIndices(self) -&gt; &#34;int&#34;:
    return _pywrapcp.RoutingIndexManager_GetNumberOfIndices(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingIndexManager.GetNumberOfNodes"><code class="name flex">
<span>def <span class="ident">GetNumberOfNodes</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetNumberOfNodes(self) -&gt; &#34;int&#34;:
    return _pywrapcp.RoutingIndexManager_GetNumberOfNodes(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingIndexManager.GetNumberOfVehicles"><code class="name flex">
<span>def <span class="ident">GetNumberOfVehicles</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetNumberOfVehicles(self) -&gt; &#34;int&#34;:
    return _pywrapcp.RoutingIndexManager_GetNumberOfVehicles(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingIndexManager.IndexToNode"><code class="name flex">
<span>def <span class="ident">IndexToNode</span></span>(<span>self, index: int64) -> 'operations_research::<a title="pywrapcp.RoutingIndexManager" href="#pywrapcp.RoutingIndexManager">RoutingIndexManager</a>::NodeIndex'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IndexToNode(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::RoutingIndexManager::NodeIndex&#34;:
    return _pywrapcp.RoutingIndexManager_IndexToNode(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingIndexManager.NodeToIndex"><code class="name flex">
<span>def <span class="ident">NodeToIndex</span></span>(<span>self, node: operations_research::RoutingIndexManager::NodeIndex) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NodeToIndex(self, node: &#34;operations_research::RoutingIndexManager::NodeIndex&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.RoutingIndexManager_NodeToIndex(self, node)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywrapcp.RoutingModel"><code class="flex name class">
<span>class <span class="ident">RoutingModel</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoutingModel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr
    ROUTING_NOT_SOLVED = _pywrapcp.RoutingModel_ROUTING_NOT_SOLVED
    r&#34;&#34;&#34; Problem not solved yet (before calling RoutingModel::Solve()).&#34;&#34;&#34;
    ROUTING_SUCCESS = _pywrapcp.RoutingModel_ROUTING_SUCCESS
    r&#34;&#34;&#34; Problem solved successfully after calling RoutingModel::Solve().&#34;&#34;&#34;
    ROUTING_FAIL = _pywrapcp.RoutingModel_ROUTING_FAIL
    r&#34;&#34;&#34; No solution found to the problem after calling RoutingModel::Solve().&#34;&#34;&#34;
    ROUTING_FAIL_TIMEOUT = _pywrapcp.RoutingModel_ROUTING_FAIL_TIMEOUT
    r&#34;&#34;&#34; Time limit reached before finding a solution with RoutingModel::Solve().&#34;&#34;&#34;
    ROUTING_INVALID = _pywrapcp.RoutingModel_ROUTING_INVALID
    r&#34;&#34;&#34; Model, model parameters or flags are not valid.&#34;&#34;&#34;
    PICKUP_AND_DELIVERY_NO_ORDER = _pywrapcp.RoutingModel_PICKUP_AND_DELIVERY_NO_ORDER
    r&#34;&#34;&#34; Any precedence is accepted.&#34;&#34;&#34;
    PICKUP_AND_DELIVERY_LIFO = _pywrapcp.RoutingModel_PICKUP_AND_DELIVERY_LIFO
    r&#34;&#34;&#34; Deliveries must be performed in reverse order of pickups.&#34;&#34;&#34;
    PICKUP_AND_DELIVERY_FIFO = _pywrapcp.RoutingModel_PICKUP_AND_DELIVERY_FIFO
    r&#34;&#34;&#34; Deliveries must be performed in the same order as pickups.&#34;&#34;&#34;

    def __init__(self, *args):
        _pywrapcp.RoutingModel_swiginit(self, _pywrapcp.new_RoutingModel(*args))
    __swig_destroy__ = _pywrapcp.delete_RoutingModel

    def RegisterUnaryTransitCallback(self, callback: &#34;operations_research::RoutingModel::TransitCallback1&#34;) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Registers &#39;callback&#39; and returns its index.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_RegisterUnaryTransitCallback(self, callback)

    def RegisterPositiveUnaryTransitCallback(self, callback: &#34;operations_research::RoutingModel::TransitCallback1&#34;) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingModel_RegisterPositiveUnaryTransitCallback(self, callback)

    def RegisterTransitCallback(self, callback: &#34;operations_research::RoutingModel::TransitCallback2&#34;) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingModel_RegisterTransitCallback(self, callback)

    def RegisterPositiveTransitCallback(self, callback: &#34;operations_research::RoutingModel::TransitCallback2&#34;) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingModel_RegisterPositiveTransitCallback(self, callback)

    def TransitCallback(self, callback_index: &#34;int&#34;) -&gt; &#34;operations_research::RoutingModel::TransitCallback2 const &amp;&#34;:
        return _pywrapcp.RoutingModel_TransitCallback(self, callback_index)

    def UnaryTransitCallbackOrNull(self, callback_index: &#34;int&#34;) -&gt; &#34;operations_research::RoutingModel::TransitCallback1 const &amp;&#34;:
        return _pywrapcp.RoutingModel_UnaryTransitCallbackOrNull(self, callback_index)

    def AddDimension(self, evaluator_index: &#34;int&#34;, slack_max: &#34;int64&#34;, capacity: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Model creation Methods to add dimensions to routes; dimensions represent quantities accumulated at nodes along the routes. They represent quantities such as weights or volumes carried along the route, or distance or times. Quantities at a node are represented by &#34;cumul&#34; variables and the increase or decrease of quantities between nodes are represented by &#34;transit&#34; variables. These variables are linked as follows: if j == next(i), cumul(j) = cumul(i) + transit(i) + slack(i) where slack is a positive slack variable (can represent waiting times for a time dimension). Setting the value of fix_start_cumul_to_zero to true will force the &#34;cumul&#34; variable of the start node of all vehicles to be equal to 0. Creates a dimension where the transit variable is constrained to be equal to evaluator(i, next(i)); &#39;slack_max&#39; is the upper bound of the slack variable and &#39;capacity&#39; is the upper bound of the cumul variables. &#39;name&#39; is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn&#39;t create the new dimension). Takes ownership of the callback &#39;evaluator&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddDimension(self, evaluator_index, slack_max, capacity, fix_start_cumul_to_zero, name)

    def AddDimensionWithVehicleTransits(self, evaluator_indices: &#34;std::vector&lt; int &gt; const &amp;&#34;, slack_max: &#34;int64&#34;, capacity: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_AddDimensionWithVehicleTransits(self, evaluator_indices, slack_max, capacity, fix_start_cumul_to_zero, name)

    def AddDimensionWithVehicleCapacity(self, evaluator_index: &#34;int&#34;, slack_max: &#34;int64&#34;, vehicle_capacities: &#34;std::vector&lt; int64 &gt;&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_AddDimensionWithVehicleCapacity(self, evaluator_index, slack_max, vehicle_capacities, fix_start_cumul_to_zero, name)

    def AddDimensionWithVehicleTransitAndCapacity(self, evaluator_indices: &#34;std::vector&lt; int &gt; const &amp;&#34;, slack_max: &#34;int64&#34;, vehicle_capacities: &#34;std::vector&lt; int64 &gt;&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_AddDimensionWithVehicleTransitAndCapacity(self, evaluator_indices, slack_max, vehicle_capacities, fix_start_cumul_to_zero, name)

    def AddConstantDimensionWithSlack(self, value: &#34;int64&#34;, capacity: &#34;int64&#34;, slack_max: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Creates a dimension where the transit variable is constrained to be equal to &#39;value&#39;; &#39;capacity&#39; is the upper bound of the cumul variables. &#39;name&#39; is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn&#39;t create the new dimension).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddConstantDimensionWithSlack(self, value, capacity, slack_max, fix_start_cumul_to_zero, name)

    def AddConstantDimension(self, value: &#34;int64&#34;, capacity: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_AddConstantDimension(self, value, capacity, fix_start_cumul_to_zero, name)

    def AddVectorDimension(self, values: &#34;std::vector&lt; int64 &gt;&#34;, capacity: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Creates a dimension where the transit variable is constrained to be equal to &#39;values[i]&#39; for node i; &#39;capacity&#39; is the upper bound of the cumul variables. &#39;name&#39; is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn&#39;t create the new dimension).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddVectorDimension(self, values, capacity, fix_start_cumul_to_zero, name)

    def MakePathSpansAndTotalSlacks(self, dimension: &#34;RoutingDimension&#34;, spans: &#34;std::vector&lt; operations_research::IntVar * &gt;&#34;, total_slacks: &#34;std::vector&lt; operations_research::IntVar * &gt;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; For every vehicle of the routing model: - if total_slacks[vehicle] is not nullptr, constrains it to be the sum of   slacks on that vehicle, that is,   dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start) -   sum_{node in path of vehicle} dimension-&gt;FixedTransitVar(node). - if spans[vehicle] is not nullptr, constrains it to be   dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start) This does stronger propagation than a decomposition, and takes breaks into account.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_MakePathSpansAndTotalSlacks(self, dimension, spans, total_slacks)

    def GetAllDimensionNames(self) -&gt; &#34;std::vector&lt; std::string &gt;&#34;:
        r&#34;&#34;&#34; Outputs the names of all dimensions added to the routing engine.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetAllDimensionNames(self)

    def GetDimensions(self) -&gt; &#34;std::vector&lt; operations_research::RoutingDimension * &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns all dimensions of the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDimensions(self)

    def GetDimensionsWithSoftOrSpanCosts(self) -&gt; &#34;std::vector&lt; operations_research::RoutingDimension * &gt;&#34;:
        r&#34;&#34;&#34; Returns dimensions with soft or vehicle span costs.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDimensionsWithSoftOrSpanCosts(self)

    def GetGlobalDimensionCumulOptimizers(self) -&gt; &#34;std::vector&lt; std::unique_ptr&lt; operations_research::GlobalDimensionCumulOptimizer &gt; &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns [global|local]_dimension_optimizers_, which are empty if the model has not been closed.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetGlobalDimensionCumulOptimizers(self)

    def GetLocalDimensionCumulOptimizers(self) -&gt; &#34;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&#34;:
        return _pywrapcp.RoutingModel_GetLocalDimensionCumulOptimizers(self)

    def GetLocalDimensionCumulMPOptimizers(self) -&gt; &#34;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&#34;:
        return _pywrapcp.RoutingModel_GetLocalDimensionCumulMPOptimizers(self)

    def GetMutableGlobalCumulOptimizer(self, dimension: &#34;RoutingDimension&#34;) -&gt; &#34;operations_research::GlobalDimensionCumulOptimizer *&#34;:
        r&#34;&#34;&#34; Returns the global/local dimension cumul optimizer for a given dimension, or nullptr if there is none.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetMutableGlobalCumulOptimizer(self, dimension)

    def GetMutableLocalCumulOptimizer(self, dimension: &#34;RoutingDimension&#34;) -&gt; &#34;operations_research::LocalDimensionCumulOptimizer *&#34;:
        return _pywrapcp.RoutingModel_GetMutableLocalCumulOptimizer(self, dimension)

    def GetMutableLocalCumulMPOptimizer(self, dimension: &#34;RoutingDimension&#34;) -&gt; &#34;operations_research::LocalDimensionCumulOptimizer *&#34;:
        return _pywrapcp.RoutingModel_GetMutableLocalCumulMPOptimizer(self, dimension)

    def HasDimension(self, dimension_name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if a dimension exists for a given dimension name.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_HasDimension(self, dimension_name)

    def GetDimensionOrDie(self, dimension_name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::RoutingDimension const &amp;&#34;:
        r&#34;&#34;&#34; Returns a dimension from its name. Dies if the dimension does not exist.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDimensionOrDie(self, dimension_name)

    def GetMutableDimension(self, dimension_name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::RoutingDimension *&#34;:
        r&#34;&#34;&#34; Returns a dimension from its name. Returns nullptr if the dimension does not exist.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetMutableDimension(self, dimension_name)

    def SetPrimaryConstrainedDimension(self, dimension_name: &#34;std::string const &amp;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Set the given dimension as &#34;primary constrained&#34;. As of August 2013, this is only used by ArcIsMoreConstrainedThanArc(). &#34;dimension&#34; must be the name of an existing dimension, or be empty, in which case there will not be a primary dimension after this call.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetPrimaryConstrainedDimension(self, dimension_name)

    def GetPrimaryConstrainedDimension(self) -&gt; &#34;std::string const &amp;&#34;:
        r&#34;&#34;&#34; Get the primary constrained dimension, or an empty string if it is unset.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetPrimaryConstrainedDimension(self)

    def AddDisjunction(self, *args) -&gt; &#34;operations_research::RoutingModel::DisjunctionIndex&#34;:
        r&#34;&#34;&#34; Adds a disjunction constraint on the indices: exactly &#39;max_cardinality&#39; of the indices are active. Start and end indices of any vehicle cannot be part of a disjunction. If a penalty is given, at most &#39;max_cardinality&#39; of the indices can be active, and if less are active, &#39;penalty&#39; is payed per inactive index. This is equivalent to adding the constraint:     p + Sum(i)active[i] == max_cardinality where p is an integer variable, and the following cost to the cost function:     p * penalty. &#39;penalty&#39; must be positive to make the disjunction optional; a negative penalty will force &#39;max_cardinality&#39; indices of the disjunction to be performed, and therefore p == 0. Note: passing a vector with a single index will model an optional index with a penalty cost if it is not visited.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddDisjunction(self, *args)

    def GetDisjunctionIndices(self, index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; operations_research::RoutingModel::DisjunctionIndex &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns the indices of the disjunctions to which an index belongs.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDisjunctionIndices(self, index)

    def GetDisjunctionPenalty(self, index: &#34;operations_research::RoutingModel::DisjunctionIndex&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the penalty of the node disjunction of index &#39;index&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDisjunctionPenalty(self, index)

    def GetDisjunctionMaxCardinality(self, index: &#34;operations_research::RoutingModel::DisjunctionIndex&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the maximum number of possible active nodes of the node disjunction of index &#39;index&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDisjunctionMaxCardinality(self, index)

    def GetNumberOfDisjunctions(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns the number of node disjunctions in the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetNumberOfDisjunctions(self)

    def GetPerfectBinaryDisjunctions(self) -&gt; &#34;std::vector&lt; std::pair&lt; int64,int64 &gt; &gt;&#34;:
        r&#34;&#34;&#34; Returns the list of all perfect binary disjunctions, as pairs of variable indices: a disjunction is &#34;perfect&#34; when its variables do not appear in any other disjunction. Each pair is sorted (lowest variable index first), and the output vector is also sorted (lowest pairs first).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetPerfectBinaryDisjunctions(self)

    def IgnoreDisjunctionsAlreadyForcedToZero(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; SPECIAL: Makes the solver ignore all the disjunctions whose active variables are all trivially zero (i.e. Max() == 0), by setting their max_cardinality to 0. This can be useful when using the BaseBinaryDisjunctionNeighborhood operators, in the context of arc-based routing.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_IgnoreDisjunctionsAlreadyForcedToZero(self)

    def AddSoftSameVehicleConstraint(self, indices: &#34;std::vector&lt; int64 &gt; const &amp;&#34;, cost: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a soft contraint to force a set of variable indices to be on the same vehicle. If all nodes are not on the same vehicle, each extra vehicle used adds &#39;cost&#39; to the cost function.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddSoftSameVehicleConstraint(self, indices, cost)

    def SetAllowedVehiclesForIndex(self, vehicles: &#34;std::vector&lt; int &gt; const &amp;&#34;, index: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the vehicles which can visit a given node. If the node is in a disjunction, this will not prevent it from being unperformed. Specifying an empty vector of vehicles has no effect (all vehicles will be allowed to visit the node).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetAllowedVehiclesForIndex(self, vehicles, index)

    def IsVehicleAllowedForIndex(self, vehicle: &#34;int&#34;, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if a vehicle is allowed to visit a given node.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_IsVehicleAllowedForIndex(self, vehicle, index)

    def AddPickupAndDelivery(self, pickup: &#34;int64&#34;, delivery: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Notifies that index1 and index2 form a pair of nodes which should belong to the same route. This methods helps the search find better solutions, especially in the local search phase. It should be called each time you have an equality constraint linking the vehicle variables of two node (including for instance pickup and delivery problems):     Solver* const solver = routing.solver();     int64 index1 = manager.NodeToIndex(node1);     int64 index2 = manager.NodeToIndex(node2);     solver-&gt;AddConstraint(solver-&gt;MakeEquality(         routing.VehicleVar(index1),         routing.VehicleVar(index2)));     routing.AddPickupAndDelivery(index1, index2);&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddPickupAndDelivery(self, pickup, delivery)

    def AddPickupAndDeliverySets(self, pickup_disjunction: &#34;operations_research::RoutingModel::DisjunctionIndex&#34;, delivery_disjunction: &#34;operations_research::RoutingModel::DisjunctionIndex&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Same as AddPickupAndDelivery but notifying that the performed node from the disjunction of index &#39;pickup_disjunction&#39; is on the same route as the performed node from the disjunction of index &#39;delivery_disjunction&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddPickupAndDeliverySets(self, pickup_disjunction, delivery_disjunction)

    def GetPickupIndexPairs(self, node_index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns pairs for which the node is a pickup; the first element of each pair is the index in the pickup and delivery pairs list in which the pickup appears, the second element is its index in the pickups list.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetPickupIndexPairs(self, node_index)

    def GetDeliveryIndexPairs(self, node_index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Same as above for deliveries.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDeliveryIndexPairs(self, node_index)

    def SetPickupAndDeliveryPolicyOfAllVehicles(self, policy: &#34;operations_research::RoutingModel::PickupAndDeliveryPolicy&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the Pickup and delivery policy of all vehicles. It is equivalent to calling SetPickupAndDeliveryPolicyOfVehicle on all vehicles.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetPickupAndDeliveryPolicyOfAllVehicles(self, policy)

    def SetPickupAndDeliveryPolicyOfVehicle(self, policy: &#34;operations_research::RoutingModel::PickupAndDeliveryPolicy&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingModel_SetPickupAndDeliveryPolicyOfVehicle(self, policy, vehicle)

    def GetPickupAndDeliveryPolicyOfVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;operations_research::RoutingModel::PickupAndDeliveryPolicy&#34;:
        return _pywrapcp.RoutingModel_GetPickupAndDeliveryPolicyOfVehicle(self, vehicle)

    def GetNumOfSingletonNodes(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns the number of non-start/end nodes which do not appear in a pickup/delivery pair.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetNumOfSingletonNodes(self)
    TYPE_ADDED_TO_VEHICLE = _pywrapcp.RoutingModel_TYPE_ADDED_TO_VEHICLE
    r&#34;&#34;&#34; When visited, the number of types &#39;T&#39; on the vehicle increases by one.&#34;&#34;&#34;
    ADDED_TYPE_REMOVED_FROM_VEHICLE = _pywrapcp.RoutingModel_ADDED_TYPE_REMOVED_FROM_VEHICLE
    r&#34;&#34;&#34; When visited, one instance of type &#39;T&#39; previously added to the route (TYPE_ADDED_TO_VEHICLE), if any, is removed from the vehicle. If the type was not previously added to the route or all added instances have already been removed, this visit has no effect on the types.&#34;&#34;&#34;
    TYPE_ON_VEHICLE_UP_TO_VISIT = _pywrapcp.RoutingModel_TYPE_ON_VEHICLE_UP_TO_VISIT
    r&#34;&#34;&#34; With the following policy, the visit enforces that type &#39;T&#39; is considered on the route from its start until this node is visited.&#34;&#34;&#34;
    TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED = _pywrapcp.RoutingModel_TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED
    r&#34;&#34;&#34; The visit doesn&#39;t have an impact on the number of types &#39;T&#39; on the route, as it&#39;s (virtually) added and removed directly. This policy can be used for visits which are part of an incompatibility or requirement set without affecting the type count on the route.&#34;&#34;&#34;

    def SetVisitType(self, index: &#34;int64&#34;, type: &#34;int&#34;, type_policy: &#34;operations_research::RoutingModel::VisitTypePolicy&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingModel_SetVisitType(self, index, type, type_policy)

    def GetVisitType(self, index: &#34;int64&#34;) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingModel_GetVisitType(self, index)

    def GetVisitTypePolicy(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::RoutingModel::VisitTypePolicy&#34;:
        return _pywrapcp.RoutingModel_GetVisitTypePolicy(self, index)

    def CloseVisitTypes(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This function should be called once all node visit types have been set and prior to adding any incompatibilities/requirements. &#34;close&#34; types.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CloseVisitTypes(self)

    def GetNumberOfVisitTypes(self) -&gt; &#34;int&#34;:
        return _pywrapcp.RoutingModel_GetNumberOfVisitTypes(self)

    def AddHardTypeIncompatibility(self, type1: &#34;int&#34;, type2: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Incompatibilities: Two nodes with &#34;hard&#34; incompatible types cannot share the same route at all, while with a &#34;temporal&#34; incompatibility they can&#39;t be on the same route at the same time.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddHardTypeIncompatibility(self, type1, type2)

    def AddTemporalTypeIncompatibility(self, type1: &#34;int&#34;, type2: &#34;int&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingModel_AddTemporalTypeIncompatibility(self, type1, type2)

    def GetHardTypeIncompatibilitiesOfType(self, type: &#34;int&#34;) -&gt; &#34;absl::flat_hash_set&lt; int &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns visit types incompatible with a given type.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetHardTypeIncompatibilitiesOfType(self, type)

    def GetTemporalTypeIncompatibilitiesOfType(self, type: &#34;int&#34;) -&gt; &#34;absl::flat_hash_set&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.RoutingModel_GetTemporalTypeIncompatibilitiesOfType(self, type)

    def HasHardTypeIncompatibilities(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true iff any hard (resp. temporal) type incompatibilities have been added to the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_HasHardTypeIncompatibilities(self)

    def HasTemporalTypeIncompatibilities(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_HasTemporalTypeIncompatibilities(self)

    def AddSameVehicleRequiredTypeAlternatives(self, dependent_type: &#34;int&#34;, required_type_alternatives: &#34;absl::flat_hash_set&lt; int &gt;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Requirements: NOTE: As of 2019-04, cycles in the requirement graph are not supported, and lead to the dependent nodes being skipped if possible (otherwise the model is considered infeasible). The following functions specify that &#34;dependent_type&#34; requires at least one of the types in &#34;required_type_alternatives&#34;. For same-vehicle requirements, a node of dependent type type_D requires at least one node of type type_R among the required alternatives on the same route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddSameVehicleRequiredTypeAlternatives(self, dependent_type, required_type_alternatives)

    def AddRequiredTypeAlternativesWhenAddingType(self, dependent_type: &#34;int&#34;, required_type_alternatives: &#34;absl::flat_hash_set&lt; int &gt;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; If type_D depends on type_R when adding type_D, any node_D of type_D and VisitTypePolicy TYPE_ADDED_TO_VEHICLE or TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED requires at least one type_R on its vehicle at the time node_D is visited.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddRequiredTypeAlternativesWhenAddingType(self, dependent_type, required_type_alternatives)

    def AddRequiredTypeAlternativesWhenRemovingType(self, dependent_type: &#34;int&#34;, required_type_alternatives: &#34;absl::flat_hash_set&lt; int &gt;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; The following requirements apply when visiting dependent nodes that remove their type from the route, i.e. type_R must be on the vehicle when type_D of VisitTypePolicy ADDED_TYPE_REMOVED_FROM_VEHICLE, TYPE_ON_VEHICLE_UP_TO_VISIT or TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED is visited.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddRequiredTypeAlternativesWhenRemovingType(self, dependent_type, required_type_alternatives)

    def GetSameVehicleRequiredTypeAlternativesOfType(self, type: &#34;int&#34;) -&gt; &#34;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns the set of same-vehicle requirement alternatives for the given type.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetSameVehicleRequiredTypeAlternativesOfType(self, type)

    def GetRequiredTypeAlternativesWhenAddingType(self, type: &#34;int&#34;) -&gt; &#34;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns the set of requirement alternatives when adding the given type.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetRequiredTypeAlternativesWhenAddingType(self, type)

    def GetRequiredTypeAlternativesWhenRemovingType(self, type: &#34;int&#34;) -&gt; &#34;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns the set of requirement alternatives when removing the given type.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetRequiredTypeAlternativesWhenRemovingType(self, type)

    def HasSameVehicleTypeRequirements(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true iff any same-route (resp. temporal) type requirements have been added to the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_HasSameVehicleTypeRequirements(self)

    def HasTemporalTypeRequirements(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_HasTemporalTypeRequirements(self)

    def HasTypeRegulations(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true iff the model has any incompatibilities or requirements set on node types.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_HasTypeRegulations(self)

    def UnperformedPenalty(self, var_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Get the &#34;unperformed&#34; penalty of a node. This is only well defined if the node is only part of a single Disjunction involving only itself, and that disjunction has a penalty. In all other cases, including forced active nodes, this returns 0.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_UnperformedPenalty(self, var_index)

    def UnperformedPenaltyOrValue(self, default_value: &#34;int64&#34;, var_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Same as above except that it returns default_value instead of 0 when penalty is not well defined (default value is passed as first argument to simplify the usage of the method in a callback).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_UnperformedPenaltyOrValue(self, default_value, var_index)

    def GetDepot(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the variable index of the first starting or ending node of all routes. If all routes start  and end at the same node (single depot), this is the node returned.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetDepot(self)

    def SetArcCostEvaluatorOfAllVehicles(self, evaluator_index: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the cost function of the model such that the cost of a segment of a route between node &#39;from&#39; and &#39;to&#39; is evaluator(from, to), whatever the route or vehicle performing the route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetArcCostEvaluatorOfAllVehicles(self, evaluator_index)

    def SetArcCostEvaluatorOfVehicle(self, evaluator_index: &#34;int&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the cost function for a given vehicle route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetArcCostEvaluatorOfVehicle(self, evaluator_index, vehicle)

    def SetFixedCostOfAllVehicles(self, cost: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the fixed cost of all vehicle routes. It is equivalent to calling SetFixedCostOfVehicle on all vehicle routes.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetFixedCostOfAllVehicles(self, cost)

    def SetFixedCostOfVehicle(self, cost: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the fixed cost of one vehicle route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetFixedCostOfVehicle(self, cost, vehicle)

    def GetFixedCostOfVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the route fixed cost taken into account if the route of the vehicle is not empty, aka there&#39;s at least one node on the route other than the first and last nodes.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetFixedCostOfVehicle(self, vehicle)

    def SetAmortizedCostFactorsOfAllVehicles(self, linear_cost_factor: &#34;int64&#34;, quadratic_cost_factor: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; The following methods set the linear and quadratic cost factors of vehicles (must be positive values). The default value of these parameters is zero for all vehicles. When set, the cost_ of the model will contain terms aiming at reducing the number of vehicles used in the model, by adding the following to the objective for every vehicle v: INDICATOR(v used in the model) *   [linear_cost_factor_of_vehicle_[v]    - quadratic_cost_factor_of_vehicle_[v]*(square of length of route v)] i.e. for every used vehicle, we add the linear factor as fixed cost, and subtract the square of the route length multiplied by the quadratic factor. This second term aims at making the routes as dense as possible. Sets the linear and quadratic cost factor of all vehicles.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetAmortizedCostFactorsOfAllVehicles(self, linear_cost_factor, quadratic_cost_factor)

    def SetAmortizedCostFactorsOfVehicle(self, linear_cost_factor: &#34;int64&#34;, quadratic_cost_factor: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Sets the linear and quadratic cost factor of the given vehicle.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetAmortizedCostFactorsOfVehicle(self, linear_cost_factor, quadratic_cost_factor, vehicle)

    def GetAmortizedLinearCostFactorOfVehicles(self) -&gt; &#34;std::vector&lt; int64 &gt; const &amp;&#34;:
        return _pywrapcp.RoutingModel_GetAmortizedLinearCostFactorOfVehicles(self)

    def GetAmortizedQuadraticCostFactorOfVehicles(self) -&gt; &#34;std::vector&lt; int64 &gt; const &amp;&#34;:
        return _pywrapcp.RoutingModel_GetAmortizedQuadraticCostFactorOfVehicles(self)

    def ConsiderEmptyRouteCostsForVehicle(self, consider_costs: &#34;bool&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingModel_ConsiderEmptyRouteCostsForVehicle(self, consider_costs, vehicle)

    def AreEmptyRouteCostsConsideredForVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.RoutingModel_AreEmptyRouteCostsConsideredForVehicle(self, vehicle)

    def SetFirstSolutionEvaluator(self, evaluator: &#34;operations_research::Solver::IndexEvaluator2&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Gets/sets the evaluator used during the search. Only relevant when RoutingSearchParameters.first_solution_strategy = EVALUATOR_STRATEGY. Takes ownership of evaluator.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetFirstSolutionEvaluator(self, evaluator)

    def AddLocalSearchOperator(self, ls_operator: &#34;LocalSearchOperator&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a local search operator to the set of operators used to solve the vehicle routing problem.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddLocalSearchOperator(self, ls_operator)

    def AddSearchMonitor(self, monitor: &#34;SearchMonitor&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a search monitor to the search used to solve the routing model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddSearchMonitor(self, monitor)

    def AddAtSolutionCallback(self, callback: &#34;std::function&lt; void () &gt;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a callback called each time a solution is found during the search. This is a shortcut to creating a monitor to call the callback on AtSolution() and adding it with AddSearchMonitor.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddAtSolutionCallback(self, callback)

    def AddVariableMinimizedByFinalizer(self, var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a variable to minimize in the solution finalizer. The solution finalizer is called each time a solution is found during the search and allows to instantiate secondary variables (such as dimension cumul variables).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddVariableMinimizedByFinalizer(self, var)

    def AddVariableMaximizedByFinalizer(self, var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a variable to maximize in the solution finalizer (see above for information on the solution finalizer).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddVariableMaximizedByFinalizer(self, var)

    def AddWeightedVariableMinimizedByFinalizer(self, var: &#34;IntVar&#34;, cost: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a variable to minimize in the solution finalizer, with a weighted priority: the higher the more priority it has.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddWeightedVariableMinimizedByFinalizer(self, var, cost)

    def AddVariableTargetToFinalizer(self, var: &#34;IntVar&#34;, target: &#34;int64&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Add a variable to set the closest possible to the target value in the solution finalizer.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddVariableTargetToFinalizer(self, var, target)

    def CloseModel(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Closes the current routing model; after this method is called, no modification to the model can be done, but RoutesToAssignment becomes available. Note that CloseModel() is automatically called by Solve() and other methods that produce solution. This is equivalent to calling CloseModelWithParameters(DefaultRoutingSearchParameters()).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CloseModel(self)

    def CloseModelWithParameters(self, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Same as above taking search parameters (as of 10/2015 some the parameters have to be set when closing the model).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CloseModelWithParameters(self, search_parameters)

    def Solve(self, assignment: &#34;Assignment&#34;=None) -&gt; &#34;operations_research::Assignment const *&#34;:
        r&#34;&#34;&#34; Solves the current routing model; closes the current model. This is equivalent to calling SolveWithParameters(DefaultRoutingSearchParameters()) or SolveFromAssignmentWithParameters(assignment,                                   DefaultRoutingSearchParameters()).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_Solve(self, assignment)

    def SolveWithParameters(self, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;, solutions: &#34;std::vector&lt; operations_research::Assignment const * &gt; *&#34;=None) -&gt; &#34;operations_research::Assignment const *&#34;:
        r&#34;&#34;&#34; Solves the current routing model with the given parameters. If &#39;solutions&#39; is specified, it will contain the k best solutions found during the search (from worst to best, including the one returned by this method), where k corresponds to the &#39;number_of_solutions_to_collect&#39; in &#39;search_parameters&#39;. Note that the Assignment returned by the method and the ones in solutions are owned by the underlying solver and should not be deleted.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SolveWithParameters(self, search_parameters, solutions)

    def SolveFromAssignmentWithParameters(self, assignment: &#34;Assignment&#34;, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;, solutions: &#34;std::vector&lt; operations_research::Assignment const * &gt; *&#34;=None) -&gt; &#34;operations_research::Assignment const *&#34;:
        return _pywrapcp.RoutingModel_SolveFromAssignmentWithParameters(self, assignment, search_parameters, solutions)

    def SetAssignmentFromOtherModelAssignment(self, target_assignment: &#34;Assignment&#34;, source_model: &#34;RoutingModel&#34;, source_assignment: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Given a &#34;source_model&#34; and its &#34;source_assignment&#34;, resets &#34;target_assignment&#34; with the IntVar variables (nexts_, and vehicle_vars_ if costs aren&#39;t homogeneous across vehicles) of &#34;this&#34; model, with the values set according to those in &#34;other_assignment&#34;. The objective_element of target_assignment is set to this-&gt;cost_.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_SetAssignmentFromOtherModelAssignment(self, target_assignment, source_model, source_assignment)

    def ComputeLowerBound(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Computes a lower bound to the routing problem solving a linear assignment problem. The routing model must be closed before calling this method. Note that problems with node disjunction constraints (including optional nodes) and non-homogenous costs are not supported (the method returns 0 in these cases).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ComputeLowerBound(self)

    def status(self) -&gt; &#34;operations_research::RoutingModel::Status&#34;:
        r&#34;&#34;&#34; Returns the current status of the routing model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_status(self)

    def ApplyLocks(self, locks: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Applies a lock chain to the next search. &#39;locks&#39; represents an ordered vector of nodes representing a partial route which will be fixed during the next search; it will constrain next variables such that: next[locks[i]] == locks[i+1]. Returns the next variable at the end of the locked chain; this variable is not locked. An assignment containing the locks can be obtained by calling PreAssignment().&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ApplyLocks(self, locks)

    def ApplyLocksToAllVehicles(self, locks: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; const &amp;&#34;, close_routes: &#34;bool&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Applies lock chains to all vehicles to the next search, such that locks[p] is the lock chain for route p. Returns false if the locks do not contain valid routes; expects that the routes do not contain the depots, i.e. there are empty vectors in place of empty routes. If close_routes is set to true, adds the end nodes to the route of each vehicle and deactivates other nodes. An assignment containing the locks can be obtained by calling PreAssignment().&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ApplyLocksToAllVehicles(self, locks, close_routes)

    def PreAssignment(self) -&gt; &#34;operations_research::Assignment const *const&#34;:
        r&#34;&#34;&#34; Returns an assignment used to fix some of the variables of the problem. In practice, this assignment locks partial routes of the problem. This can be used in the context of locking the parts of the routes which have already been driven in online routing problems.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_PreAssignment(self)

    def MutablePreAssignment(self) -&gt; &#34;operations_research::Assignment *&#34;:
        return _pywrapcp.RoutingModel_MutablePreAssignment(self)

    def WriteAssignment(self, file_name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Writes the current solution to a file containing an AssignmentProto. Returns false if the file cannot be opened or if there is no current solution.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_WriteAssignment(self, file_name)

    def ReadAssignment(self, file_name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34; Reads an assignment from a file and returns the current solution. Returns nullptr if the file cannot be opened or if the assignment is not valid.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ReadAssignment(self, file_name)

    def RestoreAssignment(self, solution: &#34;Assignment&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34; Restores an assignment as a solution in the routing model and returns the new solution. Returns nullptr if the assignment is not valid.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_RestoreAssignment(self, solution)

    def ReadAssignmentFromRoutes(self, routes: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; const &amp;&#34;, ignore_inactive_indices: &#34;bool&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34; Restores the routes as the current solution. Returns nullptr if the solution cannot be restored (routes do not contain a valid solution). Note that calling this method will run the solver to assign values to the dimension variables; this may take considerable amount of time, especially when using dimensions with slack.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ReadAssignmentFromRoutes(self, routes, ignore_inactive_indices)

    def RoutesToAssignment(self, routes: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; const &amp;&#34;, ignore_inactive_indices: &#34;bool&#34;, close_routes: &#34;bool&#34;, assignment: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Fills an assignment from a specification of the routes of the vehicles. The routes are specified as lists of variable indices that appear on the routes of the vehicles. The indices of the outer vector in &#39;routes&#39; correspond to vehicles IDs, the inner vector contains the variable indices on the routes for the given vehicle. The inner vectors must not contain the start and end indices, as these are determined by the routing model.  Sets the value of NextVars in the assignment, adding the variables to the assignment if necessary. The method does not touch other variables in the assignment. The method can only be called after the model is closed.  With ignore_inactive_indices set to false, this method will fail (return nullptr) in case some of the route contain indices that are deactivated in the model; when set to true, these indices will be skipped.  Returns true if routes were successfully loaded. However, such assignment still might not be a valid solution to the routing problem due to more complex constraints; it is advisible to call solver()-&gt;CheckSolution() afterwards.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_RoutesToAssignment(self, routes, ignore_inactive_indices, close_routes, assignment)

    def AssignmentToRoutes(self, assignment: &#34;Assignment&#34;, routes: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; *const&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Converts the solution in the given assignment to routes for all vehicles. Expects that assignment contains a valid solution (i.e. routes for all vehicles end with an end index for that vehicle).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AssignmentToRoutes(self, assignment, routes)

    def CompactAssignment(self, assignment: &#34;Assignment&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34; Returns a compacted version of the given assignment, in which all vehicles with id lower or equal to some N have non-empty routes, and all vehicles with id greater than N have empty routes. Does not take ownership of the returned object. If found, the cost of the compact assignment is the same as in the original assignment and it preserves the values of &#39;active&#39; variables. Returns nullptr if a compact assignment was not found. This method only works in homogenous mode, and it only swaps equivalent vehicles (vehicles with the same start and end nodes). When creating the compact assignment, the empty plan is replaced by the route assigned to the compatible vehicle with the highest id. Note that with more complex constraints on vehicle variables, this method might fail even if a compact solution exists. This method changes the vehicle and dimension variables as necessary. While compacting the solution, only basic checks on vehicle variables are performed; if one of these checks fails no attempts to repair it are made (instead, the method returns nullptr).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CompactAssignment(self, assignment)

    def CompactAndCheckAssignment(self, assignment: &#34;Assignment&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34; Same as CompactAssignment() but also checks the validity of the final compact solution; if it is not valid, no attempts to repair it are made (instead, the method returns nullptr).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CompactAndCheckAssignment(self, assignment)

    def AddToAssignment(self, var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds an extra variable to the vehicle routing assignment.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddToAssignment(self, var)

    def AddIntervalToAssignment(self, interval: &#34;IntervalVar&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingModel_AddIntervalToAssignment(self, interval)

    def PackCumulsOfOptimizerDimensionsFromAssignment(self, original_assignment: &#34;Assignment&#34;, duration_limit: &#34;absl::Duration&#34;) -&gt; &#34;operations_research::Assignment const *&#34;:
        r&#34;&#34;&#34; For every dimension in the model with an optimizer in local/global_dimension_optimizers_, this method tries to pack the cumul values of the dimension, such that: - The cumul costs (span costs, soft lower and upper bound costs, etc) are   minimized. - The cumuls of the ends of the routes are minimized for this given   minimal cumul cost. - Given these minimal end cumuls, the route start cumuls are maximized. Returns the assignment resulting from allocating these packed cumuls with the solver, and nullptr if these cumuls could not be set by the solver.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_PackCumulsOfOptimizerDimensionsFromAssignment(self, original_assignment, duration_limit)

    def AddLocalSearchFilter(self, filter: &#34;LocalSearchFilter&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Adds a custom local search filter to the list of filters used to speed up local search by pruning unfeasible variable assignments. Calling this method after the routing model has been closed (CloseModel() or Solve() has been called) has no effect. The routing model does not take ownership of the filter.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_AddLocalSearchFilter(self, filter)

    def Start(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Model inspection. Returns the variable index of the starting node of a vehicle route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_Start(self, vehicle)

    def End(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the variable index of the ending node of a vehicle route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_End(self, vehicle)

    def IsStart(self, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if &#39;index&#39; represents the first node of a route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_IsStart(self, index)

    def IsEnd(self, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if &#39;index&#39; represents the last node of a route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_IsEnd(self, index)

    def VehicleIndex(self, index: &#34;int&#34;) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns the vehicle of the given start/end index, and -1 if the given index is not a vehicle start/end.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_VehicleIndex(self, index)

    def Next(self, assignment: &#34;Assignment&#34;, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Assignment inspection Returns the variable index of the node directly after the node corresponding to &#39;index&#39; in &#39;assignment&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_Next(self, assignment, index)

    def IsVehicleUsed(self, assignment: &#34;Assignment&#34;, vehicle: &#34;int&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if the route of &#39;vehicle&#39; is non empty in &#39;assignment&#39;.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_IsVehicleUsed(self, assignment, vehicle)

    def NextVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the next variable of the node corresponding to index. Note that NextVar(index) == index is equivalent to ActiveVar(index) == 0.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_NextVar(self, index)

    def ActiveVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the active variable of the node corresponding to index.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ActiveVar(self, index)

    def VehicleCostsConsideredVar(self, vehicle: &#34;int&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the variable specifying whether or not costs are considered for vehicle.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_VehicleCostsConsideredVar(self, vehicle)

    def VehicleVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the vehicle variable of the node corresponding to index. Note that VehicleVar(index) == -1 is equivalent to ActiveVar(index) == 0.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_VehicleVar(self, index)

    def CostVar(self) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the global cost variable which is being minimized.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CostVar(self)

    def GetArcCostForVehicle(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;, vehicle: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the cost of the transit arc between two nodes for a given vehicle. Input are variable indices of node. This returns 0 if vehicle &lt; 0.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetArcCostForVehicle(self, from_index, to_index, vehicle)

    def CostsAreHomogeneousAcrossVehicles(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Whether costs are homogeneous across all vehicles.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CostsAreHomogeneousAcrossVehicles(self)

    def GetHomogeneousCost(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the cost of the segment between two nodes supposing all vehicle costs are the same (returns the cost for the first vehicle otherwise).&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetHomogeneousCost(self, from_index, to_index)

    def GetArcCostForFirstSolution(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the cost of the arc in the context of the first solution strategy. This is typically a simplification of the actual cost; see the .cc.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetArcCostForFirstSolution(self, from_index, to_index)

    def GetArcCostForClass(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;, cost_class_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the cost of the segment between two nodes for a given cost class. Input are variable indices of nodes and the cost class. Unlike GetArcCostForVehicle(), if cost_class is kNoCost, then the returned cost won&#39;t necessarily be zero: only some of the components of the cost that depend on the cost class will be omited. See the code for details.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetArcCostForClass(self, from_index, to_index, cost_class_index)

    def GetCostClassIndexOfVehicle(self, vehicle: &#34;int64&#34;) -&gt; &#34;operations_research::RoutingModel::CostClassIndex&#34;:
        r&#34;&#34;&#34; Get the cost class index of the given vehicle.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetCostClassIndexOfVehicle(self, vehicle)

    def HasVehicleWithCostClassIndex(self, cost_class_index: &#34;operations_research::RoutingModel::CostClassIndex&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true iff the model contains a vehicle with the given cost_class_index.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_HasVehicleWithCostClassIndex(self, cost_class_index)

    def GetCostClassesCount(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns the number of different cost classes in the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetCostClassesCount(self)

    def GetNonZeroCostClassesCount(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Ditto, minus the &#39;always zero&#39;, built-in cost class.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetNonZeroCostClassesCount(self)

    def GetVehicleClassIndexOfVehicle(self, vehicle: &#34;int64&#34;) -&gt; &#34;operations_research::RoutingModel::VehicleClassIndex&#34;:
        return _pywrapcp.RoutingModel_GetVehicleClassIndexOfVehicle(self, vehicle)

    def GetVehicleClassesCount(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns the number of different vehicle classes in the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetVehicleClassesCount(self)

    def GetSameVehicleIndicesOfIndex(self, node: &#34;int&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns variable indices of nodes constrained to be on the same route.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetSameVehicleIndicesOfIndex(self, node)

    def ArcIsMoreConstrainedThanArc(self, _from: &#34;int64&#34;, to1: &#34;int64&#34;, to2: &#34;int64&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns whether the arc from-&gt;to1 is more constrained than from-&gt;to2, taking into account, in order: - whether the destination node isn&#39;t an end node - whether the destination node is mandatory - whether the destination node is bound to the same vehicle as the source - the &#34;primary constrained&#34; dimension (see SetPrimaryConstrainedDimension) It then breaks ties using, in order: - the arc cost (taking unperformed penalties into account) - the size of the vehicle vars of &#34;to1&#34; and &#34;to2&#34; (lowest size wins) - the value: the lowest value of the indices to1 and to2 wins. See the .cc for details. The more constrained arc is typically preferable when building a first solution. This method is intended to be used as a callback for the BestValueByComparisonSelector value selector. Args:   from: the variable index of the source node   to1: the variable index of the first candidate destination node.   to2: the variable index of the second candidate destination node.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_ArcIsMoreConstrainedThanArc(self, _from, to1, to2)

    def DebugOutputAssignment(self, solution_assignment: &#34;Assignment&#34;, dimension_to_print: &#34;std::string const &amp;&#34;) -&gt; &#34;std::string&#34;:
        r&#34;&#34;&#34; Print some debugging information about an assignment, including the feasible intervals of the CumulVar for dimension &#34;dimension_to_print&#34; at each step of the routes. If &#34;dimension_to_print&#34; is omitted, all dimensions will be printed.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_DebugOutputAssignment(self, solution_assignment, dimension_to_print)

    def solver(self) -&gt; &#34;operations_research::Solver *&#34;:
        r&#34;&#34;&#34; Returns the underlying constraint solver. Can be used to add extra constraints and/or modify search algoithms.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_solver(self)

    def CheckLimit(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if the search limit has been crossed.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_CheckLimit(self)

    def RemainingTime(self) -&gt; &#34;absl::Duration&#34;:
        r&#34;&#34;&#34; Returns the time left in the search limit.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_RemainingTime(self)

    def nodes(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Sizes and indices Returns the number of nodes in the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_nodes(self)

    def vehicles(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns the number of vehicle routes in the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_vehicles(self)

    def Size(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the number of next variables in the model.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_Size(self)

    def GetNumberOfDecisionsInFirstSolution(self, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns statistics on first solution search, number of decisions sent to filters, number of decisions rejected by filters.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetNumberOfDecisionsInFirstSolution(self, search_parameters)

    def GetNumberOfRejectsInFirstSolution(self, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;) -&gt; &#34;int64&#34;:
        return _pywrapcp.RoutingModel_GetNumberOfRejectsInFirstSolution(self, search_parameters)

    def GetAutomaticFirstSolutionStrategy(self) -&gt; &#34;operations_research::FirstSolutionStrategy::Value&#34;:
        r&#34;&#34;&#34; Returns the automatic first solution strategy selected.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_GetAutomaticFirstSolutionStrategy(self)

    def IsMatchingModel(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if a vehicle/node matching problem is detected.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_IsMatchingModel(self)

    def MakeGuidedSlackFinalizer(self, dimension: &#34;RoutingDimension&#34;, initializer: &#34;std::function&lt; int64 (int64) &gt;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        r&#34;&#34;&#34; The next few members are in the public section only for testing purposes. MakeGuidedSlackFinalizer creates a DecisionBuilder for the slacks of a dimension using a callback to choose which values to start with. The finalizer works only when all next variables in the model have been fixed. It has the following two characteristics: 1. It follows the routes defined by the nexts variables when choosing a    variable to make a decision on. 2. When it comes to choose a value for the slack of node i, the decision    builder first calls the callback with argument i, and supposingly the    returned value is x it creates decisions slack[i] = x, slack[i] = x +    1, slack[i] = x - 1, slack[i] = x + 2, etc.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_MakeGuidedSlackFinalizer(self, dimension, initializer)

    def MakeSelfDependentDimensionFinalizer(self, dimension: &#34;RoutingDimension&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        r&#34;&#34;&#34; MakeSelfDependentDimensionFinalizer is a finalizer for the slacks of a self-dependent dimension. It makes an extensive use of the caches of the state dependent transits. In detail, MakeSelfDependentDimensionFinalizer returns a composition of a local search decision builder with a greedy descent operator for the cumul of the start of each route and a guided slack finalizer. Provided there are no time windows and the maximum slacks are large enough, once the cumul of the start of route is fixed, the guided finalizer can find optimal values of the slacks for the rest of the route in time proportional to the length of the route. Therefore the composed finalizer generally works in time O(log(t)*n*m), where t is the latest possible departute time, n is the number of nodes in the network and m is the number of vehicles.&#34;&#34;&#34;
        return _pywrapcp.RoutingModel_MakeSelfDependentDimensionFinalizer(self, dimension)

    def AddMatrixDimension(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.RoutingModel_AddMatrixDimension(self, *args)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pywrapcp.RoutingModel.ADDED_TYPE_REMOVED_FROM_VEHICLE"><code class="name">var <span class="ident">ADDED_TYPE_REMOVED_FROM_VEHICLE</span></code></dt>
<dd>
<div class="desc"><p>When visited, one instance of type 'T' previously added to the route (TYPE_ADDED_TO_VEHICLE), if any, is removed from the vehicle. If the type was not previously added to the route or all added instances have already been removed, this visit has no effect on the types.</p></div>
</dd>
<dt id="pywrapcp.RoutingModel.PICKUP_AND_DELIVERY_FIFO"><code class="name">var <span class="ident">PICKUP_AND_DELIVERY_FIFO</span></code></dt>
<dd>
<div class="desc"><p>Deliveries must be performed in the same order as pickups.</p></div>
</dd>
<dt id="pywrapcp.RoutingModel.PICKUP_AND_DELIVERY_LIFO"><code class="name">var <span class="ident">PICKUP_AND_DELIVERY_LIFO</span></code></dt>
<dd>
<div class="desc"><p>Deliveries must be performed in reverse order of pickups.</p></div>
</dd>
<dt id="pywrapcp.RoutingModel.PICKUP_AND_DELIVERY_NO_ORDER"><code class="name">var <span class="ident">PICKUP_AND_DELIVERY_NO_ORDER</span></code></dt>
<dd>
<div class="desc"><p>Any precedence is accepted.</p></div>
</dd>
<dt id="pywrapcp.RoutingModel.ROUTING_FAIL"><code class="name">var <span class="ident">ROUTING_FAIL</span></code></dt>
<dd>
<div class="desc"><p>No solution found to the problem after calling RoutingModel::Solve().</p></div>
</dd>
<dt id="pywrapcp.RoutingModel.ROUTING_FAIL_TIMEOUT"><code class="name">var <span class="ident">ROUTING_FAIL_TIMEOUT</span></code></dt>
<dd>
<div class="desc"><p>Time limit reached before finding a solution with RoutingModel::Solve().</p></div>
</dd>
<dt id="pywrapcp.RoutingModel.ROUTING_INVALID"><code class="name">var <span class="ident">ROUTING_INVALID</span></code></dt>
<dd>
<div class="desc"><p>Model, model parameters or flags are not valid.</p></div>
</dd>
<dt id="pywrapcp.RoutingModel.ROUTING_NOT_SOLVED"><code class="name">var <span class="ident">ROUTING_NOT_SOLVED</span></code></dt>
<dd>
<div class="desc"><p>Problem not solved yet (before calling RoutingModel::Solve()).</p></div>
</dd>
<dt id="pywrapcp.RoutingModel.ROUTING_SUCCESS"><code class="name">var <span class="ident">ROUTING_SUCCESS</span></code></dt>
<dd>
<div class="desc"><p>Problem solved successfully after calling RoutingModel::Solve().</p></div>
</dd>
<dt id="pywrapcp.RoutingModel.TYPE_ADDED_TO_VEHICLE"><code class="name">var <span class="ident">TYPE_ADDED_TO_VEHICLE</span></code></dt>
<dd>
<div class="desc"><p>When visited, the number of types 'T' on the vehicle increases by one.</p></div>
</dd>
<dt id="pywrapcp.RoutingModel.TYPE_ON_VEHICLE_UP_TO_VISIT"><code class="name">var <span class="ident">TYPE_ON_VEHICLE_UP_TO_VISIT</span></code></dt>
<dd>
<div class="desc"><p>With the following policy, the visit enforces that type 'T' is considered on the route from its start until this node is visited.</p></div>
</dd>
<dt id="pywrapcp.RoutingModel.TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED"><code class="name">var <span class="ident">TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED</span></code></dt>
<dd>
<div class="desc"><p>The visit doesn't have an impact on the number of types 'T' on the route, as it's (virtually) added and removed directly. This policy can be used for visits which are part of an incompatibility or requirement set without affecting the type count on the route.</p></div>
</dd>
<dt id="pywrapcp.RoutingModel.kNoDimension"><code class="name">var <span class="ident">kNoDimension</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.RoutingModel.kNoDisjunction"><code class="name">var <span class="ident">kNoDisjunction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.RoutingModel.kNoPenalty"><code class="name">var <span class="ident">kNoPenalty</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapcp.RoutingModel.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<div class="desc"><p>The membership flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.RoutingModel.ActiveVar"><code class="name flex">
<span>def <span class="ident">ActiveVar</span></span>(<span>self, index: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the active variable of the node corresponding to index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ActiveVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; Returns the active variable of the node corresponding to index.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_ActiveVar(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddAtSolutionCallback"><code class="name flex">
<span>def <span class="ident">AddAtSolutionCallback</span></span>(<span>self, callback: std::function< void () >) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a callback called each time a solution is found during the search. This is a shortcut to creating a monitor to call the callback on AtSolution() and adding it with AddSearchMonitor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddAtSolutionCallback(self, callback: &#34;std::function&lt; void () &gt;&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Adds a callback called each time a solution is found during the search. This is a shortcut to creating a monitor to call the callback on AtSolution() and adding it with AddSearchMonitor.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddAtSolutionCallback(self, callback)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddConstantDimension"><code class="name flex">
<span>def <span class="ident">AddConstantDimension</span></span>(<span>self, value: int64, capacity: int64, fix_start_cumul_to_zero: bool, name: std::string const &) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddConstantDimension(self, value: &#34;int64&#34;, capacity: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
    return _pywrapcp.RoutingModel_AddConstantDimension(self, value, capacity, fix_start_cumul_to_zero, name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddConstantDimensionWithSlack"><code class="name flex">
<span>def <span class="ident">AddConstantDimensionWithSlack</span></span>(<span>self, value: int64, capacity: int64, slack_max: int64, fix_start_cumul_to_zero: bool, name: std::string const &) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a dimension where the transit variable is constrained to be equal to 'value'; 'capacity' is the upper bound of the cumul variables. 'name' is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn't create the new dimension).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddConstantDimensionWithSlack(self, value: &#34;int64&#34;, capacity: &#34;int64&#34;, slack_max: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Creates a dimension where the transit variable is constrained to be equal to &#39;value&#39;; &#39;capacity&#39; is the upper bound of the cumul variables. &#39;name&#39; is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn&#39;t create the new dimension).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddConstantDimensionWithSlack(self, value, capacity, slack_max, fix_start_cumul_to_zero, name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddDimension"><code class="name flex">
<span>def <span class="ident">AddDimension</span></span>(<span>self, evaluator_index: int, slack_max: int64, capacity: int64, fix_start_cumul_to_zero: bool, name: std::string const &) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Model creation Methods to add dimensions to routes; dimensions represent quantities accumulated at nodes along the routes. They represent quantities such as weights or volumes carried along the route, or distance or times. Quantities at a node are represented by "cumul" variables and the increase or decrease of quantities between nodes are represented by "transit" variables. These variables are linked as follows: if j == next(i), cumul(j) = cumul(i) + transit(i) + slack(i) where slack is a positive slack variable (can represent waiting times for a time dimension). Setting the value of fix_start_cumul_to_zero to true will force the "cumul" variable of the start node of all vehicles to be equal to 0. Creates a dimension where the transit variable is constrained to be equal to evaluator(i, next(i)); 'slack_max' is the upper bound of the slack variable and 'capacity' is the upper bound of the cumul variables. 'name' is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn't create the new dimension). Takes ownership of the callback 'evaluator'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddDimension(self, evaluator_index: &#34;int&#34;, slack_max: &#34;int64&#34;, capacity: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Model creation Methods to add dimensions to routes; dimensions represent quantities accumulated at nodes along the routes. They represent quantities such as weights or volumes carried along the route, or distance or times. Quantities at a node are represented by &#34;cumul&#34; variables and the increase or decrease of quantities between nodes are represented by &#34;transit&#34; variables. These variables are linked as follows: if j == next(i), cumul(j) = cumul(i) + transit(i) + slack(i) where slack is a positive slack variable (can represent waiting times for a time dimension). Setting the value of fix_start_cumul_to_zero to true will force the &#34;cumul&#34; variable of the start node of all vehicles to be equal to 0. Creates a dimension where the transit variable is constrained to be equal to evaluator(i, next(i)); &#39;slack_max&#39; is the upper bound of the slack variable and &#39;capacity&#39; is the upper bound of the cumul variables. &#39;name&#39; is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn&#39;t create the new dimension). Takes ownership of the callback &#39;evaluator&#39;.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddDimension(self, evaluator_index, slack_max, capacity, fix_start_cumul_to_zero, name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddDimensionWithVehicleCapacity"><code class="name flex">
<span>def <span class="ident">AddDimensionWithVehicleCapacity</span></span>(<span>self, evaluator_index: int, slack_max: int64, vehicle_capacities: std::vector< int64 >, fix_start_cumul_to_zero: bool, name: std::string const &) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddDimensionWithVehicleCapacity(self, evaluator_index: &#34;int&#34;, slack_max: &#34;int64&#34;, vehicle_capacities: &#34;std::vector&lt; int64 &gt;&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
    return _pywrapcp.RoutingModel_AddDimensionWithVehicleCapacity(self, evaluator_index, slack_max, vehicle_capacities, fix_start_cumul_to_zero, name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddDimensionWithVehicleTransitAndCapacity"><code class="name flex">
<span>def <span class="ident">AddDimensionWithVehicleTransitAndCapacity</span></span>(<span>self, evaluator_indices: std::vector< int > const &, slack_max: int64, vehicle_capacities: std::vector< int64 >, fix_start_cumul_to_zero: bool, name: std::string const &) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddDimensionWithVehicleTransitAndCapacity(self, evaluator_indices: &#34;std::vector&lt; int &gt; const &amp;&#34;, slack_max: &#34;int64&#34;, vehicle_capacities: &#34;std::vector&lt; int64 &gt;&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
    return _pywrapcp.RoutingModel_AddDimensionWithVehicleTransitAndCapacity(self, evaluator_indices, slack_max, vehicle_capacities, fix_start_cumul_to_zero, name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddDimensionWithVehicleTransits"><code class="name flex">
<span>def <span class="ident">AddDimensionWithVehicleTransits</span></span>(<span>self, evaluator_indices: std::vector< int > const &, slack_max: int64, capacity: int64, fix_start_cumul_to_zero: bool, name: std::string const &) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddDimensionWithVehicleTransits(self, evaluator_indices: &#34;std::vector&lt; int &gt; const &amp;&#34;, slack_max: &#34;int64&#34;, capacity: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
    return _pywrapcp.RoutingModel_AddDimensionWithVehicleTransits(self, evaluator_indices, slack_max, capacity, fix_start_cumul_to_zero, name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddDisjunction"><code class="name flex">
<span>def <span class="ident">AddDisjunction</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.RoutingModel" href="#pywrapcp.RoutingModel">RoutingModel</a>::DisjunctionIndex'</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a disjunction constraint on the indices: exactly 'max_cardinality' of the indices are active. Start and end indices of any vehicle cannot be part of a disjunction. If a penalty is given, at most 'max_cardinality' of the indices can be active, and if less are active, 'penalty' is payed per inactive index. This is equivalent to adding the constraint:
p + Sum(i)active[i] == max_cardinality where p is an integer variable, and the following cost to the cost function:
p * penalty. 'penalty' must be positive to make the disjunction optional; a negative penalty will force 'max_cardinality' indices of the disjunction to be performed, and therefore p == 0. Note: passing a vector with a single index will model an optional index with a penalty cost if it is not visited.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddDisjunction(self, *args) -&gt; &#34;operations_research::RoutingModel::DisjunctionIndex&#34;:
    r&#34;&#34;&#34; Adds a disjunction constraint on the indices: exactly &#39;max_cardinality&#39; of the indices are active. Start and end indices of any vehicle cannot be part of a disjunction. If a penalty is given, at most &#39;max_cardinality&#39; of the indices can be active, and if less are active, &#39;penalty&#39; is payed per inactive index. This is equivalent to adding the constraint:     p + Sum(i)active[i] == max_cardinality where p is an integer variable, and the following cost to the cost function:     p * penalty. &#39;penalty&#39; must be positive to make the disjunction optional; a negative penalty will force &#39;max_cardinality&#39; indices of the disjunction to be performed, and therefore p == 0. Note: passing a vector with a single index will model an optional index with a penalty cost if it is not visited.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddDisjunction(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddHardTypeIncompatibility"><code class="name flex">
<span>def <span class="ident">AddHardTypeIncompatibility</span></span>(<span>self, type1: int, type2: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Incompatibilities: Two nodes with "hard" incompatible types cannot share the same route at all, while with a "temporal" incompatibility they can't be on the same route at the same time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddHardTypeIncompatibility(self, type1: &#34;int&#34;, type2: &#34;int&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Incompatibilities: Two nodes with &#34;hard&#34; incompatible types cannot share the same route at all, while with a &#34;temporal&#34; incompatibility they can&#39;t be on the same route at the same time.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddHardTypeIncompatibility(self, type1, type2)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddIntervalToAssignment"><code class="name flex">
<span>def <span class="ident">AddIntervalToAssignment</span></span>(<span>self, interval: IntervalVar) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddIntervalToAssignment(self, interval: &#34;IntervalVar&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.RoutingModel_AddIntervalToAssignment(self, interval)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddLocalSearchFilter"><code class="name flex">
<span>def <span class="ident">AddLocalSearchFilter</span></span>(<span>self, filter: LocalSearchFilter) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a custom local search filter to the list of filters used to speed up local search by pruning unfeasible variable assignments. Calling this method after the routing model has been closed (CloseModel() or Solve() has been called) has no effect. The routing model does not take ownership of the filter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddLocalSearchFilter(self, filter: &#34;LocalSearchFilter&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Adds a custom local search filter to the list of filters used to speed up local search by pruning unfeasible variable assignments. Calling this method after the routing model has been closed (CloseModel() or Solve() has been called) has no effect. The routing model does not take ownership of the filter.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddLocalSearchFilter(self, filter)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddLocalSearchOperator"><code class="name flex">
<span>def <span class="ident">AddLocalSearchOperator</span></span>(<span>self, ls_operator: LocalSearchOperator) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a local search operator to the set of operators used to solve the vehicle routing problem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddLocalSearchOperator(self, ls_operator: &#34;LocalSearchOperator&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Adds a local search operator to the set of operators used to solve the vehicle routing problem.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddLocalSearchOperator(self, ls_operator)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddMatrixDimension"><code class="name flex">
<span>def <span class="ident">AddMatrixDimension</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddMatrixDimension(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.RoutingModel_AddMatrixDimension(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddPickupAndDelivery"><code class="name flex">
<span>def <span class="ident">AddPickupAndDelivery</span></span>(<span>self, pickup: int64, delivery: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Notifies that index1 and index2 form a pair of nodes which should belong to the same route. This methods helps the search find better solutions, especially in the local search phase. It should be called each time you have an equality constraint linking the vehicle variables of two node (including for instance pickup and delivery problems):
Solver* const solver = routing.solver();
int64 index1 = manager.NodeToIndex(node1);
int64 index2 = manager.NodeToIndex(node2);
solver-&gt;AddConstraint(solver-&gt;MakeEquality(
routing.VehicleVar(index1),
routing.VehicleVar(index2)));
routing.AddPickupAndDelivery(index1, index2);</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddPickupAndDelivery(self, pickup: &#34;int64&#34;, delivery: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Notifies that index1 and index2 form a pair of nodes which should belong to the same route. This methods helps the search find better solutions, especially in the local search phase. It should be called each time you have an equality constraint linking the vehicle variables of two node (including for instance pickup and delivery problems):     Solver* const solver = routing.solver();     int64 index1 = manager.NodeToIndex(node1);     int64 index2 = manager.NodeToIndex(node2);     solver-&gt;AddConstraint(solver-&gt;MakeEquality(         routing.VehicleVar(index1),         routing.VehicleVar(index2)));     routing.AddPickupAndDelivery(index1, index2);&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddPickupAndDelivery(self, pickup, delivery)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddPickupAndDeliverySets"><code class="name flex">
<span>def <span class="ident">AddPickupAndDeliverySets</span></span>(<span>self, pickup_disjunction: operations_research::RoutingModel::DisjunctionIndex, delivery_disjunction: operations_research::RoutingModel::DisjunctionIndex) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Same as AddPickupAndDelivery but notifying that the performed node from the disjunction of index 'pickup_disjunction' is on the same route as the performed node from the disjunction of index 'delivery_disjunction'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddPickupAndDeliverySets(self, pickup_disjunction: &#34;operations_research::RoutingModel::DisjunctionIndex&#34;, delivery_disjunction: &#34;operations_research::RoutingModel::DisjunctionIndex&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Same as AddPickupAndDelivery but notifying that the performed node from the disjunction of index &#39;pickup_disjunction&#39; is on the same route as the performed node from the disjunction of index &#39;delivery_disjunction&#39;.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddPickupAndDeliverySets(self, pickup_disjunction, delivery_disjunction)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddRequiredTypeAlternativesWhenAddingType"><code class="name flex">
<span>def <span class="ident">AddRequiredTypeAlternativesWhenAddingType</span></span>(<span>self, dependent_type: int, required_type_alternatives: absl::flat_hash_set< int >) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>If type_D depends on type_R when adding type_D, any node_D of type_D and VisitTypePolicy TYPE_ADDED_TO_VEHICLE or TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED requires at least one type_R on its vehicle at the time node_D is visited.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddRequiredTypeAlternativesWhenAddingType(self, dependent_type: &#34;int&#34;, required_type_alternatives: &#34;absl::flat_hash_set&lt; int &gt;&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; If type_D depends on type_R when adding type_D, any node_D of type_D and VisitTypePolicy TYPE_ADDED_TO_VEHICLE or TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED requires at least one type_R on its vehicle at the time node_D is visited.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddRequiredTypeAlternativesWhenAddingType(self, dependent_type, required_type_alternatives)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddRequiredTypeAlternativesWhenRemovingType"><code class="name flex">
<span>def <span class="ident">AddRequiredTypeAlternativesWhenRemovingType</span></span>(<span>self, dependent_type: int, required_type_alternatives: absl::flat_hash_set< int >) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>The following requirements apply when visiting dependent nodes that remove their type from the route, i.e. type_R must be on the vehicle when type_D of VisitTypePolicy ADDED_TYPE_REMOVED_FROM_VEHICLE, TYPE_ON_VEHICLE_UP_TO_VISIT or TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED is visited.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddRequiredTypeAlternativesWhenRemovingType(self, dependent_type: &#34;int&#34;, required_type_alternatives: &#34;absl::flat_hash_set&lt; int &gt;&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; The following requirements apply when visiting dependent nodes that remove their type from the route, i.e. type_R must be on the vehicle when type_D of VisitTypePolicy ADDED_TYPE_REMOVED_FROM_VEHICLE, TYPE_ON_VEHICLE_UP_TO_VISIT or TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED is visited.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddRequiredTypeAlternativesWhenRemovingType(self, dependent_type, required_type_alternatives)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddSameVehicleRequiredTypeAlternatives"><code class="name flex">
<span>def <span class="ident">AddSameVehicleRequiredTypeAlternatives</span></span>(<span>self, dependent_type: int, required_type_alternatives: absl::flat_hash_set< int >) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Requirements: NOTE: As of 2019-04, cycles in the requirement graph are not supported, and lead to the dependent nodes being skipped if possible (otherwise the model is considered infeasible). The following functions specify that "dependent_type" requires at least one of the types in "required_type_alternatives". For same-vehicle requirements, a node of dependent type type_D requires at least one node of type type_R among the required alternatives on the same route.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddSameVehicleRequiredTypeAlternatives(self, dependent_type: &#34;int&#34;, required_type_alternatives: &#34;absl::flat_hash_set&lt; int &gt;&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Requirements: NOTE: As of 2019-04, cycles in the requirement graph are not supported, and lead to the dependent nodes being skipped if possible (otherwise the model is considered infeasible). The following functions specify that &#34;dependent_type&#34; requires at least one of the types in &#34;required_type_alternatives&#34;. For same-vehicle requirements, a node of dependent type type_D requires at least one node of type type_R among the required alternatives on the same route.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddSameVehicleRequiredTypeAlternatives(self, dependent_type, required_type_alternatives)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddSearchMonitor"><code class="name flex">
<span>def <span class="ident">AddSearchMonitor</span></span>(<span>self, monitor: SearchMonitor) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a search monitor to the search used to solve the routing model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddSearchMonitor(self, monitor: &#34;SearchMonitor&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Adds a search monitor to the search used to solve the routing model.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddSearchMonitor(self, monitor)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddSoftSameVehicleConstraint"><code class="name flex">
<span>def <span class="ident">AddSoftSameVehicleConstraint</span></span>(<span>self, indices: std::vector< int64 > const &, cost: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a soft contraint to force a set of variable indices to be on the same vehicle. If all nodes are not on the same vehicle, each extra vehicle used adds 'cost' to the cost function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddSoftSameVehicleConstraint(self, indices: &#34;std::vector&lt; int64 &gt; const &amp;&#34;, cost: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Adds a soft contraint to force a set of variable indices to be on the same vehicle. If all nodes are not on the same vehicle, each extra vehicle used adds &#39;cost&#39; to the cost function.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddSoftSameVehicleConstraint(self, indices, cost)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddTemporalTypeIncompatibility"><code class="name flex">
<span>def <span class="ident">AddTemporalTypeIncompatibility</span></span>(<span>self, type1: int, type2: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddTemporalTypeIncompatibility(self, type1: &#34;int&#34;, type2: &#34;int&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.RoutingModel_AddTemporalTypeIncompatibility(self, type1, type2)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddToAssignment"><code class="name flex">
<span>def <span class="ident">AddToAssignment</span></span>(<span>self, var: IntVar) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an extra variable to the vehicle routing assignment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddToAssignment(self, var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Adds an extra variable to the vehicle routing assignment.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddToAssignment(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddVariableMaximizedByFinalizer"><code class="name flex">
<span>def <span class="ident">AddVariableMaximizedByFinalizer</span></span>(<span>self, var: IntVar) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a variable to maximize in the solution finalizer (see above for information on the solution finalizer).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddVariableMaximizedByFinalizer(self, var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Adds a variable to maximize in the solution finalizer (see above for information on the solution finalizer).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddVariableMaximizedByFinalizer(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddVariableMinimizedByFinalizer"><code class="name flex">
<span>def <span class="ident">AddVariableMinimizedByFinalizer</span></span>(<span>self, var: IntVar) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a variable to minimize in the solution finalizer. The solution finalizer is called each time a solution is found during the search and allows to instantiate secondary variables (such as dimension cumul variables).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddVariableMinimizedByFinalizer(self, var: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Adds a variable to minimize in the solution finalizer. The solution finalizer is called each time a solution is found during the search and allows to instantiate secondary variables (such as dimension cumul variables).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddVariableMinimizedByFinalizer(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddVariableTargetToFinalizer"><code class="name flex">
<span>def <span class="ident">AddVariableTargetToFinalizer</span></span>(<span>self, var: IntVar, target: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Add a variable to set the closest possible to the target value in the solution finalizer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddVariableTargetToFinalizer(self, var: &#34;IntVar&#34;, target: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Add a variable to set the closest possible to the target value in the solution finalizer.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddVariableTargetToFinalizer(self, var, target)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddVectorDimension"><code class="name flex">
<span>def <span class="ident">AddVectorDimension</span></span>(<span>self, values: std::vector< int64 >, capacity: int64, fix_start_cumul_to_zero: bool, name: std::string const &) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a dimension where the transit variable is constrained to be equal to 'values[i]' for node i; 'capacity' is the upper bound of the cumul variables. 'name' is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn't create the new dimension).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddVectorDimension(self, values: &#34;std::vector&lt; int64 &gt;&#34;, capacity: &#34;int64&#34;, fix_start_cumul_to_zero: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Creates a dimension where the transit variable is constrained to be equal to &#39;values[i]&#39; for node i; &#39;capacity&#39; is the upper bound of the cumul variables. &#39;name&#39; is the name used to reference the dimension; this name is used to get cumul and transit variables from the routing model. Returns false if a dimension with the same name has already been created (and doesn&#39;t create the new dimension).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddVectorDimension(self, values, capacity, fix_start_cumul_to_zero, name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AddWeightedVariableMinimizedByFinalizer"><code class="name flex">
<span>def <span class="ident">AddWeightedVariableMinimizedByFinalizer</span></span>(<span>self, var: IntVar, cost: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a variable to minimize in the solution finalizer, with a weighted priority: the higher the more priority it has.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddWeightedVariableMinimizedByFinalizer(self, var: &#34;IntVar&#34;, cost: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Adds a variable to minimize in the solution finalizer, with a weighted priority: the higher the more priority it has.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AddWeightedVariableMinimizedByFinalizer(self, var, cost)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.ApplyLocks"><code class="name flex">
<span>def <span class="ident">ApplyLocks</span></span>(<span>self, locks: std::vector< int64 > const &) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Applies a lock chain to the next search. 'locks' represents an ordered vector of nodes representing a partial route which will be fixed during the next search; it will constrain next variables such that: next[locks[i]] == locks[i+1]. Returns the next variable at the end of the locked chain; this variable is not locked. An assignment containing the locks can be obtained by calling PreAssignment().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ApplyLocks(self, locks: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; Applies a lock chain to the next search. &#39;locks&#39; represents an ordered vector of nodes representing a partial route which will be fixed during the next search; it will constrain next variables such that: next[locks[i]] == locks[i+1]. Returns the next variable at the end of the locked chain; this variable is not locked. An assignment containing the locks can be obtained by calling PreAssignment().&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_ApplyLocks(self, locks)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.ApplyLocksToAllVehicles"><code class="name flex">
<span>def <span class="ident">ApplyLocksToAllVehicles</span></span>(<span>self, locks: std::vector< std::vector< int64 > > const &, close_routes: bool) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Applies lock chains to all vehicles to the next search, such that locks[p] is the lock chain for route p. Returns false if the locks do not contain valid routes; expects that the routes do not contain the depots, i.e. there are empty vectors in place of empty routes. If close_routes is set to true, adds the end nodes to the route of each vehicle and deactivates other nodes. An assignment containing the locks can be obtained by calling PreAssignment().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ApplyLocksToAllVehicles(self, locks: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; const &amp;&#34;, close_routes: &#34;bool&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Applies lock chains to all vehicles to the next search, such that locks[p] is the lock chain for route p. Returns false if the locks do not contain valid routes; expects that the routes do not contain the depots, i.e. there are empty vectors in place of empty routes. If close_routes is set to true, adds the end nodes to the route of each vehicle and deactivates other nodes. An assignment containing the locks can be obtained by calling PreAssignment().&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_ApplyLocksToAllVehicles(self, locks, close_routes)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.ArcIsMoreConstrainedThanArc"><code class="name flex">
<span>def <span class="ident">ArcIsMoreConstrainedThanArc</span></span>(<span>self, _from: int64, to1: int64, to2: int64) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns whether the arc from-&gt;to1 is more constrained than from-&gt;to2, taking into account, in order: - whether the destination node isn't an end node - whether the destination node is mandatory - whether the destination node is bound to the same vehicle as the source - the "primary constrained" dimension (see SetPrimaryConstrainedDimension) It then breaks ties using, in order: - the arc cost (taking unperformed penalties into account) - the size of the vehicle vars of "to1" and "to2" (lowest size wins) - the value: the lowest value of the indices to1 and to2 wins. See the .cc for details. The more constrained arc is typically preferable when building a first solution. This method is intended to be used as a callback for the BestValueByComparisonSelector value selector. Args:
from: the variable index of the source node
to1: the variable index of the first candidate destination node.
to2: the variable index of the second candidate destination node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ArcIsMoreConstrainedThanArc(self, _from: &#34;int64&#34;, to1: &#34;int64&#34;, to2: &#34;int64&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns whether the arc from-&gt;to1 is more constrained than from-&gt;to2, taking into account, in order: - whether the destination node isn&#39;t an end node - whether the destination node is mandatory - whether the destination node is bound to the same vehicle as the source - the &#34;primary constrained&#34; dimension (see SetPrimaryConstrainedDimension) It then breaks ties using, in order: - the arc cost (taking unperformed penalties into account) - the size of the vehicle vars of &#34;to1&#34; and &#34;to2&#34; (lowest size wins) - the value: the lowest value of the indices to1 and to2 wins. See the .cc for details. The more constrained arc is typically preferable when building a first solution. This method is intended to be used as a callback for the BestValueByComparisonSelector value selector. Args:   from: the variable index of the source node   to1: the variable index of the first candidate destination node.   to2: the variable index of the second candidate destination node.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_ArcIsMoreConstrainedThanArc(self, _from, to1, to2)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AreEmptyRouteCostsConsideredForVehicle"><code class="name flex">
<span>def <span class="ident">AreEmptyRouteCostsConsideredForVehicle</span></span>(<span>self, vehicle: int) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AreEmptyRouteCostsConsideredForVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;bool&#34;:
    return _pywrapcp.RoutingModel_AreEmptyRouteCostsConsideredForVehicle(self, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.AssignmentToRoutes"><code class="name flex">
<span>def <span class="ident">AssignmentToRoutes</span></span>(<span>self, assignment: Assignment, routes: std::vector< std::vector< int64 > > *const) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the solution in the given assignment to routes for all vehicles. Expects that assignment contains a valid solution (i.e. routes for all vehicles end with an end index for that vehicle).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AssignmentToRoutes(self, assignment: &#34;Assignment&#34;, routes: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; *const&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Converts the solution in the given assignment to routes for all vehicles. Expects that assignment contains a valid solution (i.e. routes for all vehicles end with an end index for that vehicle).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_AssignmentToRoutes(self, assignment, routes)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.CheckLimit"><code class="name flex">
<span>def <span class="ident">CheckLimit</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the search limit has been crossed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CheckLimit(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true if the search limit has been crossed.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_CheckLimit(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.CloseModel"><code class="name flex">
<span>def <span class="ident">CloseModel</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Closes the current routing model; after this method is called, no modification to the model can be done, but RoutesToAssignment becomes available. Note that CloseModel() is automatically called by Solve() and other methods that produce solution. This is equivalent to calling CloseModelWithParameters(DefaultRoutingSearchParameters()).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CloseModel(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Closes the current routing model; after this method is called, no modification to the model can be done, but RoutesToAssignment becomes available. Note that CloseModel() is automatically called by Solve() and other methods that produce solution. This is equivalent to calling CloseModelWithParameters(DefaultRoutingSearchParameters()).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_CloseModel(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.CloseModelWithParameters"><code class="name flex">
<span>def <span class="ident">CloseModelWithParameters</span></span>(<span>self, search_parameters: operations_research::RoutingSearchParameters const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Same as above taking search parameters (as of 10/2015 some the parameters have to be set when closing the model).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CloseModelWithParameters(self, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Same as above taking search parameters (as of 10/2015 some the parameters have to be set when closing the model).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_CloseModelWithParameters(self, search_parameters)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.CloseVisitTypes"><code class="name flex">
<span>def <span class="ident">CloseVisitTypes</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This function should be called once all node visit types have been set and prior to adding any incompatibilities/requirements. "close" types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CloseVisitTypes(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This function should be called once all node visit types have been set and prior to adding any incompatibilities/requirements. &#34;close&#34; types.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_CloseVisitTypes(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.CompactAndCheckAssignment"><code class="name flex">
<span>def <span class="ident">CompactAndCheckAssignment</span></span>(<span>self, assignment: Assignment) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Same as CompactAssignment() but also checks the validity of the final compact solution; if it is not valid, no attempts to repair it are made (instead, the method returns nullptr).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CompactAndCheckAssignment(self, assignment: &#34;Assignment&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
    r&#34;&#34;&#34; Same as CompactAssignment() but also checks the validity of the final compact solution; if it is not valid, no attempts to repair it are made (instead, the method returns nullptr).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_CompactAndCheckAssignment(self, assignment)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.CompactAssignment"><code class="name flex">
<span>def <span class="ident">CompactAssignment</span></span>(<span>self, assignment: Assignment) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a compacted version of the given assignment, in which all vehicles with id lower or equal to some N have non-empty routes, and all vehicles with id greater than N have empty routes. Does not take ownership of the returned object. If found, the cost of the compact assignment is the same as in the original assignment and it preserves the values of 'active' variables. Returns nullptr if a compact assignment was not found. This method only works in homogenous mode, and it only swaps equivalent vehicles (vehicles with the same start and end nodes). When creating the compact assignment, the empty plan is replaced by the route assigned to the compatible vehicle with the highest id. Note that with more complex constraints on vehicle variables, this method might fail even if a compact solution exists. This method changes the vehicle and dimension variables as necessary. While compacting the solution, only basic checks on vehicle variables are performed; if one of these checks fails no attempts to repair it are made (instead, the method returns nullptr).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CompactAssignment(self, assignment: &#34;Assignment&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
    r&#34;&#34;&#34; Returns a compacted version of the given assignment, in which all vehicles with id lower or equal to some N have non-empty routes, and all vehicles with id greater than N have empty routes. Does not take ownership of the returned object. If found, the cost of the compact assignment is the same as in the original assignment and it preserves the values of &#39;active&#39; variables. Returns nullptr if a compact assignment was not found. This method only works in homogenous mode, and it only swaps equivalent vehicles (vehicles with the same start and end nodes). When creating the compact assignment, the empty plan is replaced by the route assigned to the compatible vehicle with the highest id. Note that with more complex constraints on vehicle variables, this method might fail even if a compact solution exists. This method changes the vehicle and dimension variables as necessary. While compacting the solution, only basic checks on vehicle variables are performed; if one of these checks fails no attempts to repair it are made (instead, the method returns nullptr).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_CompactAssignment(self, assignment)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.ComputeLowerBound"><code class="name flex">
<span>def <span class="ident">ComputeLowerBound</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Computes a lower bound to the routing problem solving a linear assignment problem. The routing model must be closed before calling this method. Note that problems with node disjunction constraints (including optional nodes) and non-homogenous costs are not supported (the method returns 0 in these cases).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ComputeLowerBound(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Computes a lower bound to the routing problem solving a linear assignment problem. The routing model must be closed before calling this method. Note that problems with node disjunction constraints (including optional nodes) and non-homogenous costs are not supported (the method returns 0 in these cases).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_ComputeLowerBound(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.ConsiderEmptyRouteCostsForVehicle"><code class="name flex">
<span>def <span class="ident">ConsiderEmptyRouteCostsForVehicle</span></span>(<span>self, consider_costs: bool, vehicle: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConsiderEmptyRouteCostsForVehicle(self, consider_costs: &#34;bool&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.RoutingModel_ConsiderEmptyRouteCostsForVehicle(self, consider_costs, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.CostVar"><code class="name flex">
<span>def <span class="ident">CostVar</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the global cost variable which is being minimized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CostVar(self) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; Returns the global cost variable which is being minimized.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_CostVar(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.CostsAreHomogeneousAcrossVehicles"><code class="name flex">
<span>def <span class="ident">CostsAreHomogeneousAcrossVehicles</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Whether costs are homogeneous across all vehicles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CostsAreHomogeneousAcrossVehicles(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Whether costs are homogeneous across all vehicles.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_CostsAreHomogeneousAcrossVehicles(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.DebugOutputAssignment"><code class="name flex">
<span>def <span class="ident">DebugOutputAssignment</span></span>(<span>self, solution_assignment: Assignment, dimension_to_print: std::string const &) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"><p>Print some debugging information about an assignment, including the feasible intervals of the CumulVar for dimension "dimension_to_print" at each step of the routes. If "dimension_to_print" is omitted, all dimensions will be printed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugOutputAssignment(self, solution_assignment: &#34;Assignment&#34;, dimension_to_print: &#34;std::string const &amp;&#34;) -&gt; &#34;std::string&#34;:
    r&#34;&#34;&#34; Print some debugging information about an assignment, including the feasible intervals of the CumulVar for dimension &#34;dimension_to_print&#34; at each step of the routes. If &#34;dimension_to_print&#34; is omitted, all dimensions will be printed.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_DebugOutputAssignment(self, solution_assignment, dimension_to_print)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.End"><code class="name flex">
<span>def <span class="ident">End</span></span>(<span>self, vehicle: int) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the variable index of the ending node of a vehicle route.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def End(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the variable index of the ending node of a vehicle route.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_End(self, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetAllDimensionNames"><code class="name flex">
<span>def <span class="ident">GetAllDimensionNames</span></span>(<span>self) -> 'std::vector< std::string >'</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs the names of all dimensions added to the routing engine.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetAllDimensionNames(self) -&gt; &#34;std::vector&lt; std::string &gt;&#34;:
    r&#34;&#34;&#34; Outputs the names of all dimensions added to the routing engine.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetAllDimensionNames(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetAmortizedLinearCostFactorOfVehicles"><code class="name flex">
<span>def <span class="ident">GetAmortizedLinearCostFactorOfVehicles</span></span>(<span>self) -> 'std::vector< int64 > const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetAmortizedLinearCostFactorOfVehicles(self) -&gt; &#34;std::vector&lt; int64 &gt; const &amp;&#34;:
    return _pywrapcp.RoutingModel_GetAmortizedLinearCostFactorOfVehicles(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetAmortizedQuadraticCostFactorOfVehicles"><code class="name flex">
<span>def <span class="ident">GetAmortizedQuadraticCostFactorOfVehicles</span></span>(<span>self) -> 'std::vector< int64 > const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetAmortizedQuadraticCostFactorOfVehicles(self) -&gt; &#34;std::vector&lt; int64 &gt; const &amp;&#34;:
    return _pywrapcp.RoutingModel_GetAmortizedQuadraticCostFactorOfVehicles(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetArcCostForClass"><code class="name flex">
<span>def <span class="ident">GetArcCostForClass</span></span>(<span>self, from_index: int64, to_index: int64, cost_class_index: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the cost of the segment between two nodes for a given cost class. Input are variable indices of nodes and the cost class. Unlike GetArcCostForVehicle(), if cost_class is kNoCost, then the returned cost won't necessarily be zero: only some of the components of the cost that depend on the cost class will be omited. See the code for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetArcCostForClass(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;, cost_class_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the cost of the segment between two nodes for a given cost class. Input are variable indices of nodes and the cost class. Unlike GetArcCostForVehicle(), if cost_class is kNoCost, then the returned cost won&#39;t necessarily be zero: only some of the components of the cost that depend on the cost class will be omited. See the code for details.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetArcCostForClass(self, from_index, to_index, cost_class_index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetArcCostForFirstSolution"><code class="name flex">
<span>def <span class="ident">GetArcCostForFirstSolution</span></span>(<span>self, from_index: int64, to_index: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the cost of the arc in the context of the first solution strategy. This is typically a simplification of the actual cost; see the .cc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetArcCostForFirstSolution(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the cost of the arc in the context of the first solution strategy. This is typically a simplification of the actual cost; see the .cc.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetArcCostForFirstSolution(self, from_index, to_index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetArcCostForVehicle"><code class="name flex">
<span>def <span class="ident">GetArcCostForVehicle</span></span>(<span>self, from_index: int64, to_index: int64, vehicle: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the cost of the transit arc between two nodes for a given vehicle. Input are variable indices of node. This returns 0 if vehicle &lt; 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetArcCostForVehicle(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;, vehicle: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the cost of the transit arc between two nodes for a given vehicle. Input are variable indices of node. This returns 0 if vehicle &lt; 0.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetArcCostForVehicle(self, from_index, to_index, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetAutomaticFirstSolutionStrategy"><code class="name flex">
<span>def <span class="ident">GetAutomaticFirstSolutionStrategy</span></span>(<span>self) -> 'operations_research::FirstSolutionStrategy::Value'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the automatic first solution strategy selected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetAutomaticFirstSolutionStrategy(self) -&gt; &#34;operations_research::FirstSolutionStrategy::Value&#34;:
    r&#34;&#34;&#34; Returns the automatic first solution strategy selected.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetAutomaticFirstSolutionStrategy(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetCostClassIndexOfVehicle"><code class="name flex">
<span>def <span class="ident">GetCostClassIndexOfVehicle</span></span>(<span>self, vehicle: int64) -> 'operations_research::<a title="pywrapcp.RoutingModel" href="#pywrapcp.RoutingModel">RoutingModel</a>::CostClassIndex'</span>
</code></dt>
<dd>
<div class="desc"><p>Get the cost class index of the given vehicle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetCostClassIndexOfVehicle(self, vehicle: &#34;int64&#34;) -&gt; &#34;operations_research::RoutingModel::CostClassIndex&#34;:
    r&#34;&#34;&#34; Get the cost class index of the given vehicle.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetCostClassIndexOfVehicle(self, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetCostClassesCount"><code class="name flex">
<span>def <span class="ident">GetCostClassesCount</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of different cost classes in the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetCostClassesCount(self) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Returns the number of different cost classes in the model.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetCostClassesCount(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetDeliveryIndexPairs"><code class="name flex">
<span>def <span class="ident">GetDeliveryIndexPairs</span></span>(<span>self, node_index: int64) -> 'std::vector< std::pair< int,int > > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Same as above for deliveries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetDeliveryIndexPairs(self, node_index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&#34;:
    r&#34;&#34;&#34; Same as above for deliveries.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetDeliveryIndexPairs(self, node_index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetDepot"><code class="name flex">
<span>def <span class="ident">GetDepot</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the variable index of the first starting or ending node of all routes. If all routes start
and end at the same node (single depot), this is the node returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetDepot(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the variable index of the first starting or ending node of all routes. If all routes start  and end at the same node (single depot), this is the node returned.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetDepot(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetDimensionOrDie"><code class="name flex">
<span>def <span class="ident">GetDimensionOrDie</span></span>(<span>self, dimension_name: std::string const &) -> 'operations_research::<a title="pywrapcp.RoutingDimension" href="#pywrapcp.RoutingDimension">RoutingDimension</a> const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dimension from its name. Dies if the dimension does not exist.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetDimensionOrDie(self, dimension_name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::RoutingDimension const &amp;&#34;:
    r&#34;&#34;&#34; Returns a dimension from its name. Dies if the dimension does not exist.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetDimensionOrDie(self, dimension_name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetDimensions"><code class="name flex">
<span>def <span class="ident">GetDimensions</span></span>(<span>self) -> 'std::vector< operations_research::<a title="pywrapcp.RoutingDimension" href="#pywrapcp.RoutingDimension">RoutingDimension</a> * > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all dimensions of the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetDimensions(self) -&gt; &#34;std::vector&lt; operations_research::RoutingDimension * &gt; const &amp;&#34;:
    r&#34;&#34;&#34; Returns all dimensions of the model.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetDimensions(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetDimensionsWithSoftOrSpanCosts"><code class="name flex">
<span>def <span class="ident">GetDimensionsWithSoftOrSpanCosts</span></span>(<span>self) -> 'std::vector< operations_research::<a title="pywrapcp.RoutingDimension" href="#pywrapcp.RoutingDimension">RoutingDimension</a> * >'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns dimensions with soft or vehicle span costs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetDimensionsWithSoftOrSpanCosts(self) -&gt; &#34;std::vector&lt; operations_research::RoutingDimension * &gt;&#34;:
    r&#34;&#34;&#34; Returns dimensions with soft or vehicle span costs.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetDimensionsWithSoftOrSpanCosts(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetDisjunctionIndices"><code class="name flex">
<span>def <span class="ident">GetDisjunctionIndices</span></span>(<span>self, index: int64) -> 'std::vector< operations_research::<a title="pywrapcp.RoutingModel" href="#pywrapcp.RoutingModel">RoutingModel</a>::DisjunctionIndex > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the indices of the disjunctions to which an index belongs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetDisjunctionIndices(self, index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; operations_research::RoutingModel::DisjunctionIndex &gt; const &amp;&#34;:
    r&#34;&#34;&#34; Returns the indices of the disjunctions to which an index belongs.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetDisjunctionIndices(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetDisjunctionMaxCardinality"><code class="name flex">
<span>def <span class="ident">GetDisjunctionMaxCardinality</span></span>(<span>self, index: operations_research::RoutingModel::DisjunctionIndex) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the maximum number of possible active nodes of the node disjunction of index 'index'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetDisjunctionMaxCardinality(self, index: &#34;operations_research::RoutingModel::DisjunctionIndex&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the maximum number of possible active nodes of the node disjunction of index &#39;index&#39;.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetDisjunctionMaxCardinality(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetDisjunctionPenalty"><code class="name flex">
<span>def <span class="ident">GetDisjunctionPenalty</span></span>(<span>self, index: operations_research::RoutingModel::DisjunctionIndex) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the penalty of the node disjunction of index 'index'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetDisjunctionPenalty(self, index: &#34;operations_research::RoutingModel::DisjunctionIndex&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the penalty of the node disjunction of index &#39;index&#39;.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetDisjunctionPenalty(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetFixedCostOfVehicle"><code class="name flex">
<span>def <span class="ident">GetFixedCostOfVehicle</span></span>(<span>self, vehicle: int) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the route fixed cost taken into account if the route of the vehicle is not empty, aka there's at least one node on the route other than the first and last nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetFixedCostOfVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the route fixed cost taken into account if the route of the vehicle is not empty, aka there&#39;s at least one node on the route other than the first and last nodes.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetFixedCostOfVehicle(self, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetGlobalDimensionCumulOptimizers"><code class="name flex">
<span>def <span class="ident">GetGlobalDimensionCumulOptimizers</span></span>(<span>self) -> 'std::vector< std::unique_ptr< operations_research::GlobalDimensionCumulOptimizer > > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns [global|local]<em>dimension_optimizers</em>, which are empty if the model has not been closed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetGlobalDimensionCumulOptimizers(self) -&gt; &#34;std::vector&lt; std::unique_ptr&lt; operations_research::GlobalDimensionCumulOptimizer &gt; &gt; const &amp;&#34;:
    r&#34;&#34;&#34; Returns [global|local]_dimension_optimizers_, which are empty if the model has not been closed.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetGlobalDimensionCumulOptimizers(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetHardTypeIncompatibilitiesOfType"><code class="name flex">
<span>def <span class="ident">GetHardTypeIncompatibilitiesOfType</span></span>(<span>self, type: int) -> 'absl::flat_hash_set< int > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns visit types incompatible with a given type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetHardTypeIncompatibilitiesOfType(self, type: &#34;int&#34;) -&gt; &#34;absl::flat_hash_set&lt; int &gt; const &amp;&#34;:
    r&#34;&#34;&#34; Returns visit types incompatible with a given type.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetHardTypeIncompatibilitiesOfType(self, type)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetHomogeneousCost"><code class="name flex">
<span>def <span class="ident">GetHomogeneousCost</span></span>(<span>self, from_index: int64, to_index: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the cost of the segment between two nodes supposing all vehicle costs are the same (returns the cost for the first vehicle otherwise).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetHomogeneousCost(self, from_index: &#34;int64&#34;, to_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the cost of the segment between two nodes supposing all vehicle costs are the same (returns the cost for the first vehicle otherwise).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetHomogeneousCost(self, from_index, to_index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetLocalDimensionCumulMPOptimizers"><code class="name flex">
<span>def <span class="ident">GetLocalDimensionCumulMPOptimizers</span></span>(<span>self) -> 'std::vector< std::unique_ptr< operations_research::LocalDimensionCumulOptimizer > > const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetLocalDimensionCumulMPOptimizers(self) -&gt; &#34;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&#34;:
    return _pywrapcp.RoutingModel_GetLocalDimensionCumulMPOptimizers(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetLocalDimensionCumulOptimizers"><code class="name flex">
<span>def <span class="ident">GetLocalDimensionCumulOptimizers</span></span>(<span>self) -> 'std::vector< std::unique_ptr< operations_research::LocalDimensionCumulOptimizer > > const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetLocalDimensionCumulOptimizers(self) -&gt; &#34;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&#34;:
    return _pywrapcp.RoutingModel_GetLocalDimensionCumulOptimizers(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetMutableDimension"><code class="name flex">
<span>def <span class="ident">GetMutableDimension</span></span>(<span>self, dimension_name: std::string const &) -> 'operations_research::<a title="pywrapcp.RoutingDimension" href="#pywrapcp.RoutingDimension">RoutingDimension</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dimension from its name. Returns nullptr if the dimension does not exist.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetMutableDimension(self, dimension_name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::RoutingDimension *&#34;:
    r&#34;&#34;&#34; Returns a dimension from its name. Returns nullptr if the dimension does not exist.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetMutableDimension(self, dimension_name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetMutableGlobalCumulOptimizer"><code class="name flex">
<span>def <span class="ident">GetMutableGlobalCumulOptimizer</span></span>(<span>self, dimension: RoutingDimension) -> 'operations_research::GlobalDimensionCumulOptimizer *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the global/local dimension cumul optimizer for a given dimension, or nullptr if there is none.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetMutableGlobalCumulOptimizer(self, dimension: &#34;RoutingDimension&#34;) -&gt; &#34;operations_research::GlobalDimensionCumulOptimizer *&#34;:
    r&#34;&#34;&#34; Returns the global/local dimension cumul optimizer for a given dimension, or nullptr if there is none.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetMutableGlobalCumulOptimizer(self, dimension)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetMutableLocalCumulMPOptimizer"><code class="name flex">
<span>def <span class="ident">GetMutableLocalCumulMPOptimizer</span></span>(<span>self, dimension: RoutingDimension) -> 'operations_research::LocalDimensionCumulOptimizer *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetMutableLocalCumulMPOptimizer(self, dimension: &#34;RoutingDimension&#34;) -&gt; &#34;operations_research::LocalDimensionCumulOptimizer *&#34;:
    return _pywrapcp.RoutingModel_GetMutableLocalCumulMPOptimizer(self, dimension)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetMutableLocalCumulOptimizer"><code class="name flex">
<span>def <span class="ident">GetMutableLocalCumulOptimizer</span></span>(<span>self, dimension: RoutingDimension) -> 'operations_research::LocalDimensionCumulOptimizer *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetMutableLocalCumulOptimizer(self, dimension: &#34;RoutingDimension&#34;) -&gt; &#34;operations_research::LocalDimensionCumulOptimizer *&#34;:
    return _pywrapcp.RoutingModel_GetMutableLocalCumulOptimizer(self, dimension)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetNonZeroCostClassesCount"><code class="name flex">
<span>def <span class="ident">GetNonZeroCostClassesCount</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Ditto, minus the 'always zero', built-in cost class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetNonZeroCostClassesCount(self) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Ditto, minus the &#39;always zero&#39;, built-in cost class.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetNonZeroCostClassesCount(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetNumOfSingletonNodes"><code class="name flex">
<span>def <span class="ident">GetNumOfSingletonNodes</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of non-start/end nodes which do not appear in a pickup/delivery pair.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetNumOfSingletonNodes(self) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Returns the number of non-start/end nodes which do not appear in a pickup/delivery pair.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetNumOfSingletonNodes(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetNumberOfDecisionsInFirstSolution"><code class="name flex">
<span>def <span class="ident">GetNumberOfDecisionsInFirstSolution</span></span>(<span>self, search_parameters: operations_research::RoutingSearchParameters const &) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns statistics on first solution search, number of decisions sent to filters, number of decisions rejected by filters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetNumberOfDecisionsInFirstSolution(self, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns statistics on first solution search, number of decisions sent to filters, number of decisions rejected by filters.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetNumberOfDecisionsInFirstSolution(self, search_parameters)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetNumberOfDisjunctions"><code class="name flex">
<span>def <span class="ident">GetNumberOfDisjunctions</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of node disjunctions in the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetNumberOfDisjunctions(self) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Returns the number of node disjunctions in the model.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetNumberOfDisjunctions(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetNumberOfRejectsInFirstSolution"><code class="name flex">
<span>def <span class="ident">GetNumberOfRejectsInFirstSolution</span></span>(<span>self, search_parameters: operations_research::RoutingSearchParameters const &) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetNumberOfRejectsInFirstSolution(self, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;) -&gt; &#34;int64&#34;:
    return _pywrapcp.RoutingModel_GetNumberOfRejectsInFirstSolution(self, search_parameters)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetNumberOfVisitTypes"><code class="name flex">
<span>def <span class="ident">GetNumberOfVisitTypes</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetNumberOfVisitTypes(self) -&gt; &#34;int&#34;:
    return _pywrapcp.RoutingModel_GetNumberOfVisitTypes(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetPerfectBinaryDisjunctions"><code class="name flex">
<span>def <span class="ident">GetPerfectBinaryDisjunctions</span></span>(<span>self) -> 'std::vector< std::pair< int64,int64 > >'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list of all perfect binary disjunctions, as pairs of variable indices: a disjunction is "perfect" when its variables do not appear in any other disjunction. Each pair is sorted (lowest variable index first), and the output vector is also sorted (lowest pairs first).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetPerfectBinaryDisjunctions(self) -&gt; &#34;std::vector&lt; std::pair&lt; int64,int64 &gt; &gt;&#34;:
    r&#34;&#34;&#34; Returns the list of all perfect binary disjunctions, as pairs of variable indices: a disjunction is &#34;perfect&#34; when its variables do not appear in any other disjunction. Each pair is sorted (lowest variable index first), and the output vector is also sorted (lowest pairs first).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetPerfectBinaryDisjunctions(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetPickupAndDeliveryPolicyOfVehicle"><code class="name flex">
<span>def <span class="ident">GetPickupAndDeliveryPolicyOfVehicle</span></span>(<span>self, vehicle: int) -> 'operations_research::<a title="pywrapcp.RoutingModel" href="#pywrapcp.RoutingModel">RoutingModel</a>::PickupAndDeliveryPolicy'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetPickupAndDeliveryPolicyOfVehicle(self, vehicle: &#34;int&#34;) -&gt; &#34;operations_research::RoutingModel::PickupAndDeliveryPolicy&#34;:
    return _pywrapcp.RoutingModel_GetPickupAndDeliveryPolicyOfVehicle(self, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetPickupIndexPairs"><code class="name flex">
<span>def <span class="ident">GetPickupIndexPairs</span></span>(<span>self, node_index: int64) -> 'std::vector< std::pair< int,int > > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns pairs for which the node is a pickup; the first element of each pair is the index in the pickup and delivery pairs list in which the pickup appears, the second element is its index in the pickups list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetPickupIndexPairs(self, node_index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&#34;:
    r&#34;&#34;&#34; Returns pairs for which the node is a pickup; the first element of each pair is the index in the pickup and delivery pairs list in which the pickup appears, the second element is its index in the pickups list.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetPickupIndexPairs(self, node_index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetPrimaryConstrainedDimension"><code class="name flex">
<span>def <span class="ident">GetPrimaryConstrainedDimension</span></span>(<span>self) -> 'std::string const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Get the primary constrained dimension, or an empty string if it is unset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetPrimaryConstrainedDimension(self) -&gt; &#34;std::string const &amp;&#34;:
    r&#34;&#34;&#34; Get the primary constrained dimension, or an empty string if it is unset.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetPrimaryConstrainedDimension(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetRequiredTypeAlternativesWhenAddingType"><code class="name flex">
<span>def <span class="ident">GetRequiredTypeAlternativesWhenAddingType</span></span>(<span>self, type: int) -> 'std::vector< absl::flat_hash_set< int > > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the set of requirement alternatives when adding the given type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetRequiredTypeAlternativesWhenAddingType(self, type: &#34;int&#34;) -&gt; &#34;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&#34;:
    r&#34;&#34;&#34; Returns the set of requirement alternatives when adding the given type.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetRequiredTypeAlternativesWhenAddingType(self, type)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetRequiredTypeAlternativesWhenRemovingType"><code class="name flex">
<span>def <span class="ident">GetRequiredTypeAlternativesWhenRemovingType</span></span>(<span>self, type: int) -> 'std::vector< absl::flat_hash_set< int > > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the set of requirement alternatives when removing the given type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetRequiredTypeAlternativesWhenRemovingType(self, type: &#34;int&#34;) -&gt; &#34;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&#34;:
    r&#34;&#34;&#34; Returns the set of requirement alternatives when removing the given type.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetRequiredTypeAlternativesWhenRemovingType(self, type)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetSameVehicleIndicesOfIndex"><code class="name flex">
<span>def <span class="ident">GetSameVehicleIndicesOfIndex</span></span>(<span>self, node: int) -> 'std::vector< int > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns variable indices of nodes constrained to be on the same route.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetSameVehicleIndicesOfIndex(self, node: &#34;int&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
    r&#34;&#34;&#34; Returns variable indices of nodes constrained to be on the same route.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetSameVehicleIndicesOfIndex(self, node)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetSameVehicleRequiredTypeAlternativesOfType"><code class="name flex">
<span>def <span class="ident">GetSameVehicleRequiredTypeAlternativesOfType</span></span>(<span>self, type: int) -> 'std::vector< absl::flat_hash_set< int > > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the set of same-vehicle requirement alternatives for the given type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetSameVehicleRequiredTypeAlternativesOfType(self, type: &#34;int&#34;) -&gt; &#34;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&#34;:
    r&#34;&#34;&#34; Returns the set of same-vehicle requirement alternatives for the given type.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetSameVehicleRequiredTypeAlternativesOfType(self, type)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetTemporalTypeIncompatibilitiesOfType"><code class="name flex">
<span>def <span class="ident">GetTemporalTypeIncompatibilitiesOfType</span></span>(<span>self, type: int) -> 'absl::flat_hash_set< int > const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetTemporalTypeIncompatibilitiesOfType(self, type: &#34;int&#34;) -&gt; &#34;absl::flat_hash_set&lt; int &gt; const &amp;&#34;:
    return _pywrapcp.RoutingModel_GetTemporalTypeIncompatibilitiesOfType(self, type)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetVehicleClassIndexOfVehicle"><code class="name flex">
<span>def <span class="ident">GetVehicleClassIndexOfVehicle</span></span>(<span>self, vehicle: int64) -> 'operations_research::<a title="pywrapcp.RoutingModel" href="#pywrapcp.RoutingModel">RoutingModel</a>::VehicleClassIndex'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetVehicleClassIndexOfVehicle(self, vehicle: &#34;int64&#34;) -&gt; &#34;operations_research::RoutingModel::VehicleClassIndex&#34;:
    return _pywrapcp.RoutingModel_GetVehicleClassIndexOfVehicle(self, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetVehicleClassesCount"><code class="name flex">
<span>def <span class="ident">GetVehicleClassesCount</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of different vehicle classes in the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetVehicleClassesCount(self) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Returns the number of different vehicle classes in the model.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_GetVehicleClassesCount(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetVisitType"><code class="name flex">
<span>def <span class="ident">GetVisitType</span></span>(<span>self, index: int64) -> 'int'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetVisitType(self, index: &#34;int64&#34;) -&gt; &#34;int&#34;:
    return _pywrapcp.RoutingModel_GetVisitType(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.GetVisitTypePolicy"><code class="name flex">
<span>def <span class="ident">GetVisitTypePolicy</span></span>(<span>self, index: int64) -> 'operations_research::<a title="pywrapcp.RoutingModel" href="#pywrapcp.RoutingModel">RoutingModel</a>::VisitTypePolicy'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetVisitTypePolicy(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::RoutingModel::VisitTypePolicy&#34;:
    return _pywrapcp.RoutingModel_GetVisitTypePolicy(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.HasDimension"><code class="name flex">
<span>def <span class="ident">HasDimension</span></span>(<span>self, dimension_name: std::string const &) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if a dimension exists for a given dimension name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HasDimension(self, dimension_name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true if a dimension exists for a given dimension name.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_HasDimension(self, dimension_name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.HasHardTypeIncompatibilities"><code class="name flex">
<span>def <span class="ident">HasHardTypeIncompatibilities</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true iff any hard (resp. temporal) type incompatibilities have been added to the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HasHardTypeIncompatibilities(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true iff any hard (resp. temporal) type incompatibilities have been added to the model.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_HasHardTypeIncompatibilities(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.HasSameVehicleTypeRequirements"><code class="name flex">
<span>def <span class="ident">HasSameVehicleTypeRequirements</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true iff any same-route (resp. temporal) type requirements have been added to the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HasSameVehicleTypeRequirements(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true iff any same-route (resp. temporal) type requirements have been added to the model.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_HasSameVehicleTypeRequirements(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.HasTemporalTypeIncompatibilities"><code class="name flex">
<span>def <span class="ident">HasTemporalTypeIncompatibilities</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HasTemporalTypeIncompatibilities(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.RoutingModel_HasTemporalTypeIncompatibilities(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.HasTemporalTypeRequirements"><code class="name flex">
<span>def <span class="ident">HasTemporalTypeRequirements</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HasTemporalTypeRequirements(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.RoutingModel_HasTemporalTypeRequirements(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.HasTypeRegulations"><code class="name flex">
<span>def <span class="ident">HasTypeRegulations</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true iff the model has any incompatibilities or requirements set on node types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HasTypeRegulations(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true iff the model has any incompatibilities or requirements set on node types.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_HasTypeRegulations(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.HasVehicleWithCostClassIndex"><code class="name flex">
<span>def <span class="ident">HasVehicleWithCostClassIndex</span></span>(<span>self, cost_class_index: operations_research::RoutingModel::CostClassIndex) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true iff the model contains a vehicle with the given cost_class_index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HasVehicleWithCostClassIndex(self, cost_class_index: &#34;operations_research::RoutingModel::CostClassIndex&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true iff the model contains a vehicle with the given cost_class_index.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_HasVehicleWithCostClassIndex(self, cost_class_index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.IgnoreDisjunctionsAlreadyForcedToZero"><code class="name flex">
<span>def <span class="ident">IgnoreDisjunctionsAlreadyForcedToZero</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>SPECIAL: Makes the solver ignore all the disjunctions whose active variables are all trivially zero (i.e. Max() == 0), by setting their max_cardinality to 0. This can be useful when using the BaseBinaryDisjunctionNeighborhood operators, in the context of arc-based routing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IgnoreDisjunctionsAlreadyForcedToZero(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; SPECIAL: Makes the solver ignore all the disjunctions whose active variables are all trivially zero (i.e. Max() == 0), by setting their max_cardinality to 0. This can be useful when using the BaseBinaryDisjunctionNeighborhood operators, in the context of arc-based routing.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_IgnoreDisjunctionsAlreadyForcedToZero(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.IsEnd"><code class="name flex">
<span>def <span class="ident">IsEnd</span></span>(<span>self, index: int64) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if 'index' represents the last node of a route.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsEnd(self, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true if &#39;index&#39; represents the last node of a route.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_IsEnd(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.IsMatchingModel"><code class="name flex">
<span>def <span class="ident">IsMatchingModel</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if a vehicle/node matching problem is detected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsMatchingModel(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true if a vehicle/node matching problem is detected.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_IsMatchingModel(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.IsStart"><code class="name flex">
<span>def <span class="ident">IsStart</span></span>(<span>self, index: int64) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if 'index' represents the first node of a route.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsStart(self, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true if &#39;index&#39; represents the first node of a route.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_IsStart(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.IsVehicleAllowedForIndex"><code class="name flex">
<span>def <span class="ident">IsVehicleAllowedForIndex</span></span>(<span>self, vehicle: int, index: int64) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if a vehicle is allowed to visit a given node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsVehicleAllowedForIndex(self, vehicle: &#34;int&#34;, index: &#34;int64&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true if a vehicle is allowed to visit a given node.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_IsVehicleAllowedForIndex(self, vehicle, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.IsVehicleUsed"><code class="name flex">
<span>def <span class="ident">IsVehicleUsed</span></span>(<span>self, assignment: Assignment, vehicle: int) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the route of 'vehicle' is non empty in 'assignment'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsVehicleUsed(self, assignment: &#34;Assignment&#34;, vehicle: &#34;int&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true if the route of &#39;vehicle&#39; is non empty in &#39;assignment&#39;.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_IsVehicleUsed(self, assignment, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.MakeGuidedSlackFinalizer"><code class="name flex">
<span>def <span class="ident">MakeGuidedSlackFinalizer</span></span>(<span>self, dimension: RoutingDimension, initializer: std::function< int64 (int64) >) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>The next few members are in the public section only for testing purposes. MakeGuidedSlackFinalizer creates a DecisionBuilder for the slacks of a dimension using a callback to choose which values to start with. The finalizer works only when all next variables in the model have been fixed. It has the following two characteristics: 1. It follows the routes defined by the nexts variables when choosing a
variable to make a decision on. 2. When it comes to choose a value for the slack of node i, the decision
builder first calls the callback with argument i, and supposingly the
returned value is x it creates decisions slack[i] = x, slack[i] = x +
1, slack[i] = x - 1, slack[i] = x + 2, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MakeGuidedSlackFinalizer(self, dimension: &#34;RoutingDimension&#34;, initializer: &#34;std::function&lt; int64 (int64) &gt;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    r&#34;&#34;&#34; The next few members are in the public section only for testing purposes. MakeGuidedSlackFinalizer creates a DecisionBuilder for the slacks of a dimension using a callback to choose which values to start with. The finalizer works only when all next variables in the model have been fixed. It has the following two characteristics: 1. It follows the routes defined by the nexts variables when choosing a    variable to make a decision on. 2. When it comes to choose a value for the slack of node i, the decision    builder first calls the callback with argument i, and supposingly the    returned value is x it creates decisions slack[i] = x, slack[i] = x +    1, slack[i] = x - 1, slack[i] = x + 2, etc.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_MakeGuidedSlackFinalizer(self, dimension, initializer)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.MakePathSpansAndTotalSlacks"><code class="name flex">
<span>def <span class="ident">MakePathSpansAndTotalSlacks</span></span>(<span>self, dimension: RoutingDimension, spans: std::vector< operations_research::IntVar * >, total_slacks: std::vector< operations_research::IntVar * >) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>For every vehicle of the routing model: - if total_slacks[vehicle] is not nullptr, constrains it to be the sum of
slacks on that vehicle, that is,
dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start) -
sum_{node in path of vehicle} dimension-&gt;FixedTransitVar(node). - if spans[vehicle] is not nullptr, constrains it to be
dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start) This does stronger propagation than a decomposition, and takes breaks into account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MakePathSpansAndTotalSlacks(self, dimension: &#34;RoutingDimension&#34;, spans: &#34;std::vector&lt; operations_research::IntVar * &gt;&#34;, total_slacks: &#34;std::vector&lt; operations_research::IntVar * &gt;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; For every vehicle of the routing model: - if total_slacks[vehicle] is not nullptr, constrains it to be the sum of   slacks on that vehicle, that is,   dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start) -   sum_{node in path of vehicle} dimension-&gt;FixedTransitVar(node). - if spans[vehicle] is not nullptr, constrains it to be   dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start) This does stronger propagation than a decomposition, and takes breaks into account.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_MakePathSpansAndTotalSlacks(self, dimension, spans, total_slacks)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.MakeSelfDependentDimensionFinalizer"><code class="name flex">
<span>def <span class="ident">MakeSelfDependentDimensionFinalizer</span></span>(<span>self, dimension: RoutingDimension) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>MakeSelfDependentDimensionFinalizer is a finalizer for the slacks of a self-dependent dimension. It makes an extensive use of the caches of the state dependent transits. In detail, MakeSelfDependentDimensionFinalizer returns a composition of a local search decision builder with a greedy descent operator for the cumul of the start of each route and a guided slack finalizer. Provided there are no time windows and the maximum slacks are large enough, once the cumul of the start of route is fixed, the guided finalizer can find optimal values of the slacks for the rest of the route in time proportional to the length of the route. Therefore the composed finalizer generally works in time O(log(t)<em>n</em>m), where t is the latest possible departute time, n is the number of nodes in the network and m is the number of vehicles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MakeSelfDependentDimensionFinalizer(self, dimension: &#34;RoutingDimension&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    r&#34;&#34;&#34; MakeSelfDependentDimensionFinalizer is a finalizer for the slacks of a self-dependent dimension. It makes an extensive use of the caches of the state dependent transits. In detail, MakeSelfDependentDimensionFinalizer returns a composition of a local search decision builder with a greedy descent operator for the cumul of the start of each route and a guided slack finalizer. Provided there are no time windows and the maximum slacks are large enough, once the cumul of the start of route is fixed, the guided finalizer can find optimal values of the slacks for the rest of the route in time proportional to the length of the route. Therefore the composed finalizer generally works in time O(log(t)*n*m), where t is the latest possible departute time, n is the number of nodes in the network and m is the number of vehicles.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_MakeSelfDependentDimensionFinalizer(self, dimension)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.MutablePreAssignment"><code class="name flex">
<span>def <span class="ident">MutablePreAssignment</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MutablePreAssignment(self) -&gt; &#34;operations_research::Assignment *&#34;:
    return _pywrapcp.RoutingModel_MutablePreAssignment(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.Next"><code class="name flex">
<span>def <span class="ident">Next</span></span>(<span>self, assignment: Assignment, index: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Assignment inspection Returns the variable index of the node directly after the node corresponding to 'index' in 'assignment'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Next(self, assignment: &#34;Assignment&#34;, index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Assignment inspection Returns the variable index of the node directly after the node corresponding to &#39;index&#39; in &#39;assignment&#39;.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_Next(self, assignment, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.NextVar"><code class="name flex">
<span>def <span class="ident">NextVar</span></span>(<span>self, index: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the next variable of the node corresponding to index. Note that NextVar(index) == index is equivalent to ActiveVar(index) == 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NextVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; Returns the next variable of the node corresponding to index. Note that NextVar(index) == index is equivalent to ActiveVar(index) == 0.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_NextVar(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.PackCumulsOfOptimizerDimensionsFromAssignment"><code class="name flex">
<span>def <span class="ident">PackCumulsOfOptimizerDimensionsFromAssignment</span></span>(<span>self, original_assignment: Assignment, duration_limit: absl::Duration) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a> const *'</span>
</code></dt>
<dd>
<div class="desc"><p>For every dimension in the model with an optimizer in local/global_dimension_optimizers_, this method tries to pack the cumul values of the dimension, such that: - The cumul costs (span costs, soft lower and upper bound costs, etc) are
minimized. - The cumuls of the ends of the routes are minimized for this given
minimal cumul cost. - Given these minimal end cumuls, the route start cumuls are maximized. Returns the assignment resulting from allocating these packed cumuls with the solver, and nullptr if these cumuls could not be set by the solver.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PackCumulsOfOptimizerDimensionsFromAssignment(self, original_assignment: &#34;Assignment&#34;, duration_limit: &#34;absl::Duration&#34;) -&gt; &#34;operations_research::Assignment const *&#34;:
    r&#34;&#34;&#34; For every dimension in the model with an optimizer in local/global_dimension_optimizers_, this method tries to pack the cumul values of the dimension, such that: - The cumul costs (span costs, soft lower and upper bound costs, etc) are   minimized. - The cumuls of the ends of the routes are minimized for this given   minimal cumul cost. - Given these minimal end cumuls, the route start cumuls are maximized. Returns the assignment resulting from allocating these packed cumuls with the solver, and nullptr if these cumuls could not be set by the solver.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_PackCumulsOfOptimizerDimensionsFromAssignment(self, original_assignment, duration_limit)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.PreAssignment"><code class="name flex">
<span>def <span class="ident">PreAssignment</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a> const *const'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an assignment used to fix some of the variables of the problem. In practice, this assignment locks partial routes of the problem. This can be used in the context of locking the parts of the routes which have already been driven in online routing problems.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PreAssignment(self) -&gt; &#34;operations_research::Assignment const *const&#34;:
    r&#34;&#34;&#34; Returns an assignment used to fix some of the variables of the problem. In practice, this assignment locks partial routes of the problem. This can be used in the context of locking the parts of the routes which have already been driven in online routing problems.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_PreAssignment(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.ReadAssignment"><code class="name flex">
<span>def <span class="ident">ReadAssignment</span></span>(<span>self, file_name: std::string const &) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Reads an assignment from a file and returns the current solution. Returns nullptr if the file cannot be opened or if the assignment is not valid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ReadAssignment(self, file_name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
    r&#34;&#34;&#34; Reads an assignment from a file and returns the current solution. Returns nullptr if the file cannot be opened or if the assignment is not valid.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_ReadAssignment(self, file_name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.ReadAssignmentFromRoutes"><code class="name flex">
<span>def <span class="ident">ReadAssignmentFromRoutes</span></span>(<span>self, routes: std::vector< std::vector< int64 > > const &, ignore_inactive_indices: bool) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Restores the routes as the current solution. Returns nullptr if the solution cannot be restored (routes do not contain a valid solution). Note that calling this method will run the solver to assign values to the dimension variables; this may take considerable amount of time, especially when using dimensions with slack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ReadAssignmentFromRoutes(self, routes: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; const &amp;&#34;, ignore_inactive_indices: &#34;bool&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
    r&#34;&#34;&#34; Restores the routes as the current solution. Returns nullptr if the solution cannot be restored (routes do not contain a valid solution). Note that calling this method will run the solver to assign values to the dimension variables; this may take considerable amount of time, especially when using dimensions with slack.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_ReadAssignmentFromRoutes(self, routes, ignore_inactive_indices)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.RegisterPositiveTransitCallback"><code class="name flex">
<span>def <span class="ident">RegisterPositiveTransitCallback</span></span>(<span>self, callback: operations_research::RoutingModel::TransitCallback2) -> 'int'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RegisterPositiveTransitCallback(self, callback: &#34;operations_research::RoutingModel::TransitCallback2&#34;) -&gt; &#34;int&#34;:
    return _pywrapcp.RoutingModel_RegisterPositiveTransitCallback(self, callback)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.RegisterPositiveUnaryTransitCallback"><code class="name flex">
<span>def <span class="ident">RegisterPositiveUnaryTransitCallback</span></span>(<span>self, callback: operations_research::RoutingModel::TransitCallback1) -> 'int'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RegisterPositiveUnaryTransitCallback(self, callback: &#34;operations_research::RoutingModel::TransitCallback1&#34;) -&gt; &#34;int&#34;:
    return _pywrapcp.RoutingModel_RegisterPositiveUnaryTransitCallback(self, callback)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.RegisterTransitCallback"><code class="name flex">
<span>def <span class="ident">RegisterTransitCallback</span></span>(<span>self, callback: operations_research::RoutingModel::TransitCallback2) -> 'int'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RegisterTransitCallback(self, callback: &#34;operations_research::RoutingModel::TransitCallback2&#34;) -&gt; &#34;int&#34;:
    return _pywrapcp.RoutingModel_RegisterTransitCallback(self, callback)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.RegisterUnaryTransitCallback"><code class="name flex">
<span>def <span class="ident">RegisterUnaryTransitCallback</span></span>(<span>self, callback: operations_research::RoutingModel::TransitCallback1) -> 'int'</span>
</code></dt>
<dd>
<div class="desc"><p>Registers 'callback' and returns its index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RegisterUnaryTransitCallback(self, callback: &#34;operations_research::RoutingModel::TransitCallback1&#34;) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Registers &#39;callback&#39; and returns its index.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_RegisterUnaryTransitCallback(self, callback)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.RemainingTime"><code class="name flex">
<span>def <span class="ident">RemainingTime</span></span>(<span>self) -> 'absl::Duration'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the time left in the search limit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RemainingTime(self) -&gt; &#34;absl::Duration&#34;:
    r&#34;&#34;&#34; Returns the time left in the search limit.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_RemainingTime(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.RestoreAssignment"><code class="name flex">
<span>def <span class="ident">RestoreAssignment</span></span>(<span>self, solution: Assignment) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Restores an assignment as a solution in the routing model and returns the new solution. Returns nullptr if the assignment is not valid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RestoreAssignment(self, solution: &#34;Assignment&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
    r&#34;&#34;&#34; Restores an assignment as a solution in the routing model and returns the new solution. Returns nullptr if the assignment is not valid.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_RestoreAssignment(self, solution)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.RoutesToAssignment"><code class="name flex">
<span>def <span class="ident">RoutesToAssignment</span></span>(<span>self, routes: std::vector< std::vector< int64 > > const &, ignore_inactive_indices: bool, close_routes: bool, assignment: Assignment) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Fills an assignment from a specification of the routes of the vehicles. The routes are specified as lists of variable indices that appear on the routes of the vehicles. The indices of the outer vector in 'routes' correspond to vehicles IDs, the inner vector contains the variable indices on the routes for the given vehicle. The inner vectors must not contain the start and end indices, as these are determined by the routing model.
Sets the value of NextVars in the assignment, adding the variables to the assignment if necessary. The method does not touch other variables in the assignment. The method can only be called after the model is closed.
With ignore_inactive_indices set to false, this method will fail (return nullptr) in case some of the route contain indices that are deactivated in the model; when set to true, these indices will be skipped.
Returns true if routes were successfully loaded. However, such assignment still might not be a valid solution to the routing problem due to more complex constraints; it is advisible to call solver()-&gt;CheckSolution() afterwards.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RoutesToAssignment(self, routes: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; const &amp;&#34;, ignore_inactive_indices: &#34;bool&#34;, close_routes: &#34;bool&#34;, assignment: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Fills an assignment from a specification of the routes of the vehicles. The routes are specified as lists of variable indices that appear on the routes of the vehicles. The indices of the outer vector in &#39;routes&#39; correspond to vehicles IDs, the inner vector contains the variable indices on the routes for the given vehicle. The inner vectors must not contain the start and end indices, as these are determined by the routing model.  Sets the value of NextVars in the assignment, adding the variables to the assignment if necessary. The method does not touch other variables in the assignment. The method can only be called after the model is closed.  With ignore_inactive_indices set to false, this method will fail (return nullptr) in case some of the route contain indices that are deactivated in the model; when set to true, these indices will be skipped.  Returns true if routes were successfully loaded. However, such assignment still might not be a valid solution to the routing problem due to more complex constraints; it is advisible to call solver()-&gt;CheckSolution() afterwards.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_RoutesToAssignment(self, routes, ignore_inactive_indices, close_routes, assignment)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SetAllowedVehiclesForIndex"><code class="name flex">
<span>def <span class="ident">SetAllowedVehiclesForIndex</span></span>(<span>self, vehicles: std::vector< int > const &, index: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the vehicles which can visit a given node. If the node is in a disjunction, this will not prevent it from being unperformed. Specifying an empty vector of vehicles has no effect (all vehicles will be allowed to visit the node).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetAllowedVehiclesForIndex(self, vehicles: &#34;std::vector&lt; int &gt; const &amp;&#34;, index: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets the vehicles which can visit a given node. If the node is in a disjunction, this will not prevent it from being unperformed. Specifying an empty vector of vehicles has no effect (all vehicles will be allowed to visit the node).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_SetAllowedVehiclesForIndex(self, vehicles, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SetAmortizedCostFactorsOfAllVehicles"><code class="name flex">
<span>def <span class="ident">SetAmortizedCostFactorsOfAllVehicles</span></span>(<span>self, linear_cost_factor: int64, quadratic_cost_factor: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>The following methods set the linear and quadratic cost factors of vehicles (must be positive values). The default value of these parameters is zero for all vehicles. When set, the cost_ of the model will contain terms aiming at reducing the number of vehicles used in the model, by adding the following to the objective for every vehicle v: INDICATOR(v used in the model) *
[linear_cost_factor_of_vehicle_[v]
- quadratic_cost_factor_of_vehicle_[v]*(square of length of route v)] i.e. for every used vehicle, we add the linear factor as fixed cost, and subtract the square of the route length multiplied by the quadratic factor. This second term aims at making the routes as dense as possible. Sets the linear and quadratic cost factor of all vehicles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetAmortizedCostFactorsOfAllVehicles(self, linear_cost_factor: &#34;int64&#34;, quadratic_cost_factor: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; The following methods set the linear and quadratic cost factors of vehicles (must be positive values). The default value of these parameters is zero for all vehicles. When set, the cost_ of the model will contain terms aiming at reducing the number of vehicles used in the model, by adding the following to the objective for every vehicle v: INDICATOR(v used in the model) *   [linear_cost_factor_of_vehicle_[v]    - quadratic_cost_factor_of_vehicle_[v]*(square of length of route v)] i.e. for every used vehicle, we add the linear factor as fixed cost, and subtract the square of the route length multiplied by the quadratic factor. This second term aims at making the routes as dense as possible. Sets the linear and quadratic cost factor of all vehicles.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_SetAmortizedCostFactorsOfAllVehicles(self, linear_cost_factor, quadratic_cost_factor)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SetAmortizedCostFactorsOfVehicle"><code class="name flex">
<span>def <span class="ident">SetAmortizedCostFactorsOfVehicle</span></span>(<span>self, linear_cost_factor: int64, quadratic_cost_factor: int64, vehicle: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the linear and quadratic cost factor of the given vehicle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetAmortizedCostFactorsOfVehicle(self, linear_cost_factor: &#34;int64&#34;, quadratic_cost_factor: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets the linear and quadratic cost factor of the given vehicle.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_SetAmortizedCostFactorsOfVehicle(self, linear_cost_factor, quadratic_cost_factor, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SetArcCostEvaluatorOfAllVehicles"><code class="name flex">
<span>def <span class="ident">SetArcCostEvaluatorOfAllVehicles</span></span>(<span>self, evaluator_index: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the cost function of the model such that the cost of a segment of a route between node 'from' and 'to' is evaluator(from, to), whatever the route or vehicle performing the route.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetArcCostEvaluatorOfAllVehicles(self, evaluator_index: &#34;int&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets the cost function of the model such that the cost of a segment of a route between node &#39;from&#39; and &#39;to&#39; is evaluator(from, to), whatever the route or vehicle performing the route.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_SetArcCostEvaluatorOfAllVehicles(self, evaluator_index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SetArcCostEvaluatorOfVehicle"><code class="name flex">
<span>def <span class="ident">SetArcCostEvaluatorOfVehicle</span></span>(<span>self, evaluator_index: int, vehicle: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the cost function for a given vehicle route.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetArcCostEvaluatorOfVehicle(self, evaluator_index: &#34;int&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets the cost function for a given vehicle route.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_SetArcCostEvaluatorOfVehicle(self, evaluator_index, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SetAssignmentFromOtherModelAssignment"><code class="name flex">
<span>def <span class="ident">SetAssignmentFromOtherModelAssignment</span></span>(<span>self, target_assignment: Assignment, source_model: RoutingModel, source_assignment: Assignment) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Given a "source_model" and its "source_assignment", resets "target_assignment" with the IntVar variables (nexts_, and vehicle_vars_ if costs aren't homogeneous across vehicles) of "this" model, with the values set according to those in "other_assignment". The objective_element of target_assignment is set to this-&gt;cost_.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetAssignmentFromOtherModelAssignment(self, target_assignment: &#34;Assignment&#34;, source_model: &#34;RoutingModel&#34;, source_assignment: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Given a &#34;source_model&#34; and its &#34;source_assignment&#34;, resets &#34;target_assignment&#34; with the IntVar variables (nexts_, and vehicle_vars_ if costs aren&#39;t homogeneous across vehicles) of &#34;this&#34; model, with the values set according to those in &#34;other_assignment&#34;. The objective_element of target_assignment is set to this-&gt;cost_.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_SetAssignmentFromOtherModelAssignment(self, target_assignment, source_model, source_assignment)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SetFirstSolutionEvaluator"><code class="name flex">
<span>def <span class="ident">SetFirstSolutionEvaluator</span></span>(<span>self, evaluator: operations_research::Solver::IndexEvaluator2) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Gets/sets the evaluator used during the search. Only relevant when RoutingSearchParameters.first_solution_strategy = EVALUATOR_STRATEGY. Takes ownership of evaluator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetFirstSolutionEvaluator(self, evaluator: &#34;operations_research::Solver::IndexEvaluator2&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Gets/sets the evaluator used during the search. Only relevant when RoutingSearchParameters.first_solution_strategy = EVALUATOR_STRATEGY. Takes ownership of evaluator.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_SetFirstSolutionEvaluator(self, evaluator)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SetFixedCostOfAllVehicles"><code class="name flex">
<span>def <span class="ident">SetFixedCostOfAllVehicles</span></span>(<span>self, cost: int64) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the fixed cost of all vehicle routes. It is equivalent to calling SetFixedCostOfVehicle on all vehicle routes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetFixedCostOfAllVehicles(self, cost: &#34;int64&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets the fixed cost of all vehicle routes. It is equivalent to calling SetFixedCostOfVehicle on all vehicle routes.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_SetFixedCostOfAllVehicles(self, cost)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SetFixedCostOfVehicle"><code class="name flex">
<span>def <span class="ident">SetFixedCostOfVehicle</span></span>(<span>self, cost: int64, vehicle: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the fixed cost of one vehicle route.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetFixedCostOfVehicle(self, cost: &#34;int64&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets the fixed cost of one vehicle route.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_SetFixedCostOfVehicle(self, cost, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SetPickupAndDeliveryPolicyOfAllVehicles"><code class="name flex">
<span>def <span class="ident">SetPickupAndDeliveryPolicyOfAllVehicles</span></span>(<span>self, policy: operations_research::RoutingModel::PickupAndDeliveryPolicy) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the Pickup and delivery policy of all vehicles. It is equivalent to calling SetPickupAndDeliveryPolicyOfVehicle on all vehicles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetPickupAndDeliveryPolicyOfAllVehicles(self, policy: &#34;operations_research::RoutingModel::PickupAndDeliveryPolicy&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Sets the Pickup and delivery policy of all vehicles. It is equivalent to calling SetPickupAndDeliveryPolicyOfVehicle on all vehicles.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_SetPickupAndDeliveryPolicyOfAllVehicles(self, policy)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SetPickupAndDeliveryPolicyOfVehicle"><code class="name flex">
<span>def <span class="ident">SetPickupAndDeliveryPolicyOfVehicle</span></span>(<span>self, policy: operations_research::RoutingModel::PickupAndDeliveryPolicy, vehicle: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetPickupAndDeliveryPolicyOfVehicle(self, policy: &#34;operations_research::RoutingModel::PickupAndDeliveryPolicy&#34;, vehicle: &#34;int&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.RoutingModel_SetPickupAndDeliveryPolicyOfVehicle(self, policy, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SetPrimaryConstrainedDimension"><code class="name flex">
<span>def <span class="ident">SetPrimaryConstrainedDimension</span></span>(<span>self, dimension_name: std::string const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Set the given dimension as "primary constrained". As of August 2013, this is only used by ArcIsMoreConstrainedThanArc(). "dimension" must be the name of an existing dimension, or be empty, in which case there will not be a primary dimension after this call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetPrimaryConstrainedDimension(self, dimension_name: &#34;std::string const &amp;&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Set the given dimension as &#34;primary constrained&#34;. As of August 2013, this is only used by ArcIsMoreConstrainedThanArc(). &#34;dimension&#34; must be the name of an existing dimension, or be empty, in which case there will not be a primary dimension after this call.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_SetPrimaryConstrainedDimension(self, dimension_name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SetVisitType"><code class="name flex">
<span>def <span class="ident">SetVisitType</span></span>(<span>self, index: int64, type: int, type_policy: operations_research::RoutingModel::VisitTypePolicy) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetVisitType(self, index: &#34;int64&#34;, type: &#34;int&#34;, type_policy: &#34;operations_research::RoutingModel::VisitTypePolicy&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.RoutingModel_SetVisitType(self, index, type, type_policy)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.Size"><code class="name flex">
<span>def <span class="ident">Size</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of next variables in the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Size(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the number of next variables in the model.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_Size(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.Solve"><code class="name flex">
<span>def <span class="ident">Solve</span></span>(<span>self, assignment: Assignment = None) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a> const *'</span>
</code></dt>
<dd>
<div class="desc"><p>Solves the current routing model; closes the current model. This is equivalent to calling SolveWithParameters(DefaultRoutingSearchParameters()) or SolveFromAssignmentWithParameters(assignment,
DefaultRoutingSearchParameters()).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Solve(self, assignment: &#34;Assignment&#34;=None) -&gt; &#34;operations_research::Assignment const *&#34;:
    r&#34;&#34;&#34; Solves the current routing model; closes the current model. This is equivalent to calling SolveWithParameters(DefaultRoutingSearchParameters()) or SolveFromAssignmentWithParameters(assignment,                                   DefaultRoutingSearchParameters()).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_Solve(self, assignment)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SolveFromAssignmentWithParameters"><code class="name flex">
<span>def <span class="ident">SolveFromAssignmentWithParameters</span></span>(<span>self, assignment: Assignment, search_parameters: operations_research::RoutingSearchParameters const &, solutions: std::vector< operations_research::Assignment const * > * = None) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a> const *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SolveFromAssignmentWithParameters(self, assignment: &#34;Assignment&#34;, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;, solutions: &#34;std::vector&lt; operations_research::Assignment const * &gt; *&#34;=None) -&gt; &#34;operations_research::Assignment const *&#34;:
    return _pywrapcp.RoutingModel_SolveFromAssignmentWithParameters(self, assignment, search_parameters, solutions)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.SolveWithParameters"><code class="name flex">
<span>def <span class="ident">SolveWithParameters</span></span>(<span>self, search_parameters: operations_research::RoutingSearchParameters const &, solutions: std::vector< operations_research::Assignment const * > * = None) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a> const *'</span>
</code></dt>
<dd>
<div class="desc"><p>Solves the current routing model with the given parameters. If 'solutions' is specified, it will contain the k best solutions found during the search (from worst to best, including the one returned by this method), where k corresponds to the 'number_of_solutions_to_collect' in 'search_parameters'. Note that the Assignment returned by the method and the ones in solutions are owned by the underlying solver and should not be deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SolveWithParameters(self, search_parameters: &#34;operations_research::RoutingSearchParameters const &amp;&#34;, solutions: &#34;std::vector&lt; operations_research::Assignment const * &gt; *&#34;=None) -&gt; &#34;operations_research::Assignment const *&#34;:
    r&#34;&#34;&#34; Solves the current routing model with the given parameters. If &#39;solutions&#39; is specified, it will contain the k best solutions found during the search (from worst to best, including the one returned by this method), where k corresponds to the &#39;number_of_solutions_to_collect&#39; in &#39;search_parameters&#39;. Note that the Assignment returned by the method and the ones in solutions are owned by the underlying solver and should not be deleted.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_SolveWithParameters(self, search_parameters, solutions)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.Start"><code class="name flex">
<span>def <span class="ident">Start</span></span>(<span>self, vehicle: int) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Model inspection. Returns the variable index of the starting node of a vehicle route.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Start(self, vehicle: &#34;int&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Model inspection. Returns the variable index of the starting node of a vehicle route.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_Start(self, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.TransitCallback"><code class="name flex">
<span>def <span class="ident">TransitCallback</span></span>(<span>self, callback_index: int) -> 'operations_research::<a title="pywrapcp.RoutingModel" href="#pywrapcp.RoutingModel">RoutingModel</a>::TransitCallback2 const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TransitCallback(self, callback_index: &#34;int&#34;) -&gt; &#34;operations_research::RoutingModel::TransitCallback2 const &amp;&#34;:
    return _pywrapcp.RoutingModel_TransitCallback(self, callback_index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.UnaryTransitCallbackOrNull"><code class="name flex">
<span>def <span class="ident">UnaryTransitCallbackOrNull</span></span>(<span>self, callback_index: int) -> 'operations_research::<a title="pywrapcp.RoutingModel" href="#pywrapcp.RoutingModel">RoutingModel</a>::TransitCallback1 const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UnaryTransitCallbackOrNull(self, callback_index: &#34;int&#34;) -&gt; &#34;operations_research::RoutingModel::TransitCallback1 const &amp;&#34;:
    return _pywrapcp.RoutingModel_UnaryTransitCallbackOrNull(self, callback_index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.UnperformedPenalty"><code class="name flex">
<span>def <span class="ident">UnperformedPenalty</span></span>(<span>self, var_index: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Get the "unperformed" penalty of a node. This is only well defined if the node is only part of a single Disjunction involving only itself, and that disjunction has a penalty. In all other cases, including forced active nodes, this returns 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UnperformedPenalty(self, var_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Get the &#34;unperformed&#34; penalty of a node. This is only well defined if the node is only part of a single Disjunction involving only itself, and that disjunction has a penalty. In all other cases, including forced active nodes, this returns 0.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_UnperformedPenalty(self, var_index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.UnperformedPenaltyOrValue"><code class="name flex">
<span>def <span class="ident">UnperformedPenaltyOrValue</span></span>(<span>self, default_value: int64, var_index: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Same as above except that it returns default_value instead of 0 when penalty is not well defined (default value is passed as first argument to simplify the usage of the method in a callback).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UnperformedPenaltyOrValue(self, default_value: &#34;int64&#34;, var_index: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Same as above except that it returns default_value instead of 0 when penalty is not well defined (default value is passed as first argument to simplify the usage of the method in a callback).&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_UnperformedPenaltyOrValue(self, default_value, var_index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.VehicleCostsConsideredVar"><code class="name flex">
<span>def <span class="ident">VehicleCostsConsideredVar</span></span>(<span>self, vehicle: int) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the variable specifying whether or not costs are considered for vehicle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VehicleCostsConsideredVar(self, vehicle: &#34;int&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; Returns the variable specifying whether or not costs are considered for vehicle.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_VehicleCostsConsideredVar(self, vehicle)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.VehicleIndex"><code class="name flex">
<span>def <span class="ident">VehicleIndex</span></span>(<span>self, index: int) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the vehicle of the given start/end index, and -1 if the given index is not a vehicle start/end.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VehicleIndex(self, index: &#34;int&#34;) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Returns the vehicle of the given start/end index, and -1 if the given index is not a vehicle start/end.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_VehicleIndex(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.VehicleVar"><code class="name flex">
<span>def <span class="ident">VehicleVar</span></span>(<span>self, index: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the vehicle variable of the node corresponding to index. Note that VehicleVar(index) == -1 is equivalent to ActiveVar(index) == 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VehicleVar(self, index: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; Returns the vehicle variable of the node corresponding to index. Note that VehicleVar(index) == -1 is equivalent to ActiveVar(index) == 0.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_VehicleVar(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.WriteAssignment"><code class="name flex">
<span>def <span class="ident">WriteAssignment</span></span>(<span>self, file_name: std::string const &) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the current solution to a file containing an AssignmentProto. Returns false if the file cannot be opened or if there is no current solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WriteAssignment(self, file_name: &#34;std::string const &amp;&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Writes the current solution to a file containing an AssignmentProto. Returns false if the file cannot be opened or if there is no current solution.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_WriteAssignment(self, file_name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.nodes"><code class="name flex">
<span>def <span class="ident">nodes</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Sizes and indices Returns the number of nodes in the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nodes(self) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Sizes and indices Returns the number of nodes in the model.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_nodes(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.solver"><code class="name flex">
<span>def <span class="ident">solver</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Solver" href="#pywrapcp.Solver">Solver</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the underlying constraint solver. Can be used to add extra constraints and/or modify search algoithms.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solver(self) -&gt; &#34;operations_research::Solver *&#34;:
    r&#34;&#34;&#34; Returns the underlying constraint solver. Can be used to add extra constraints and/or modify search algoithms.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_solver(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.status"><code class="name flex">
<span>def <span class="ident">status</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.RoutingModel" href="#pywrapcp.RoutingModel">RoutingModel</a>::Status'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current status of the routing model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def status(self) -&gt; &#34;operations_research::RoutingModel::Status&#34;:
    r&#34;&#34;&#34; Returns the current status of the routing model.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_status(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.RoutingModel.vehicles"><code class="name flex">
<span>def <span class="ident">vehicles</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of vehicle routes in the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vehicles(self) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Returns the number of vehicle routes in the model.&#34;&#34;&#34;
    return _pywrapcp.RoutingModel_vehicles(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywrapcp.RoutingModelVisitor"><code class="flex name class">
<span>class <span class="ident">RoutingModelVisitor</span></span>
</code></dt>
<dd>
<div class="desc"><p>Routing model visitor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoutingModelVisitor(BaseObject):
    r&#34;&#34;&#34; Routing model visitor.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self):
        _pywrapcp.RoutingModelVisitor_swiginit(self, _pywrapcp.new_RoutingModelVisitor())
    __swig_destroy__ = _pywrapcp.delete_RoutingModelVisitor</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pywrapcp.RoutingModelVisitor.kLightElement"><code class="name">var <span class="ident">kLightElement</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.RoutingModelVisitor.kLightElement2"><code class="name">var <span class="ident">kLightElement2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.RoutingModelVisitor.kRemoveValues"><code class="name">var <span class="ident">kRemoveValues</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.BaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.SearchLimit"><code class="flex name class">
<span>class <span class="ident">SearchLimit</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class of all search limits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SearchLimit(SearchMonitor):
    r&#34;&#34;&#34; Base class of all search limits.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_SearchLimit

    def Crossed(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if the limit has been crossed.&#34;&#34;&#34;
        return _pywrapcp.SearchLimit_Crossed(self)

    def Check(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; This method is called to check the status of the limit. A return value of true indicates that we have indeed crossed the limit. In that case, this method will not be called again and the remaining search will be discarded.&#34;&#34;&#34;
        return _pywrapcp.SearchLimit_Check(self)

    def Init(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method is called when the search limit is initialized.&#34;&#34;&#34;
        return _pywrapcp.SearchLimit_Init(self)

    def EnterSearch(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Internal methods.&#34;&#34;&#34;
        return _pywrapcp.SearchLimit_EnterSearch(self)

    def BeginNextDecision(self, b: &#34;DecisionBuilder&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SearchLimit_BeginNextDecision(self, b)

    def RefuteDecision(self, d: &#34;Decision&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SearchLimit_RefuteDecision(self, d)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SearchLimit_DebugString(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.SearchLimit.Check"><code class="name flex">
<span>def <span class="ident">Check</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>This method is called to check the status of the limit. A return value of true indicates that we have indeed crossed the limit. In that case, this method will not be called again and the remaining search will be discarded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Check(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; This method is called to check the status of the limit. A return value of true indicates that we have indeed crossed the limit. In that case, this method will not be called again and the remaining search will be discarded.&#34;&#34;&#34;
    return _pywrapcp.SearchLimit_Check(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchLimit.Crossed"><code class="name flex">
<span>def <span class="ident">Crossed</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if the limit has been crossed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Crossed(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Returns true if the limit has been crossed.&#34;&#34;&#34;
    return _pywrapcp.SearchLimit_Crossed(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchLimit.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.SearchLimit_DebugString(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchLimit.EnterSearch"><code class="name flex">
<span>def <span class="ident">EnterSearch</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Internal methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EnterSearch(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Internal methods.&#34;&#34;&#34;
    return _pywrapcp.SearchLimit_EnterSearch(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchLimit.Init"><code class="name flex">
<span>def <span class="ident">Init</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method is called when the search limit is initialized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Init(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method is called when the search limit is initialized.&#34;&#34;&#34;
    return _pywrapcp.SearchLimit_Init(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.SearchMonitor.AcceptNeighbor" href="#pywrapcp.SearchMonitor.AcceptNeighbor">AcceptNeighbor</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.AcceptSolution" href="#pywrapcp.SearchMonitor.AcceptSolution">AcceptSolution</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.AfterDecision" href="#pywrapcp.SearchMonitor.AfterDecision">AfterDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.ApplyDecision" href="#pywrapcp.SearchMonitor.ApplyDecision">ApplyDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.AtSolution" href="#pywrapcp.SearchMonitor.AtSolution">AtSolution</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.BeginFail" href="#pywrapcp.SearchMonitor.BeginFail">BeginFail</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.BeginInitialPropagation" href="#pywrapcp.SearchMonitor.BeginInitialPropagation">BeginInitialPropagation</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.BeginNextDecision" href="#pywrapcp.SearchMonitor.BeginNextDecision">BeginNextDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EndFail" href="#pywrapcp.SearchMonitor.EndFail">EndFail</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EndInitialPropagation" href="#pywrapcp.SearchMonitor.EndInitialPropagation">EndInitialPropagation</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EndNextDecision" href="#pywrapcp.SearchMonitor.EndNextDecision">EndNextDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.ExitSearch" href="#pywrapcp.SearchMonitor.ExitSearch">ExitSearch</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.LocalOptimum" href="#pywrapcp.SearchMonitor.LocalOptimum">LocalOptimum</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.NoMoreSolutions" href="#pywrapcp.SearchMonitor.NoMoreSolutions">NoMoreSolutions</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.RefuteDecision" href="#pywrapcp.SearchMonitor.RefuteDecision">RefuteDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.RestartSearch" href="#pywrapcp.SearchMonitor.RestartSearch">RestartSearch</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.SearchMonitor"><code class="flex name class">
<span>class <span class="ident">SearchMonitor</span></span>
<span>(</span><span>s: Solver)</span>
</code></dt>
<dd>
<div class="desc"><p>A search monitor is a simple set of callbacks to monitor all search events</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SearchMonitor(BaseObject):
    r&#34;&#34;&#34; A search monitor is a simple set of callbacks to monitor all search events&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, s: &#34;Solver&#34;):
        if self.__class__ == SearchMonitor:
            _self = None
        else:
            _self = self
        _pywrapcp.SearchMonitor_swiginit(self, _pywrapcp.new_SearchMonitor(_self, s))
    __swig_destroy__ = _pywrapcp.delete_SearchMonitor

    def EnterSearch(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Beginning of the search.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_EnterSearch(self)

    def RestartSearch(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Restart the search.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_RestartSearch(self)

    def ExitSearch(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; End of the search.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_ExitSearch(self)

    def BeginNextDecision(self, b: &#34;DecisionBuilder&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Before calling DecisionBuilder::Next.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_BeginNextDecision(self, b)

    def EndNextDecision(self, b: &#34;DecisionBuilder&#34;, d: &#34;Decision&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; After calling DecisionBuilder::Next, along with the returned decision.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_EndNextDecision(self, b, d)

    def ApplyDecision(self, d: &#34;Decision&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Before applying the decision.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_ApplyDecision(self, d)

    def RefuteDecision(self, d: &#34;Decision&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Before refuting the decision.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_RefuteDecision(self, d)

    def AfterDecision(self, d: &#34;Decision&#34;, apply: &#34;bool&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Just after refuting or applying the decision, apply is true after Apply. This is called only if the Apply() or Refute() methods have not failed.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_AfterDecision(self, d, apply)

    def BeginFail(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Just when the failure occurs.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_BeginFail(self)

    def EndFail(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; After completing the backtrack.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_EndFail(self)

    def BeginInitialPropagation(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Before the initial propagation.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_BeginInitialPropagation(self)

    def EndInitialPropagation(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; After the initial propagation.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_EndInitialPropagation(self)

    def AcceptSolution(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; This method is called when a solution is found. It asserts whether the solution is valid. A value of false indicates that the solution should be discarded.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_AcceptSolution(self)

    def AtSolution(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; This method is called when a valid solution is found. If the return value is true, then search will resume after. If the result is false, then search will stop there.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_AtSolution(self)

    def NoMoreSolutions(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; When the search tree is finished.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_NoMoreSolutions(self)

    def LocalOptimum(self) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; When a local optimum is reached. If &#39;true&#39; is returned, the last solution is discarded and the search proceeds with the next one.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_LocalOptimum(self)

    def AcceptDelta(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.SearchMonitor_AcceptDelta(self, delta, deltadelta)

    def AcceptNeighbor(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; After accepting a neighbor during local search.&#34;&#34;&#34;
        return _pywrapcp.SearchMonitor_AcceptNeighbor(self)

    def solver(self) -&gt; &#34;operations_research::Solver *&#34;:
        return _pywrapcp.SearchMonitor_solver(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SearchMonitor___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SearchMonitor___str__(self)
    def __disown__(self):
        self.this.disown()
        _pywrapcp.disown_SearchMonitor(self)
        return weakref.proxy(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.OptimizeVar" href="#pywrapcp.OptimizeVar">OptimizeVar</a></li>
<li><a title="pywrapcp.SearchLimit" href="#pywrapcp.SearchLimit">SearchLimit</a></li>
<li><a title="pywrapcp.SolutionCollector" href="#pywrapcp.SolutionCollector">SolutionCollector</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.SearchMonitor.AcceptDelta"><code class="name flex">
<span>def <span class="ident">AcceptDelta</span></span>(<span>self, delta: Assignment, deltadelta: Assignment) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AcceptDelta(self, delta: &#34;Assignment&#34;, deltadelta: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
    return _pywrapcp.SearchMonitor_AcceptDelta(self, delta, deltadelta)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.AcceptNeighbor"><code class="name flex">
<span>def <span class="ident">AcceptNeighbor</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>After accepting a neighbor during local search.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AcceptNeighbor(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; After accepting a neighbor during local search.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_AcceptNeighbor(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.AcceptSolution"><code class="name flex">
<span>def <span class="ident">AcceptSolution</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>This method is called when a solution is found. It asserts whether the solution is valid. A value of false indicates that the solution should be discarded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AcceptSolution(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; This method is called when a solution is found. It asserts whether the solution is valid. A value of false indicates that the solution should be discarded.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_AcceptSolution(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.AfterDecision"><code class="name flex">
<span>def <span class="ident">AfterDecision</span></span>(<span>self, d: Decision, apply: bool) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Just after refuting or applying the decision, apply is true after Apply. This is called only if the Apply() or Refute() methods have not failed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AfterDecision(self, d: &#34;Decision&#34;, apply: &#34;bool&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Just after refuting or applying the decision, apply is true after Apply. This is called only if the Apply() or Refute() methods have not failed.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_AfterDecision(self, d, apply)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.ApplyDecision"><code class="name flex">
<span>def <span class="ident">ApplyDecision</span></span>(<span>self, d: Decision) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Before applying the decision.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ApplyDecision(self, d: &#34;Decision&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Before applying the decision.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_ApplyDecision(self, d)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.AtSolution"><code class="name flex">
<span>def <span class="ident">AtSolution</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>This method is called when a valid solution is found. If the return value is true, then search will resume after. If the result is false, then search will stop there.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AtSolution(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; This method is called when a valid solution is found. If the return value is true, then search will resume after. If the result is false, then search will stop there.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_AtSolution(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.BeginFail"><code class="name flex">
<span>def <span class="ident">BeginFail</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Just when the failure occurs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BeginFail(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Just when the failure occurs.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_BeginFail(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.BeginInitialPropagation"><code class="name flex">
<span>def <span class="ident">BeginInitialPropagation</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Before the initial propagation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BeginInitialPropagation(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Before the initial propagation.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_BeginInitialPropagation(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.BeginNextDecision"><code class="name flex">
<span>def <span class="ident">BeginNextDecision</span></span>(<span>self, b: DecisionBuilder) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Before calling DecisionBuilder::Next.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BeginNextDecision(self, b: &#34;DecisionBuilder&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Before calling DecisionBuilder::Next.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_BeginNextDecision(self, b)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.EndFail"><code class="name flex">
<span>def <span class="ident">EndFail</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>After completing the backtrack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndFail(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; After completing the backtrack.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_EndFail(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.EndInitialPropagation"><code class="name flex">
<span>def <span class="ident">EndInitialPropagation</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>After the initial propagation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndInitialPropagation(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; After the initial propagation.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_EndInitialPropagation(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.EndNextDecision"><code class="name flex">
<span>def <span class="ident">EndNextDecision</span></span>(<span>self, b: DecisionBuilder, d: Decision) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>After calling DecisionBuilder::Next, along with the returned decision.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndNextDecision(self, b: &#34;DecisionBuilder&#34;, d: &#34;Decision&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; After calling DecisionBuilder::Next, along with the returned decision.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_EndNextDecision(self, b, d)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.EnterSearch"><code class="name flex">
<span>def <span class="ident">EnterSearch</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Beginning of the search.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EnterSearch(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Beginning of the search.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_EnterSearch(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.ExitSearch"><code class="name flex">
<span>def <span class="ident">ExitSearch</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>End of the search.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ExitSearch(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; End of the search.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_ExitSearch(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.LocalOptimum"><code class="name flex">
<span>def <span class="ident">LocalOptimum</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>When a local optimum is reached. If 'true' is returned, the last solution is discarded and the search proceeds with the next one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LocalOptimum(self) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; When a local optimum is reached. If &#39;true&#39; is returned, the last solution is discarded and the search proceeds with the next one.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_LocalOptimum(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.NoMoreSolutions"><code class="name flex">
<span>def <span class="ident">NoMoreSolutions</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>When the search tree is finished.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NoMoreSolutions(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; When the search tree is finished.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_NoMoreSolutions(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.RefuteDecision"><code class="name flex">
<span>def <span class="ident">RefuteDecision</span></span>(<span>self, d: Decision) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Before refuting the decision.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RefuteDecision(self, d: &#34;Decision&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Before refuting the decision.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_RefuteDecision(self, d)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.RestartSearch"><code class="name flex">
<span>def <span class="ident">RestartSearch</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Restart the search.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RestartSearch(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Restart the search.&#34;&#34;&#34;
    return _pywrapcp.SearchMonitor_RestartSearch(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SearchMonitor.solver"><code class="name flex">
<span>def <span class="ident">solver</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Solver" href="#pywrapcp.Solver">Solver</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solver(self) -&gt; &#34;operations_research::Solver *&#34;:
    return _pywrapcp.SearchMonitor_solver(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.BaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.SequenceVar"><code class="flex name class">
<span>class <span class="ident">SequenceVar</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A sequence variable is a variable whose domain is a set of possible orderings of the interval variables. It allows ordering of tasks. It has two sets of methods: ComputePossibleFirstsAndLasts(), which returns the list of interval variables that can be ranked first or last; and RankFirst/RankNotFirst/RankLast/RankNotLast, which can be used to create the search decision.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SequenceVar(PropagationBaseObject):
    r&#34;&#34;&#34; A sequence variable is a variable whose domain is a set of possible orderings of the interval variables. It allows ordering of tasks. It has two sets of methods: ComputePossibleFirstsAndLasts(), which returns the list of interval variables that can be ranked first or last; and RankFirst/RankNotFirst/RankLast/RankNotLast, which can be used to create the search decision.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SequenceVar_DebugString(self)

    def RankFirst(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Ranks the index_th interval var first of all unranked interval vars. After that, it will no longer be considered ranked.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_RankFirst(self, index)

    def RankNotFirst(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Indicates that the index_th interval var will not be ranked first of all currently unranked interval vars.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_RankNotFirst(self, index)

    def RankLast(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Ranks the index_th interval var first of all unranked interval vars. After that, it will no longer be considered ranked.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_RankLast(self, index)

    def RankNotLast(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Indicates that the index_th interval var will not be ranked first of all currently unranked interval vars.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_RankNotLast(self, index)

    def Interval(self, index: &#34;int&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Returns the index_th interval of the sequence.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_Interval(self, index)

    def Next(self, index: &#34;int&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; Returns the next of the index_th interval of the sequence.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_Next(self, index)

    def Size(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the number of interval vars in the sequence.&#34;&#34;&#34;
        return _pywrapcp.SequenceVar_Size(self)

    def __repr__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SequenceVar___repr__(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SequenceVar___str__(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.SequenceVar.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.SequenceVar_DebugString(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVar.Interval"><code class="name flex">
<span>def <span class="ident">Interval</span></span>(<span>self, index: int) -> 'operations_research::<a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the index_th interval of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Interval(self, index: &#34;int&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
    r&#34;&#34;&#34; Returns the index_th interval of the sequence.&#34;&#34;&#34;
    return _pywrapcp.SequenceVar_Interval(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVar.Next"><code class="name flex">
<span>def <span class="ident">Next</span></span>(<span>self, index: int) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the next of the index_th interval of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Next(self, index: &#34;int&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; Returns the next of the index_th interval of the sequence.&#34;&#34;&#34;
    return _pywrapcp.SequenceVar_Next(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVar.RankFirst"><code class="name flex">
<span>def <span class="ident">RankFirst</span></span>(<span>self, index: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Ranks the index_th interval var first of all unranked interval vars. After that, it will no longer be considered ranked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RankFirst(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Ranks the index_th interval var first of all unranked interval vars. After that, it will no longer be considered ranked.&#34;&#34;&#34;
    return _pywrapcp.SequenceVar_RankFirst(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVar.RankLast"><code class="name flex">
<span>def <span class="ident">RankLast</span></span>(<span>self, index: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Ranks the index_th interval var first of all unranked interval vars. After that, it will no longer be considered ranked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RankLast(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Ranks the index_th interval var first of all unranked interval vars. After that, it will no longer be considered ranked.&#34;&#34;&#34;
    return _pywrapcp.SequenceVar_RankLast(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVar.RankNotFirst"><code class="name flex">
<span>def <span class="ident">RankNotFirst</span></span>(<span>self, index: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that the index_th interval var will not be ranked first of all currently unranked interval vars.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RankNotFirst(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Indicates that the index_th interval var will not be ranked first of all currently unranked interval vars.&#34;&#34;&#34;
    return _pywrapcp.SequenceVar_RankNotFirst(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVar.RankNotLast"><code class="name flex">
<span>def <span class="ident">RankNotLast</span></span>(<span>self, index: int) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that the index_th interval var will not be ranked first of all currently unranked interval vars.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RankNotLast(self, index: &#34;int&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Indicates that the index_th interval var will not be ranked first of all currently unranked interval vars.&#34;&#34;&#34;
    return _pywrapcp.SequenceVar_RankNotLast(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVar.Size"><code class="name flex">
<span>def <span class="ident">Size</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of interval vars in the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Size(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the number of interval vars in the sequence.&#34;&#34;&#34;
    return _pywrapcp.SequenceVar_Size(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.PropagationBaseObject.Name" href="#pywrapcp.PropagationBaseObject.Name">Name</a></code></li>
<li><code><a title="pywrapcp.PropagationBaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.SequenceVarContainer"><code class="flex name class">
<span>class <span class="ident">SequenceVarContainer</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SequenceVarContainer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Contains(self, var: &#34;SequenceVar&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.SequenceVarContainer_Contains(self, var)

    def Element(self, index: &#34;int&#34;) -&gt; &#34;operations_research::SequenceVarElement *&#34;:
        return _pywrapcp.SequenceVarContainer_Element(self, index)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.SequenceVarContainer_Size(self)

    def Store(self) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarContainer_Store(self)

    def Restore(self) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarContainer_Restore(self)

    def __eq__(self, container: &#34;SequenceVarContainer&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Returns true if this and &#39;container&#39; both represent the same V* -&gt; E map. Runs in linear time; requires that the == operator on the type E is well defined.&#34;&#34;&#34;
        return _pywrapcp.SequenceVarContainer___eq__(self, container)

    def __ne__(self, container: &#34;SequenceVarContainer&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.SequenceVarContainer___ne__(self, container)
    __swig_destroy__ = _pywrapcp.delete_SequenceVarContainer</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapcp.SequenceVarContainer.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<div class="desc"><p>The membership flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.SequenceVarContainer.Contains"><code class="name flex">
<span>def <span class="ident">Contains</span></span>(<span>self, var: SequenceVar) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Contains(self, var: &#34;SequenceVar&#34;) -&gt; &#34;bool&#34;:
    return _pywrapcp.SequenceVarContainer_Contains(self, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarContainer.Element"><code class="name flex">
<span>def <span class="ident">Element</span></span>(<span>self, index: int) -> 'operations_research::<a title="pywrapcp.SequenceVarElement" href="#pywrapcp.SequenceVarElement">SequenceVarElement</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Element(self, index: &#34;int&#34;) -&gt; &#34;operations_research::SequenceVarElement *&#34;:
    return _pywrapcp.SequenceVarContainer_Element(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarContainer.Restore"><code class="name flex">
<span>def <span class="ident">Restore</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Restore(self) -&gt; &#34;void&#34;:
    return _pywrapcp.SequenceVarContainer_Restore(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarContainer.Size"><code class="name flex">
<span>def <span class="ident">Size</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Size(self) -&gt; &#34;int&#34;:
    return _pywrapcp.SequenceVarContainer_Size(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarContainer.Store"><code class="name flex">
<span>def <span class="ident">Store</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Store(self) -&gt; &#34;void&#34;:
    return _pywrapcp.SequenceVarContainer_Store(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywrapcp.SequenceVarElement"><code class="flex name class">
<span>class <span class="ident">SequenceVarElement</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The SequenceVarElement stores a partial representation of ranked interval variables in the underlying sequence variable. This representation consists of three vectors:
- the forward sequence. That is the list of interval variables
ranked first in the sequence.
The first element of the backward
sequence is the first interval in the sequence variable.
- the backward sequence. That is the list of interval variables
ranked last in the sequence. The first element of the backward
sequence is the last interval in the sequence variable.
- The list of unperformed interval variables.
Furthermore, if all performed variables are ranked, then by
convention, the forward_sequence will contain all such variables
and the backward_sequence will be empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SequenceVarElement(AssignmentElement):
    r&#34;&#34;&#34; The SequenceVarElement stores a partial representation of ranked interval variables in the underlying sequence variable. This representation consists of three vectors:   - the forward sequence. That is the list of interval variables     ranked first in the sequence.  The first element of the backward     sequence is the first interval in the sequence variable.   - the backward sequence. That is the list of interval variables     ranked last in the sequence. The first element of the backward     sequence is the last interval in the sequence variable.   - The list of unperformed interval variables.  Furthermore, if all performed variables are ranked, then by  convention, the forward_sequence will contain all such variables  and the backward_sequence will be empty.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def Var(self) -&gt; &#34;operations_research::SequenceVar *&#34;:
        return _pywrapcp.SequenceVarElement_Var(self)

    def ForwardSequence(self) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.SequenceVarElement_ForwardSequence(self)

    def BackwardSequence(self) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.SequenceVarElement_BackwardSequence(self)

    def Unperformed(self) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.SequenceVarElement_Unperformed(self)

    def SetSequence(self, forward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;, backward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;, unperformed: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarElement_SetSequence(self, forward_sequence, backward_sequence, unperformed)

    def SetForwardSequence(self, forward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarElement_SetForwardSequence(self, forward_sequence)

    def SetBackwardSequence(self, backward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarElement_SetBackwardSequence(self, backward_sequence)

    def SetUnperformed(self, unperformed: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarElement_SetUnperformed(self, unperformed)

    def __eq__(self, element: &#34;SequenceVarElement&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.SequenceVarElement___eq__(self, element)

    def __ne__(self, element: &#34;SequenceVarElement&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.SequenceVarElement___ne__(self, element)
    __swig_destroy__ = _pywrapcp.delete_SequenceVarElement</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.AssignmentElement" href="#pywrapcp.AssignmentElement">AssignmentElement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.SequenceVarElement.BackwardSequence"><code class="name flex">
<span>def <span class="ident">BackwardSequence</span></span>(<span>self) -> 'std::vector< int > const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BackwardSequence(self) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
    return _pywrapcp.SequenceVarElement_BackwardSequence(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarElement.ForwardSequence"><code class="name flex">
<span>def <span class="ident">ForwardSequence</span></span>(<span>self) -> 'std::vector< int > const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ForwardSequence(self) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
    return _pywrapcp.SequenceVarElement_ForwardSequence(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarElement.SetBackwardSequence"><code class="name flex">
<span>def <span class="ident">SetBackwardSequence</span></span>(<span>self, backward_sequence: std::vector< int > const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetBackwardSequence(self, backward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.SequenceVarElement_SetBackwardSequence(self, backward_sequence)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarElement.SetForwardSequence"><code class="name flex">
<span>def <span class="ident">SetForwardSequence</span></span>(<span>self, forward_sequence: std::vector< int > const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetForwardSequence(self, forward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.SequenceVarElement_SetForwardSequence(self, forward_sequence)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarElement.SetSequence"><code class="name flex">
<span>def <span class="ident">SetSequence</span></span>(<span>self, forward_sequence: std::vector< int > const &, backward_sequence: std::vector< int > const &, unperformed: std::vector< int > const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetSequence(self, forward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;, backward_sequence: &#34;std::vector&lt; int &gt; const &amp;&#34;, unperformed: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.SequenceVarElement_SetSequence(self, forward_sequence, backward_sequence, unperformed)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarElement.SetUnperformed"><code class="name flex">
<span>def <span class="ident">SetUnperformed</span></span>(<span>self, unperformed: std::vector< int > const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetUnperformed(self, unperformed: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.SequenceVarElement_SetUnperformed(self, unperformed)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarElement.Unperformed"><code class="name flex">
<span>def <span class="ident">Unperformed</span></span>(<span>self) -> 'std::vector< int > const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Unperformed(self) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
    return _pywrapcp.SequenceVarElement_Unperformed(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarElement.Var"><code class="name flex">
<span>def <span class="ident">Var</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.SequenceVar" href="#pywrapcp.SequenceVar">SequenceVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Var(self) -&gt; &#34;operations_research::SequenceVar *&#34;:
    return _pywrapcp.SequenceVarElement_Var(self)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.AssignmentElement" href="#pywrapcp.AssignmentElement">AssignmentElement</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.AssignmentElement.thisown" href="#pywrapcp.AssignmentElement.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.SequenceVarLocalSearchOperator"><code class="flex name class">
<span>class <span class="ident">SequenceVarLocalSearchOperator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base operator class for operators manipulating variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SequenceVarLocalSearchOperator(SequenceVarLocalSearchOperatorTemplate):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate">SequenceVarLocalSearchOperatorTemplate</a></li>
<li><a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate">SequenceVarLocalSearchOperatorTemplate</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate.OnStart" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate.OnStart">OnStart</a></code></li>
<li><code><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate.Start" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate.Start">Start</a></code></li>
<li><code><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate.Value" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate.Value">Value</a></code></li>
<li><code><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.SequenceVarLocalSearchOperatorTemplate"><code class="flex name class">
<span>class <span class="ident">SequenceVarLocalSearchOperatorTemplate</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base operator class for operators manipulating variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SequenceVarLocalSearchOperatorTemplate(LocalSearchOperator):
    r&#34;&#34;&#34; Base operator class for operators manipulating variables.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr

    def Start(self, assignment: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; This method should not be overridden. Override OnStart() instead which is called before exiting this method.&#34;&#34;&#34;
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_Start(self, assignment)

    def IsIncremental(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_IsIncremental(self)

    def Size(self) -&gt; &#34;int&#34;:
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_Size(self)

    def Value(self, index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        r&#34;&#34;&#34; Returns the value in the current assignment of the variable of given index.&#34;&#34;&#34;
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_Value(self, index)

    def OldValue(self, index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_OldValue(self, index)

    def SetValue(self, index: &#34;int64&#34;, value: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_SetValue(self, index, value)

    def OnStart(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Called by Start() after synchronizing the operator with the current assignment. Should be overridden instead of Start() to avoid calling VarLocalSearchOperator::Start explicitly.&#34;&#34;&#34;
        return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_OnStart(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.SequenceVarLocalSearchOperator" href="#pywrapcp.SequenceVarLocalSearchOperator">SequenceVarLocalSearchOperator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.SequenceVarLocalSearchOperatorTemplate.IsIncremental"><code class="name flex">
<span>def <span class="ident">IsIncremental</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsIncremental(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_IsIncremental(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarLocalSearchOperatorTemplate.OldValue"><code class="name flex">
<span>def <span class="ident">OldValue</span></span>(<span>self, index: int64) -> 'std::vector< int > const &'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OldValue(self, index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
    return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_OldValue(self, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarLocalSearchOperatorTemplate.OnStart"><code class="name flex">
<span>def <span class="ident">OnStart</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Called by Start() after synchronizing the operator with the current assignment. Should be overridden instead of Start() to avoid calling VarLocalSearchOperator::Start explicitly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OnStart(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Called by Start() after synchronizing the operator with the current assignment. Should be overridden instead of Start() to avoid calling VarLocalSearchOperator::Start explicitly.&#34;&#34;&#34;
    return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_OnStart(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarLocalSearchOperatorTemplate.SetValue"><code class="name flex">
<span>def <span class="ident">SetValue</span></span>(<span>self, index: int64, value: std::vector< int > const &) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetValue(self, index: &#34;int64&#34;, value: &#34;std::vector&lt; int &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_SetValue(self, index, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarLocalSearchOperatorTemplate.Size"><code class="name flex">
<span>def <span class="ident">Size</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Size(self) -&gt; &#34;int&#34;:
    return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_Size(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarLocalSearchOperatorTemplate.Start"><code class="name flex">
<span>def <span class="ident">Start</span></span>(<span>self, assignment: Assignment) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>This method should not be overridden. Override OnStart() instead which is called before exiting this method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Start(self, assignment: &#34;Assignment&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; This method should not be overridden. Override OnStart() instead which is called before exiting this method.&#34;&#34;&#34;
    return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_Start(self, assignment)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SequenceVarLocalSearchOperatorTemplate.Value"><code class="name flex">
<span>def <span class="ident">Value</span></span>(<span>self, index: int64) -> 'std::vector< int > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the value in the current assignment of the variable of given index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Value(self, index: &#34;int64&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
    r&#34;&#34;&#34; Returns the value in the current assignment of the variable of given index.&#34;&#34;&#34;
    return _pywrapcp.SequenceVarLocalSearchOperatorTemplate_Value(self, index)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.LocalSearchOperator.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.SolutionCollector"><code class="flex name class">
<span>class <span class="ident">SolutionCollector</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is the root class of all solution collectors. It implements a basic query API to be used independently of the collector used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SolutionCollector(SearchMonitor):
    r&#34;&#34;&#34; This class is the root class of all solution collectors. It implements a basic query API to be used independently of the collector used.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined&#34;)
    __repr__ = _swig_repr

    def DebugString(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.SolutionCollector_DebugString(self)

    def Add(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.SolutionCollector_Add(self, *args)

    def AddObjective(self, objective: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
        return _pywrapcp.SolutionCollector_AddObjective(self, objective)

    def EnterSearch(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Beginning of the search.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_EnterSearch(self)

    def SolutionCount(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Returns how many solutions were stored during the search.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_SolutionCount(self)

    def Solution(self, n: &#34;int&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34; Returns the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_Solution(self, n)

    def WallTime(self, n: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the wall time in ms for the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_WallTime(self, n)

    def Branches(self, n: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the number of branches when the nth solution was found.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_Branches(self, n)

    def Failures(self, n: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the number of failures encountered at the time of the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_Failures(self, n)

    def ObjectiveValue(self, n: &#34;int&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns the objective value of the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_ObjectiveValue(self, n)

    def Value(self, n: &#34;int&#34;, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the Value of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_Value(self, n, var)

    def StartValue(self, n: &#34;int&#34;, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the StartValue of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_StartValue(self, n, var)

    def EndValue(self, n: &#34;int&#34;, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the EndValue of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_EndValue(self, n, var)

    def DurationValue(self, n: &#34;int&#34;, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the DurationValue of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_DurationValue(self, n, var)

    def PerformedValue(self, n: &#34;int&#34;, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the PerformedValue of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_PerformedValue(self, n, var)

    def ForwardSequence(self, n: &#34;int&#34;, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the ForwardSequence of &#39;var&#39; in the nth solution. The forward sequence is the list of ranked interval variables starting from the start of the sequence.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_ForwardSequence(self, n, var)

    def BackwardSequence(self, n: &#34;int&#34;, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the BackwardSequence of &#39;var&#39; in the nth solution. The backward sequence is the list of ranked interval variables starting from the end of the sequence.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_BackwardSequence(self, n, var)

    def Unperformed(self, n: &#34;int&#34;, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
        r&#34;&#34;&#34; This is a shortcut to get the list of unperformed of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
        return _pywrapcp.SolutionCollector_Unperformed(self, n, var)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.SolutionCollector.Add"><code class="name flex">
<span>def <span class="ident">Add</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Add(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.SolutionCollector_Add(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.AddObjective"><code class="name flex">
<span>def <span class="ident">AddObjective</span></span>(<span>self, objective: IntVar) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddObjective(self, objective: &#34;IntVar&#34;) -&gt; &#34;void&#34;:
    return _pywrapcp.SolutionCollector_AddObjective(self, objective)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.BackwardSequence"><code class="name flex">
<span>def <span class="ident">BackwardSequence</span></span>(<span>self, n: int, var: SequenceVar) -> 'std::vector< int > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>This is a shortcut to get the BackwardSequence of 'var' in the nth solution. The backward sequence is the list of ranked interval variables starting from the end of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BackwardSequence(self, n: &#34;int&#34;, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
    r&#34;&#34;&#34; This is a shortcut to get the BackwardSequence of &#39;var&#39; in the nth solution. The backward sequence is the list of ranked interval variables starting from the end of the sequence.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_BackwardSequence(self, n, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.Branches"><code class="name flex">
<span>def <span class="ident">Branches</span></span>(<span>self, n: int) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of branches when the nth solution was found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Branches(self, n: &#34;int&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the number of branches when the nth solution was found.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_Branches(self, n)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.DebugString"><code class="name flex">
<span>def <span class="ident">DebugString</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DebugString(self) -&gt; &#34;std::string&#34;:
    return _pywrapcp.SolutionCollector_DebugString(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.DurationValue"><code class="name flex">
<span>def <span class="ident">DurationValue</span></span>(<span>self, n: int, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>This is a shortcut to get the DurationValue of 'var' in the nth solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DurationValue(self, n: &#34;int&#34;, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; This is a shortcut to get the DurationValue of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_DurationValue(self, n, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.EndValue"><code class="name flex">
<span>def <span class="ident">EndValue</span></span>(<span>self, n: int, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>This is a shortcut to get the EndValue of 'var' in the nth solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndValue(self, n: &#34;int&#34;, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; This is a shortcut to get the EndValue of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_EndValue(self, n, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.Failures"><code class="name flex">
<span>def <span class="ident">Failures</span></span>(<span>self, n: int) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of failures encountered at the time of the nth solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Failures(self, n: &#34;int&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the number of failures encountered at the time of the nth solution.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_Failures(self, n)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.ForwardSequence"><code class="name flex">
<span>def <span class="ident">ForwardSequence</span></span>(<span>self, n: int, var: SequenceVar) -> 'std::vector< int > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>This is a shortcut to get the ForwardSequence of 'var' in the nth solution. The forward sequence is the list of ranked interval variables starting from the start of the sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ForwardSequence(self, n: &#34;int&#34;, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
    r&#34;&#34;&#34; This is a shortcut to get the ForwardSequence of &#39;var&#39; in the nth solution. The forward sequence is the list of ranked interval variables starting from the start of the sequence.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_ForwardSequence(self, n, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.ObjectiveValue"><code class="name flex">
<span>def <span class="ident">ObjectiveValue</span></span>(<span>self, n: int) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the objective value of the nth solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ObjectiveValue(self, n: &#34;int&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the objective value of the nth solution.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_ObjectiveValue(self, n)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.PerformedValue"><code class="name flex">
<span>def <span class="ident">PerformedValue</span></span>(<span>self, n: int, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>This is a shortcut to get the PerformedValue of 'var' in the nth solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PerformedValue(self, n: &#34;int&#34;, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; This is a shortcut to get the PerformedValue of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_PerformedValue(self, n, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.Solution"><code class="name flex">
<span>def <span class="ident">Solution</span></span>(<span>self, n: int) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the nth solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Solution(self, n: &#34;int&#34;) -&gt; &#34;operations_research::Assignment *&#34;:
    r&#34;&#34;&#34; Returns the nth solution.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_Solution(self, n)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.SolutionCount"><code class="name flex">
<span>def <span class="ident">SolutionCount</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns how many solutions were stored during the search.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SolutionCount(self) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Returns how many solutions were stored during the search.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_SolutionCount(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.StartValue"><code class="name flex">
<span>def <span class="ident">StartValue</span></span>(<span>self, n: int, var: IntervalVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>This is a shortcut to get the StartValue of 'var' in the nth solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StartValue(self, n: &#34;int&#34;, var: &#34;IntervalVar&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; This is a shortcut to get the StartValue of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_StartValue(self, n, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.Unperformed"><code class="name flex">
<span>def <span class="ident">Unperformed</span></span>(<span>self, n: int, var: SequenceVar) -> 'std::vector< int > const &'</span>
</code></dt>
<dd>
<div class="desc"><p>This is a shortcut to get the list of unperformed of 'var' in the nth solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Unperformed(self, n: &#34;int&#34;, var: &#34;SequenceVar&#34;) -&gt; &#34;std::vector&lt; int &gt; const &amp;&#34;:
    r&#34;&#34;&#34; This is a shortcut to get the list of unperformed of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_Unperformed(self, n, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.Value"><code class="name flex">
<span>def <span class="ident">Value</span></span>(<span>self, n: int, var: IntVar) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>This is a shortcut to get the Value of 'var' in the nth solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Value(self, n: &#34;int&#34;, var: &#34;IntVar&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; This is a shortcut to get the Value of &#39;var&#39; in the nth solution.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_Value(self, n, var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.SolutionCollector.WallTime"><code class="name flex">
<span>def <span class="ident">WallTime</span></span>(<span>self, n: int) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the wall time in ms for the nth solution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WallTime(self, n: &#34;int&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns the wall time in ms for the nth solution.&#34;&#34;&#34;
    return _pywrapcp.SolutionCollector_WallTime(self, n)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.SearchMonitor.AcceptNeighbor" href="#pywrapcp.SearchMonitor.AcceptNeighbor">AcceptNeighbor</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.AcceptSolution" href="#pywrapcp.SearchMonitor.AcceptSolution">AcceptSolution</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.AfterDecision" href="#pywrapcp.SearchMonitor.AfterDecision">AfterDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.ApplyDecision" href="#pywrapcp.SearchMonitor.ApplyDecision">ApplyDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.AtSolution" href="#pywrapcp.SearchMonitor.AtSolution">AtSolution</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.BeginFail" href="#pywrapcp.SearchMonitor.BeginFail">BeginFail</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.BeginInitialPropagation" href="#pywrapcp.SearchMonitor.BeginInitialPropagation">BeginInitialPropagation</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.BeginNextDecision" href="#pywrapcp.SearchMonitor.BeginNextDecision">BeginNextDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EndFail" href="#pywrapcp.SearchMonitor.EndFail">EndFail</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EndInitialPropagation" href="#pywrapcp.SearchMonitor.EndInitialPropagation">EndInitialPropagation</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EndNextDecision" href="#pywrapcp.SearchMonitor.EndNextDecision">EndNextDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EnterSearch" href="#pywrapcp.SearchMonitor.EnterSearch">EnterSearch</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.ExitSearch" href="#pywrapcp.SearchMonitor.ExitSearch">ExitSearch</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.LocalOptimum" href="#pywrapcp.SearchMonitor.LocalOptimum">LocalOptimum</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.NoMoreSolutions" href="#pywrapcp.SearchMonitor.NoMoreSolutions">NoMoreSolutions</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.RefuteDecision" href="#pywrapcp.SearchMonitor.RefuteDecision">RefuteDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.RestartSearch" href="#pywrapcp.SearchMonitor.RestartSearch">RestartSearch</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.Solver"><code class="flex name class">
<span>class <span class="ident">Solver</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Solver Class A solver represents the main computation engine. It implements the entire range of Constraint Programming protocols:
- Reversibility
- Propagation
- Search Usually, Constraint Programming code consists of
- the creation of the Solver,
- the creation of the decision variables of the model,
- the creation of the constraints of the model and their addition to the
solver() through the AddConstraint() method,
- the creation of the main DecisionBuilder class,
- the launch of the solve() method with the decision builder. For the time being, Solver is neither MT_SAFE nor MT_HOT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Solver(object):
    r&#34;&#34;&#34; Solver Class A solver represents the main computation engine. It implements the entire range of Constraint Programming protocols:   - Reversibility   - Propagation   - Search Usually, Constraint Programming code consists of   - the creation of the Solver,   - the creation of the decision variables of the model,   - the creation of the constraints of the model and their addition to the     solver() through the AddConstraint() method,   - the creation of the main DecisionBuilder class,   - the launch of the solve() method with the decision builder. For the time being, Solver is neither MT_SAFE nor MT_HOT.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr
    INT_VAR_DEFAULT = _pywrapcp.Solver_INT_VAR_DEFAULT
    r&#34;&#34;&#34; The default behavior is CHOOSE_FIRST_UNBOUND.&#34;&#34;&#34;
    INT_VAR_SIMPLE = _pywrapcp.Solver_INT_VAR_SIMPLE
    r&#34;&#34;&#34; The simple selection is CHOOSE_FIRST_UNBOUND.&#34;&#34;&#34;
    CHOOSE_FIRST_UNBOUND = _pywrapcp.Solver_CHOOSE_FIRST_UNBOUND
    r&#34;&#34;&#34; Select the first unbound variable. Variables are considered in the order of the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_RANDOM = _pywrapcp.Solver_CHOOSE_RANDOM
    r&#34;&#34;&#34; Randomly select one of the remaining unbound variables.&#34;&#34;&#34;
    CHOOSE_MIN_SIZE_LOWEST_MIN = _pywrapcp.Solver_CHOOSE_MIN_SIZE_LOWEST_MIN
    r&#34;&#34;&#34; Among unbound variables, select the variable with the smallest size, i.e., the smallest number of possible values. In case of a tie, the selected variables is the one with the lowest min value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_MIN_SIZE_HIGHEST_MIN = _pywrapcp.Solver_CHOOSE_MIN_SIZE_HIGHEST_MIN
    r&#34;&#34;&#34; Among unbound variables, select the variable with the smallest size, i.e., the smallest number of possible values. In case of a tie, the selected variable is the one with the highest min value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_MIN_SIZE_LOWEST_MAX = _pywrapcp.Solver_CHOOSE_MIN_SIZE_LOWEST_MAX
    r&#34;&#34;&#34; Among unbound variables, select the variable with the smallest size, i.e., the smallest number of possible values. In case of a tie, the selected variables is the one with the lowest max value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_MIN_SIZE_HIGHEST_MAX = _pywrapcp.Solver_CHOOSE_MIN_SIZE_HIGHEST_MAX
    r&#34;&#34;&#34; Among unbound variables, select the variable with the smallest size, i.e., the smallest number of possible values. In case of a tie, the selected variable is the one with the highest max value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_LOWEST_MIN = _pywrapcp.Solver_CHOOSE_LOWEST_MIN
    r&#34;&#34;&#34; Among unbound variables, select the variable with the smallest minimal value. In case of a tie, the first one is selected, &#34;first&#34; defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_HIGHEST_MAX = _pywrapcp.Solver_CHOOSE_HIGHEST_MAX
    r&#34;&#34;&#34; Among unbound variables, select the variable with the highest maximal value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_MIN_SIZE = _pywrapcp.Solver_CHOOSE_MIN_SIZE
    r&#34;&#34;&#34; Among unbound variables, select the variable with the smallest size. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_MAX_SIZE = _pywrapcp.Solver_CHOOSE_MAX_SIZE
    r&#34;&#34;&#34; Among unbound variables, select the variable with the highest size. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.&#34;&#34;&#34;
    CHOOSE_MAX_REGRET_ON_MIN = _pywrapcp.Solver_CHOOSE_MAX_REGRET_ON_MIN
    r&#34;&#34;&#34; Among unbound variables, select the variable with the largest gap between the first and the second values of the domain.&#34;&#34;&#34;
    CHOOSE_PATH = _pywrapcp.Solver_CHOOSE_PATH
    r&#34;&#34;&#34; Selects the next unbound variable on a path, the path being defined by the variables: var[i] corresponds to the index of the next of i.&#34;&#34;&#34;
    INT_VALUE_DEFAULT = _pywrapcp.Solver_INT_VALUE_DEFAULT
    r&#34;&#34;&#34; The default behavior is ASSIGN_MIN_VALUE.&#34;&#34;&#34;
    INT_VALUE_SIMPLE = _pywrapcp.Solver_INT_VALUE_SIMPLE
    r&#34;&#34;&#34; The simple selection is ASSIGN_MIN_VALUE.&#34;&#34;&#34;
    ASSIGN_MIN_VALUE = _pywrapcp.Solver_ASSIGN_MIN_VALUE
    r&#34;&#34;&#34; Selects the min value of the selected variable.&#34;&#34;&#34;
    ASSIGN_MAX_VALUE = _pywrapcp.Solver_ASSIGN_MAX_VALUE
    r&#34;&#34;&#34; Selects the max value of the selected variable.&#34;&#34;&#34;
    ASSIGN_RANDOM_VALUE = _pywrapcp.Solver_ASSIGN_RANDOM_VALUE
    r&#34;&#34;&#34; Selects randomly one of the possible values of the selected variable.&#34;&#34;&#34;
    ASSIGN_CENTER_VALUE = _pywrapcp.Solver_ASSIGN_CENTER_VALUE
    r&#34;&#34;&#34; Selects the first possible value which is the closest to the center of the domain of the selected variable. The center is defined as (min + max) / 2.&#34;&#34;&#34;
    SPLIT_LOWER_HALF = _pywrapcp.Solver_SPLIT_LOWER_HALF
    r&#34;&#34;&#34; Split the domain in two around the center, and choose the lower part first.&#34;&#34;&#34;
    SPLIT_UPPER_HALF = _pywrapcp.Solver_SPLIT_UPPER_HALF
    r&#34;&#34;&#34; Split the domain in two around the center, and choose the lower part first.&#34;&#34;&#34;
    SEQUENCE_DEFAULT = _pywrapcp.Solver_SEQUENCE_DEFAULT
    SEQUENCE_SIMPLE = _pywrapcp.Solver_SEQUENCE_SIMPLE
    CHOOSE_MIN_SLACK_RANK_FORWARD = _pywrapcp.Solver_CHOOSE_MIN_SLACK_RANK_FORWARD
    CHOOSE_RANDOM_RANK_FORWARD = _pywrapcp.Solver_CHOOSE_RANDOM_RANK_FORWARD
    INTERVAL_DEFAULT = _pywrapcp.Solver_INTERVAL_DEFAULT
    r&#34;&#34;&#34; The default is INTERVAL_SET_TIMES_FORWARD.&#34;&#34;&#34;
    INTERVAL_SIMPLE = _pywrapcp.Solver_INTERVAL_SIMPLE
    r&#34;&#34;&#34; The simple is INTERVAL_SET_TIMES_FORWARD.&#34;&#34;&#34;
    INTERVAL_SET_TIMES_FORWARD = _pywrapcp.Solver_INTERVAL_SET_TIMES_FORWARD
    r&#34;&#34;&#34; Selects the variable with the lowest starting time of all variables, and fixes its starting time to this lowest value.&#34;&#34;&#34;
    INTERVAL_SET_TIMES_BACKWARD = _pywrapcp.Solver_INTERVAL_SET_TIMES_BACKWARD
    r&#34;&#34;&#34; Selects the variable with the highest ending time of all variables, and fixes the ending time to this highest values.&#34;&#34;&#34;
    TWOOPT = _pywrapcp.Solver_TWOOPT
    r&#34;&#34;&#34; Operator which reverses a sub-chain of a path. It is called TwoOpt because it breaks two arcs on the path; resulting paths are called two-optimal. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (where (1, 5) are first and last nodes of the path and can therefore not be moved):   1 -&gt; [3 -&gt; 2] -&gt; 4  -&gt; 5   1 -&gt; [4 -&gt; 3  -&gt; 2] -&gt; 5   1 -&gt;  2 -&gt; [4 -&gt; 3] -&gt; 5&#34;&#34;&#34;
    OROPT = _pywrapcp.Solver_OROPT
    r&#34;&#34;&#34; Relocate: OROPT and RELOCATE. Operator which moves a sub-chain of a path to another position; the specified chain length is the fixed length of the chains being moved. When this length is 1, the operator simply moves a node to another position. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a chain length of 2 (where (1, 5) are first and last nodes of the path and can therefore not be moved):   1 -&gt;  4 -&gt; [2 -&gt; 3] -&gt; 5   1 -&gt; [3 -&gt; 4] -&gt; 2  -&gt; 5 Using Relocate with chain lengths of 1, 2 and 3 together is equivalent to the OrOpt operator on a path. The OrOpt operator is a limited  version of 3Opt (breaks 3 arcs on a path).&#34;&#34;&#34;
    RELOCATE = _pywrapcp.Solver_RELOCATE
    r&#34;&#34;&#34; Relocate neighborhood with length of 1 (see OROPT comment).&#34;&#34;&#34;
    EXCHANGE = _pywrapcp.Solver_EXCHANGE
    r&#34;&#34;&#34; Operator which exchanges the positions of two nodes. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (where (1, 5) are first and last nodes of the path and can therefore not be moved):   1 -&gt; [3] -&gt; [2] -&gt;  4  -&gt; 5   1 -&gt; [4] -&gt;  3  -&gt; [2] -&gt; 5   1 -&gt;  2  -&gt; [4] -&gt; [3] -&gt; 5&#34;&#34;&#34;
    CROSS = _pywrapcp.Solver_CROSS
    r&#34;&#34;&#34; Operator which cross exchanges the starting chains of 2 paths, including exchanging the whole paths. First and last nodes are not moved. Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8 (where (1, 5) and (6, 8) are first and last nodes of the paths and can therefore not be moved):   1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5  6 -&gt; [2] -&gt; 8   1 -&gt; [7] -&gt; 4 -&gt; 5       6 -&gt; [2 -&gt; 3] -&gt; 8   1 -&gt; [7] -&gt; 5            6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8&#34;&#34;&#34;
    MAKEACTIVE = _pywrapcp.Solver_MAKEACTIVE
    r&#34;&#34;&#34; Operator which inserts an inactive node into a path. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive (where 1 and 4 are first and last nodes of the path) are:   1 -&gt; [5] -&gt;  2  -&gt;  3  -&gt; 4   1 -&gt;  2  -&gt; [5] -&gt;  3  -&gt; 4   1 -&gt;  2  -&gt;  3  -&gt; [5] -&gt; 4&#34;&#34;&#34;
    MAKEINACTIVE = _pywrapcp.Solver_MAKEINACTIVE
    r&#34;&#34;&#34; Operator which makes path nodes inactive. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first and last nodes of the path) are:   1 -&gt; 3 -&gt; 4 with 2 inactive   1 -&gt; 2 -&gt; 4 with 3 inactive&#34;&#34;&#34;
    MAKECHAININACTIVE = _pywrapcp.Solver_MAKECHAININACTIVE
    r&#34;&#34;&#34; Operator which makes a &#34;chain&#34; of path nodes inactive. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first and last nodes of the path) are:   1 -&gt; 3 -&gt; 4 with 2 inactive   1 -&gt; 2 -&gt; 4 with 3 inactive   1 -&gt; 4 with 2 and 3 inactive&#34;&#34;&#34;
    SWAPACTIVE = _pywrapcp.Solver_SWAPACTIVE
    r&#34;&#34;&#34; Operator which replaces an active node by an inactive one. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive (where 1 and 4 are first and last nodes of the path) are:   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive&#34;&#34;&#34;
    EXTENDEDSWAPACTIVE = _pywrapcp.Solver_EXTENDEDSWAPACTIVE
    r&#34;&#34;&#34; Operator which makes an inactive node active and an active one inactive. It is similar to SwapActiveOperator except that it tries to insert the inactive node in all possible positions instead of just the position of the node made inactive. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive (where 1 and 4 are first and last nodes of the path) are:   1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive   1 -&gt;  3  -&gt; [5] -&gt; 4 with 2 inactive   1 -&gt; [5] -&gt;  2  -&gt; 4 with 3 inactive   1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive&#34;&#34;&#34;
    PATHLNS = _pywrapcp.Solver_PATHLNS
    r&#34;&#34;&#34; Operator which relaxes two sub-chains of three consecutive arcs each. Each sub-chain is defined by a start node and the next three arcs. Those six arcs are relaxed to build a new neighbor. PATHLNS explores all possible pairs of starting nodes and so defines n^2 neighbors, n being the number of nodes. Note that the two sub-chains can be part of the same path; they even may overlap.&#34;&#34;&#34;
    FULLPATHLNS = _pywrapcp.Solver_FULLPATHLNS
    r&#34;&#34;&#34; Operator which relaxes one entire path and all inactive nodes, thus defining num_paths neighbors.&#34;&#34;&#34;
    UNACTIVELNS = _pywrapcp.Solver_UNACTIVELNS
    r&#34;&#34;&#34; Operator which relaxes all inactive nodes and one sub-chain of six consecutive arcs. That way the path can be improved by inserting inactive nodes or swapping arcs.&#34;&#34;&#34;
    INCREMENT = _pywrapcp.Solver_INCREMENT
    r&#34;&#34;&#34; Operator which defines one neighbor per variable. Each neighbor tries to increment by one the value of the corresponding variable. When a new solution is found the neighborhood is rebuilt from scratch, i.e., tries to increment values in the variable order. Consider for instance variables x and y. x is incremented one by one to its max, and when it is not possible to increment x anymore, y is incremented once. If this is a solution, then next neighbor tries to increment x.&#34;&#34;&#34;
    DECREMENT = _pywrapcp.Solver_DECREMENT
    r&#34;&#34;&#34; Operator which defines a neighborhood to decrement values. The behavior is the same as INCREMENT, except values are decremented instead of incremented.&#34;&#34;&#34;
    SIMPLELNS = _pywrapcp.Solver_SIMPLELNS
    r&#34;&#34;&#34; Operator which defines one neighbor per variable. Each neighbor relaxes one variable. When a new solution is found the neighborhood is rebuilt from scratch. Consider for instance variables x and y. First x is relaxed and the solver is looking for the best possible solution (with only x relaxed). Then y is relaxed, and the solver is looking for a new solution. If a new solution is found, then the next variable to be relaxed is x.&#34;&#34;&#34;
    GE = _pywrapcp.Solver_GE
    r&#34;&#34;&#34; Move is accepted when the current objective value &gt;= objective.Min.&#34;&#34;&#34;
    LE = _pywrapcp.Solver_LE
    r&#34;&#34;&#34; Move is accepted when the current objective value &lt;= objective.Max.&#34;&#34;&#34;
    EQ = _pywrapcp.Solver_EQ
    r&#34;&#34;&#34; Move is accepted when the current objective value is in the interval objective.Min .. objective.Max.&#34;&#34;&#34;
    DELAYED_PRIORITY = _pywrapcp.Solver_DELAYED_PRIORITY
    r&#34;&#34;&#34; DELAYED_PRIORITY is the lowest priority: Demons will be processed after VAR_PRIORITY and NORMAL_PRIORITY demons.&#34;&#34;&#34;
    VAR_PRIORITY = _pywrapcp.Solver_VAR_PRIORITY
    r&#34;&#34;&#34; VAR_PRIORITY is between DELAYED_PRIORITY and NORMAL_PRIORITY.&#34;&#34;&#34;
    NORMAL_PRIORITY = _pywrapcp.Solver_NORMAL_PRIORITY
    r&#34;&#34;&#34; NORMAL_PRIORITY is the highest priority: Demons will be processed first.&#34;&#34;&#34;

    def __init__(self, *args):
        _pywrapcp.Solver_swiginit(self, _pywrapcp.new_Solver(*args))

        self.__python_constraints = []



    __swig_destroy__ = _pywrapcp.delete_Solver

    def Parameters(self) -&gt; &#34;operations_research::ConstraintSolverParameters&#34;:
        r&#34;&#34;&#34; Stored Parameters.&#34;&#34;&#34;
        return _pywrapcp.Solver_Parameters(self)

    @staticmethod
    def DefaultSolverParameters() -&gt; &#34;operations_research::ConstraintSolverParameters&#34;:
        r&#34;&#34;&#34; Create a ConstraintSolverParameters proto with all the default values.&#34;&#34;&#34;
        return _pywrapcp.Solver_DefaultSolverParameters()

    def AddConstraint(self, c: &#34;Constraint&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
        Adds the constraint &#39;c&#39; to the model. After calling this method, and until there is a backtrack that undoes the addition, any assignment of variables to values must satisfy the given constraint in order to be considered feasible. There are two fairly different use cases: - the most common use case is modeling: the given constraint is really part of the problem that the user is trying to solve. In this use case, AddConstraint is called outside of search (i.e., with.. code-block:: c++

           state() == OUTSIDE_SEARCH). Most users should only use AddConstraint in this way. In this case, the constraint will belong to the model forever: it cannot not be removed by backtracking. - a rarer use case is that &#39;c&#39; is not a real constraint of the model. It may be a constraint generated by a branching decision (a constraint whose goal is to restrict the search space), a symmetry breaking constraint (a constraint that does restrict the search space, but in a way that cannot have an impact on the quality of the solutions in the subtree), or an inferred constraint that, while having no semantic value to the model (it does not restrict the set of solutions), is worth having because we believe it may strengthen the propagation. In these cases, it happens that the constraint is added during the search (i.e., with state() == IN_SEARCH or state() == IN_ROOT_NODE). When a constraint is added during a search, it applies only to the subtree of the search tree rooted at the current node, and will be automatically removed by backtracking. This method does not take ownership of the constraint. If the constraint has been created by any factory method (Solver::MakeXXX), it will automatically be deleted. However, power users who implement their own constraints should do: solver.AddConstraint(solver.RevAlloc(new MyConstraint(...));
        &#34;&#34;&#34;
        return _pywrapcp.Solver_AddConstraint(self, c)

    def Solve(self, *args) -&gt; &#34;bool&#34;:
        return _pywrapcp.Solver_Solve(self, *args)

    def NewSearch(self, *args) -&gt; &#34;void&#34;:
        return _pywrapcp.Solver_NewSearch(self, *args)

    def NextSolution(self) -&gt; &#34;bool&#34;:
        return _pywrapcp.Solver_NextSolution(self)

    def RestartSearch(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Solver_RestartSearch(self)

    def EndSearch(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Solver_EndSearch(self)

    def SolveAndCommit(self, *args) -&gt; &#34;bool&#34;:
        return _pywrapcp.Solver_SolveAndCommit(self, *args)

    def CheckAssignment(self, solution: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Checks whether the given assignment satisfies all relevant constraints.&#34;&#34;&#34;
        return _pywrapcp.Solver_CheckAssignment(self, solution)

    def CheckConstraint(self, ct: &#34;Constraint&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34; Checks whether adding this constraint will lead to an immediate failure. It will return false if the model is already inconsistent, or if adding the constraint makes it inconsistent.&#34;&#34;&#34;
        return _pywrapcp.Solver_CheckConstraint(self, ct)

    def Fail(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Abandon the current branch in the search tree. A backtrack will follow.&#34;&#34;&#34;
        return _pywrapcp.Solver_Fail(self)

    @staticmethod
    def MemoryUsage() -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Current memory usage in bytes&#34;&#34;&#34;
        return _pywrapcp.Solver_MemoryUsage()

    def WallTime(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; DEPRECATED: Use Now() instead. Time elapsed, in ms since the creation of the solver.&#34;&#34;&#34;
        return _pywrapcp.Solver_WallTime(self)

    def Branches(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; The number of branches explored since the creation of the solver.&#34;&#34;&#34;
        return _pywrapcp.Solver_Branches(self)

    def Solutions(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; The number of solutions found since the start of the search.&#34;&#34;&#34;
        return _pywrapcp.Solver_Solutions(self)

    def Failures(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; The number of failures encountered since the creation of the solver.&#34;&#34;&#34;
        return _pywrapcp.Solver_Failures(self)

    def AcceptedNeighbors(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; The number of accepted neighbors.&#34;&#34;&#34;
        return _pywrapcp.Solver_AcceptedNeighbors(self)

    def Stamp(self) -&gt; &#34;uint64&#34;:
        r&#34;&#34;&#34; The stamp indicates how many moves in the search tree we have performed. It is useful to detect if we need to update same lazy structures.&#34;&#34;&#34;
        return _pywrapcp.Solver_Stamp(self)

    def FailStamp(self) -&gt; &#34;uint64&#34;:
        r&#34;&#34;&#34; The fail_stamp() is incremented after each backtrack.&#34;&#34;&#34;
        return _pywrapcp.Solver_FailStamp(self)

    def IntVar(self, *args) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        MakeIntVar will create the best range based int var for the bounds given.

        |

        *Overload 2:*
        MakeIntVar will create a variable with the given sparse domain.

        |

        *Overload 3:*
        MakeIntVar will create a variable with the given sparse domain.

        |

        *Overload 4:*
        MakeIntVar will create the best range based int var for the bounds given.

        |

        *Overload 5:*
        MakeIntVar will create a variable with the given sparse domain.

        |

        *Overload 6:*
        MakeIntVar will create a variable with the given sparse domain.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_IntVar(self, *args)

    def BoolVar(self, *args) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        MakeBoolVar will create a variable with a {0, 1} domain.

        |

        *Overload 2:*
        MakeBoolVar will create a variable with a {0, 1} domain.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_BoolVar(self, *args)

    def IntConst(self, *args) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        IntConst will create a constant expression.

        |

        *Overload 2:*
        IntConst will create a constant expression.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_IntConst(self, *args)

    def Sum(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; sum of all vars.&#34;&#34;&#34;
        return _pywrapcp.Solver_Sum(self, vars)

    def ScalProd(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        scalar product

        |

        *Overload 2:*
        scalar product
        &#34;&#34;&#34;
        return _pywrapcp.Solver_ScalProd(self, *args)

    def MonotonicElement(self, values: &#34;operations_research::Solver::IndexEvaluator1&#34;, increasing: &#34;bool&#34;, index: &#34;IntVar&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; Function based element. The constraint takes ownership of the callback.  The callback must be monotonic. It must be able to cope with any possible value in the domain of &#39;index&#39; (potentially negative ones too). Furtermore, monotonicity is not checked. Thus giving a non-monotonic function, or specifying an incorrect increasing parameter will result in undefined behavior.&#34;&#34;&#34;
        return _pywrapcp.Solver_MonotonicElement(self, values, increasing, index)

    def Element(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        values[index]

        |

        *Overload 2:*
        values[index]

        |

        *Overload 3:*
        Function-based element. The constraint takes ownership of the callback. The callback must be able to cope with any possible value in the domain of &#39;index&#39; (potentially negative ones too).

        |

        *Overload 4:*
        2D version of function-based element expression, values(expr1, expr2).

        |

        *Overload 5:*
        vars[expr]
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Element(self, *args)

    def IndexExpression(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; Returns the expression expr such that vars[expr] == value. It assumes that vars are all different.&#34;&#34;&#34;
        return _pywrapcp.Solver_IndexExpression(self, vars, value)

    def Min(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        std::min(vars)

        |

        *Overload 2:*
        std::min (left, right)

        |

        *Overload 3:*
        std::min(expr, value)

        |

        *Overload 4:*
        std::min(expr, value)
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Min(self, *args)

    def Max(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        std::max(vars)

        |

        *Overload 2:*
        std::max(left, right)

        |

        *Overload 3:*
        std::max(expr, value)

        |

        *Overload 4:*
        std::max(expr, value)
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Max(self, *args)

    def ConvexPiecewiseExpr(self, expr: &#34;IntExpr&#34;, early_cost: &#34;int64&#34;, early_date: &#34;int64&#34;, late_date: &#34;int64&#34;, late_cost: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; Convex piecewise function.&#34;&#34;&#34;
        return _pywrapcp.Solver_ConvexPiecewiseExpr(self, expr, early_cost, early_date, late_date, late_cost)

    def SemiContinuousExpr(self, expr: &#34;IntExpr&#34;, fixed_charge: &#34;int64&#34;, step: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; Semi continuous Expression (x &lt;= 0 -&gt; f(x) = 0; x &gt; 0 -&gt; f(x) = ax + b) a &gt;= 0 and b &gt;= 0&#34;&#34;&#34;
        return _pywrapcp.Solver_SemiContinuousExpr(self, expr, fixed_charge, step)

    def ConditionalExpression(self, condition: &#34;IntVar&#34;, expr: &#34;IntExpr&#34;, unperformed_value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        r&#34;&#34;&#34; Conditional Expr condition ? expr : unperformed_value&#34;&#34;&#34;
        return _pywrapcp.Solver_ConditionalExpression(self, condition, expr, unperformed_value)

    def TrueConstraint(self) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; This constraint always succeeds.&#34;&#34;&#34;
        return _pywrapcp.Solver_TrueConstraint(self)

    def FalseConstraint(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_FalseConstraint(self, *args)

    def IsEqualCstCt(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;, boolvar: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; boolvar == (var == value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsEqualCstCt(self, var, value, boolvar)

    def IsEqualCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (var == value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsEqualCstVar(self, var, value)

    def IsEqualCt(self, v1: &#34;IntExpr&#34;, v2: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (v1 == v2)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsEqualCt(self, v1, v2, b)

    def IsEqualVar(self, v1: &#34;IntExpr&#34;, v2: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (v1 == v2)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsEqualVar(self, v1, v2)

    def IsDifferentCstCt(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;, boolvar: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; boolvar == (var != value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsDifferentCstCt(self, var, value, boolvar)

    def IsDifferentCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (var != value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsDifferentCstVar(self, var, value)

    def IsDifferentVar(self, v1: &#34;IntExpr&#34;, v2: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (v1 != v2)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsDifferentVar(self, v1, v2)

    def IsDifferentCt(self, v1: &#34;IntExpr&#34;, v2: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (v1 != v2)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsDifferentCt(self, v1, v2, b)

    def IsLessOrEqualCstCt(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;, boolvar: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; boolvar == (var &lt;= value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessOrEqualCstCt(self, var, value, boolvar)

    def IsLessOrEqualCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (var &lt;= value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessOrEqualCstVar(self, var, value)

    def IsLessOrEqualVar(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (left &lt;= right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessOrEqualVar(self, left, right)

    def IsLessOrEqualCt(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (left &lt;= right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessOrEqualCt(self, left, right, b)

    def IsGreaterOrEqualCstCt(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;, boolvar: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; boolvar == (var &gt;= value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterOrEqualCstCt(self, var, value, boolvar)

    def IsGreaterOrEqualCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (var &gt;= value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterOrEqualCstVar(self, var, value)

    def IsGreaterOrEqualVar(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (left &gt;= right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterOrEqualVar(self, left, right)

    def IsGreaterOrEqualCt(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (left &gt;= right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterOrEqualCt(self, left, right, b)

    def IsGreaterCstCt(self, v: &#34;IntExpr&#34;, c: &#34;int64&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (v &gt; c)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterCstCt(self, v, c, b)

    def IsGreaterCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (var &gt; value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterCstVar(self, var, value)

    def IsGreaterVar(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (left &gt; right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterVar(self, left, right)

    def IsGreaterCt(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (left &gt; right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsGreaterCt(self, left, right, b)

    def IsLessCstCt(self, v: &#34;IntExpr&#34;, c: &#34;int64&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (v &lt; c)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessCstCt(self, v, c, b)

    def IsLessCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (var &lt; value)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessCstVar(self, var, value)

    def IsLessVar(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        r&#34;&#34;&#34; status var of (left &lt; right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessVar(self, left, right)

    def IsLessCt(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (left &lt; right)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsLessCt(self, left, right, b)

    def SumLessOrEqual(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, cst: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Variation on arrays.&#34;&#34;&#34;
        return _pywrapcp.Solver_SumLessOrEqual(self, vars, cst)

    def SumGreaterOrEqual(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, cst: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_SumGreaterOrEqual(self, vars, cst)

    def SumEquality(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_SumEquality(self, *args)

    def ScalProdEquality(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_ScalProdEquality(self, *args)

    def ScalProdGreaterOrEqual(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_ScalProdGreaterOrEqual(self, *args)

    def ScalProdLessOrEqual(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_ScalProdLessOrEqual(self, *args)

    def MinEquality(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, min_var: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_MinEquality(self, vars, min_var)

    def MaxEquality(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, max_var: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_MaxEquality(self, vars, max_var)

    def ElementEquality(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_ElementEquality(self, *args)

    def AbsEquality(self, var: &#34;IntVar&#34;, abs_var: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates the constraint abs(var) == abs_var.&#34;&#34;&#34;
        return _pywrapcp.Solver_AbsEquality(self, var, abs_var)

    def IndexOfConstraint(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, index: &#34;IntVar&#34;, target: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; This constraint is a special case of the element constraint with an array of integer variables, where the variables are all different and the index variable is constrained such that vars[index] == target.&#34;&#34;&#34;
        return _pywrapcp.Solver_IndexOfConstraint(self, vars, index, target)

    def ConstraintInitialPropagateCallback(self, ct: &#34;Constraint&#34;) -&gt; &#34;operations_research::Demon *&#34;:
        r&#34;&#34;&#34; This method is a specialized case of the MakeConstraintDemon method to call the InitiatePropagate of the constraint &#39;ct&#39;.&#34;&#34;&#34;
        return _pywrapcp.Solver_ConstraintInitialPropagateCallback(self, ct)

    def DelayedConstraintInitialPropagateCallback(self, ct: &#34;Constraint&#34;) -&gt; &#34;operations_research::Demon *&#34;:
        r&#34;&#34;&#34; This method is a specialized case of the MakeConstraintDemon method to call the InitiatePropagate of the constraint &#39;ct&#39; with low priority.&#34;&#34;&#34;
        return _pywrapcp.Solver_DelayedConstraintInitialPropagateCallback(self, ct)

    def ClosureDemon(self, closure: &#34;operations_research::Solver::Closure&#34;) -&gt; &#34;operations_research::Demon *&#34;:
        r&#34;&#34;&#34; Creates a demon from a closure.&#34;&#34;&#34;
        return _pywrapcp.Solver_ClosureDemon(self, closure)

    def BetweenCt(self, expr: &#34;IntExpr&#34;, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; (l &lt;= expr &lt;= u)&#34;&#34;&#34;
        return _pywrapcp.Solver_BetweenCt(self, expr, l, u)

    def IsBetweenCt(self, expr: &#34;IntExpr&#34;, l: &#34;int64&#34;, u: &#34;int64&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; b == (l &lt;= expr &lt;= u)&#34;&#34;&#34;
        return _pywrapcp.Solver_IsBetweenCt(self, expr, l, u, b)

    def IsBetweenVar(self, v: &#34;IntExpr&#34;, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.Solver_IsBetweenVar(self, v, l, u)

    def MemberCt(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_MemberCt(self, *args)

    def NotMemberCt(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        expr not in set.

        |

        *Overload 2:*
        expr should not be in the list of forbidden intervals [start[i]..end[i]].

        |

        *Overload 3:*
        expr should not be in the list of forbidden intervals [start[i]..end[i]].
        &#34;&#34;&#34;
        return _pywrapcp.Solver_NotMemberCt(self, *args)

    def IsMemberCt(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_IsMemberCt(self, *args)

    def IsMemberVar(self, *args) -&gt; &#34;operations_research::IntVar *&#34;:
        return _pywrapcp.Solver_IsMemberVar(self, *args)

    def Count(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        |{i | vars[i] == value}| == max_count

        |

        *Overload 2:*
        |{i | vars[i] == value}| == max_count
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Count(self, *args)

    def Distribute(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]

        |

        *Overload 2:*
        Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]

        |

        *Overload 3:*
        Aggregated version of count:  |{i | v[i] == j}| == cards[j]

        |

        *Overload 4:*
        Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1: card_min &lt;= |{i | v[i] == j}| &lt;= card_max

        |

        *Overload 5:*
        Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:    card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]

        |

        *Overload 6:*
        Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:    card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]

        |

        *Overload 7:*
        Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:    card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]

        |

        *Overload 8:*
        Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:    card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Distribute(self, *args)

    def Deviation(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, deviation_var: &#34;IntVar&#34;, total_sum: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Deviation constraint: sum_i |n * vars[i] - total_sum| &lt;= deviation_var and sum_i vars[i] == total_sum n = #vars&#34;&#34;&#34;
        return _pywrapcp.Solver_Deviation(self, vars, deviation_var, total_sum)

    def AllDifferent(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        All variables are pairwise different. This corresponds to the stronger version of the propagation algorithm.

        |

        *Overload 2:*
        All variables are pairwise different.  If &#39;stronger_propagation&#39; is true, stronger, and potentially slower propagation will occur. This API will be deprecated in the future.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_AllDifferent(self, *args)

    def AllDifferentExcept(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, escape_value: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; All variables are pairwise different, unless they are assigned to the escape value.&#34;&#34;&#34;
        return _pywrapcp.Solver_AllDifferentExcept(self, vars, escape_value)

    def SortingConstraint(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, sorted: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates a constraint binding the arrays of variables &#34;vars&#34; and &#34;sorted_vars&#34;: sorted_vars[0] must be equal to the minimum of all variables in vars, and so on: the value of sorted_vars[i] must be equal to the i-th value of variables invars. This constraint propagates in both directions: from &#34;vars&#34; to &#34;sorted_vars&#34; and vice-versa. Behind the scenes, this constraint maintains that:   - sorted is always increasing.   - whatever the values of vars, there exists a permutation that     injects its values into the sorted variables. For more info, please have a look at:   https://mpi-inf.mpg.de/~mehlhorn/ftp/Mehlhorn-Thiel.pdf&#34;&#34;&#34;
        return _pywrapcp.Solver_SortingConstraint(self, vars, sorted)

    def LexicalLess(self, left: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, right: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates a constraint that enforces that left is lexicographically less than right.&#34;&#34;&#34;
        return _pywrapcp.Solver_LexicalLess(self, left, right)

    def LexicalLessOrEqual(self, left: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, right: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates a constraint that enforces that left is lexicographically less than or equal to right.&#34;&#34;&#34;
        return _pywrapcp.Solver_LexicalLessOrEqual(self, left, right)

    def InversePermutationConstraint(self, left: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, right: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates a constraint that enforces that &#39;left&#39; and &#39;right&#39; both represent permutations of [0..left.size()-1], and that &#39;right&#39; is the inverse permutation of &#39;left&#39;, i.e. for all i in [0..left.size()-1], right[left[i]] = i.&#34;&#34;&#34;
        return _pywrapcp.Solver_InversePermutationConstraint(self, left, right)

    def NullIntersect(self, first_vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, second_vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates a constraint that states that all variables in the first vector are different from all variables in the second group. Thus the set of values in the first vector does not intersect with the set of values in the second vector.&#34;&#34;&#34;
        return _pywrapcp.Solver_NullIntersect(self, first_vars, second_vars)

    def NullIntersectExcept(self, first_vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, second_vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, escape_value: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Creates a constraint that states that all variables in the first vector are different from all variables from the second group, unless they are assigned to the escape value. Thus the set of values in the first vector minus the escape value does not intersect with the set of values in the second vector.&#34;&#34;&#34;
        return _pywrapcp.Solver_NullIntersectExcept(self, first_vars, second_vars, escape_value)

    def Circuit(self, nexts: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Force the &#34;nexts&#34; variable to create a complete Hamiltonian path.&#34;&#34;&#34;
        return _pywrapcp.Solver_Circuit(self, nexts)

    def SubCircuit(self, nexts: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Force the &#34;nexts&#34; variable to create a complete Hamiltonian path for those that do not loop upon themselves.&#34;&#34;&#34;
        return _pywrapcp.Solver_SubCircuit(self, nexts)

    def DelayedPathCumul(self, nexts: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, active: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, cumuls: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, transits: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; Delayed version of the same constraint: propagation on the nexts variables is delayed until all constraints have propagated.&#34;&#34;&#34;
        return _pywrapcp.Solver_DelayedPathCumul(self, nexts, active, cumuls, transits)

    def PathCumul(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Creates a constraint which accumulates values along a path such that: cumuls[next[i]] = cumuls[i] + transits[i]. Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem.

        |

        *Overload 2:*
        Creates a constraint which accumulates values along a path such that: cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]). Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem. Ownership of transit_evaluator is taken and it must be a repeatable callback.

        |

        *Overload 3:*
        Creates a constraint which accumulates values along a path such that: cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]) + slacks[i]. Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem. Ownership of transit_evaluator is taken and it must be a repeatable callback.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_PathCumul(self, *args)

    def AllowedAssignments(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This method creates a constraint where the graph of the relation between the variables is given in extension. There are &#39;arity&#39; variables involved in the relation and the graph is given by a integer tuple set.

        |

        *Overload 2:*
        Compatibility layer for Python API.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_AllowedAssignments(self, *args)

    def TransitionConstraint(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_TransitionConstraint(self, *args)

    def NonOverlappingBoxesConstraint(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_NonOverlappingBoxesConstraint(self, *args)

    def Pack(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, number_of_bins: &#34;int&#34;) -&gt; &#34;operations_research::Pack *&#34;:
        r&#34;&#34;&#34; This constraint packs all variables onto &#39;number_of_bins&#39; variables.  For any given variable, a value of &#39;number_of_bins&#39; indicates that the variable is not assigned to any bin. Dimensions, i.e., cumulative constraints on this packing, can be added directly from the pack class.&#34;&#34;&#34;
        return _pywrapcp.Solver_Pack(self, vars, number_of_bins)

    def FixedDurationIntervalVar(self, *args) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Creates an interval var with a fixed duration. The duration must be greater than 0. If optional is true, then the interval can be performed or unperformed. If optional is false, then the interval is always performed.

        |

        *Overload 2:*
        Creates a performed interval var with a fixed duration. The duration must be greater than 0.

        |

        *Overload 3:*
        Creates an interval var with a fixed duration, and performed_variable. The duration must be greater than 0.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_FixedDurationIntervalVar(self, *args)

    def FixedInterval(self, start: &#34;int64&#34;, duration: &#34;int64&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates a fixed and performed interval.&#34;&#34;&#34;
        return _pywrapcp.Solver_FixedInterval(self, start, duration, name)

    def IntervalVar(self, start_min: &#34;int64&#34;, start_max: &#34;int64&#34;, duration_min: &#34;int64&#34;, duration_max: &#34;int64&#34;, end_min: &#34;int64&#34;, end_max: &#34;int64&#34;, optional: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates an interval var by specifying the bounds on start, duration, and end.&#34;&#34;&#34;
        return _pywrapcp.Solver_IntervalVar(self, start_min, start_max, duration_min, duration_max, end_min, end_max, optional, name)

    def MirrorInterval(self, interval_var: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates an interval var that is the mirror image of the given one, that is, the interval var obtained by reversing the axis.&#34;&#34;&#34;
        return _pywrapcp.Solver_MirrorInterval(self, interval_var)

    def FixedDurationStartSyncedOnStartIntervalVar(self, interval_var: &#34;IntervalVar&#34;, duration: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates an interval var with a fixed duration whose start is synchronized with the start of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.&#34;&#34;&#34;
        return _pywrapcp.Solver_FixedDurationStartSyncedOnStartIntervalVar(self, interval_var, duration, offset)

    def FixedDurationStartSyncedOnEndIntervalVar(self, interval_var: &#34;IntervalVar&#34;, duration: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates an interval var with a fixed duration whose start is synchronized with the end of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.&#34;&#34;&#34;
        return _pywrapcp.Solver_FixedDurationStartSyncedOnEndIntervalVar(self, interval_var, duration, offset)

    def FixedDurationEndSyncedOnStartIntervalVar(self, interval_var: &#34;IntervalVar&#34;, duration: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates an interval var with a fixed duration whose end is synchronized with the start of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.&#34;&#34;&#34;
        return _pywrapcp.Solver_FixedDurationEndSyncedOnStartIntervalVar(self, interval_var, duration, offset)

    def FixedDurationEndSyncedOnEndIntervalVar(self, interval_var: &#34;IntervalVar&#34;, duration: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates an interval var with a fixed duration whose end is synchronized with the end of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.&#34;&#34;&#34;
        return _pywrapcp.Solver_FixedDurationEndSyncedOnEndIntervalVar(self, interval_var, duration, offset)

    def IntervalRelaxedMin(self, interval_var: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates and returns an interval variable that wraps around the given one, relaxing the min start and end. Relaxing means making unbounded when optional. If the variable is non-optional, this method returns interval_var. More precisely, such an interval variable behaves as follows: * When the underlying must be performed, the returned interval variable     behaves exactly as the underlying; * When the underlying may or may not be performed, the returned interval     variable behaves like the underlying, except that it is unbounded on     the min side; * When the underlying cannot be performed, the returned interval variable     is of duration 0 and must be performed in an interval unbounded on     both sides. This is very useful to implement propagators that may only modify the start max or end max.&#34;&#34;&#34;
        return _pywrapcp.Solver_IntervalRelaxedMin(self, interval_var)

    def IntervalRelaxedMax(self, interval_var: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
        r&#34;&#34;&#34; Creates and returns an interval variable that wraps around the given one, relaxing the max start and end. Relaxing means making unbounded when optional. If the variable is non optional, this method returns interval_var. More precisely, such an interval variable behaves as follows: * When the underlying must be performed, the returned interval variable     behaves exactly as the underlying; * When the underlying may or may not be performed, the returned interval     variable behaves like the underlying, except that it is unbounded on     the max side; * When the underlying cannot be performed, the returned interval variable     is of duration 0 and must be performed in an interval unbounded on     both sides. This is very useful for implementing propagators that may only modify the start min or end min.&#34;&#34;&#34;
        return _pywrapcp.Solver_IntervalRelaxedMax(self, interval_var)

    def TemporalDisjunction(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This constraint implements a temporal disjunction between two interval vars t1 and t2. &#39;alt&#39; indicates which alternative was chosen (alt == 0 is equivalent to t1 before t2).

        |

        *Overload 2:*
        This constraint implements a temporal disjunction between two interval vars.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_TemporalDisjunction(self, *args)

    def DisjunctiveConstraint(self, intervals: &#34;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::DisjunctiveConstraint *&#34;:
        r&#34;&#34;&#34; This constraint forces all interval vars into an non-overlapping sequence. Intervals with zero duration can be scheduled anywhere.&#34;&#34;&#34;
        return _pywrapcp.Solver_DisjunctiveConstraint(self, intervals, name)

    def Cumulative(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This constraint forces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.

        |

        *Overload 2:*
        This constraint forces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.

        |

        *Overload 3:*
        This constraint forces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.

        |

        *Overload 4:*
        This constraint enforces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.

        |

        *Overload 5:*
        This constraint enforces that, for any integer t, the sum of demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should be positive.

        |

        *Overload 6:*
        This constraint enforces that, for any integer t, the sum of demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should be positive.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Cumulative(self, *args)

    def Cover(self, vars: &#34;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&#34;, target_var: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
        r&#34;&#34;&#34; This constraint states that the target_var is the convex hull of the intervals. If none of the interval variables is performed, then the target var is unperformed too. Also, if the target variable is unperformed, then all the intervals variables are unperformed too.&#34;&#34;&#34;
        return _pywrapcp.Solver_Cover(self, vars, target_var)

    def Assignment(self, *args) -&gt; &#34;operations_research::Assignment *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        This method creates an empty assignment.

        |

        *Overload 2:*
        This method creates an assignment which is a copy of &#39;a&#39;.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Assignment(self, *args)

    def FirstSolutionCollector(self, *args) -&gt; &#34;operations_research::SolutionCollector *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Collect the first solution of the search.

        |

        *Overload 2:*
        Collect the first solution of the search. The variables will need to be added later.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_FirstSolutionCollector(self, *args)

    def LastSolutionCollector(self, *args) -&gt; &#34;operations_research::SolutionCollector *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Collect the last solution of the search.

        |

        *Overload 2:*
        Collect the last solution of the search. The variables will need to be added later.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_LastSolutionCollector(self, *args)

    def BestValueSolutionCollector(self, *args) -&gt; &#34;operations_research::SolutionCollector *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Collect the solution corresponding to the optimal value of the objective of &#39;assignment&#39;; if &#39;assignment&#39; does not have an objective no solution is collected. This collector only collects one solution corresponding to the best objective value (the first one found).

        |

        *Overload 2:*
        Collect the solution corresponding to the optimal value of the objective of &#39;assignment&#39;; if &#39;assignment&#39; does not have an objective no solution is collected. This collector only collects one solution corresponding to the best objective value (the first one found). The variables will need to be added later.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_BestValueSolutionCollector(self, *args)

    def AllSolutionCollector(self, *args) -&gt; &#34;operations_research::SolutionCollector *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Collect all solutions of the search.

        |

        *Overload 2:*
        Collect all solutions of the search. The variables will need to be added later.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_AllSolutionCollector(self, *args)

    def Minimize(self, v: &#34;IntVar&#34;, step: &#34;int64&#34;) -&gt; &#34;operations_research::OptimizeVar *&#34;:
        r&#34;&#34;&#34; Creates a minimization objective.&#34;&#34;&#34;
        return _pywrapcp.Solver_Minimize(self, v, step)

    def Maximize(self, v: &#34;IntVar&#34;, step: &#34;int64&#34;) -&gt; &#34;operations_research::OptimizeVar *&#34;:
        r&#34;&#34;&#34; Creates a maximization objective.&#34;&#34;&#34;
        return _pywrapcp.Solver_Maximize(self, v, step)

    def Optimize(self, maximize: &#34;bool&#34;, v: &#34;IntVar&#34;, step: &#34;int64&#34;) -&gt; &#34;operations_research::OptimizeVar *&#34;:
        r&#34;&#34;&#34; Creates a objective with a given sense (true = maximization).&#34;&#34;&#34;
        return _pywrapcp.Solver_Optimize(self, maximize, v, step)

    def WeightedMinimize(self, *args) -&gt; &#34;operations_research::OptimizeVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Creates a minimization weighted objective. The actual objective is scalar_prod(sub_objectives, weights).

        |

        *Overload 2:*
        Creates a minimization weighted objective. The actual objective is scalar_prod(sub_objectives, weights).
        &#34;&#34;&#34;
        return _pywrapcp.Solver_WeightedMinimize(self, *args)

    def WeightedMaximize(self, *args) -&gt; &#34;operations_research::OptimizeVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Creates a maximization weigthed objective.

        |

        *Overload 2:*
        Creates a maximization weigthed objective.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_WeightedMaximize(self, *args)

    def WeightedOptimize(self, *args) -&gt; &#34;operations_research::OptimizeVar *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Creates a weighted objective with a given sense (true = maximization).

        |

        *Overload 2:*
        Creates a weighted objective with a given sense (true = maximization).
        &#34;&#34;&#34;
        return _pywrapcp.Solver_WeightedOptimize(self, *args)

    def TabuSearch(self, maximize: &#34;bool&#34;, v: &#34;IntVar&#34;, step: &#34;int64&#34;, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, keep_tenure: &#34;int64&#34;, forbid_tenure: &#34;int64&#34;, tabu_factor: &#34;double&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        r&#34;&#34;&#34; MetaHeuristics which try to get the search out of local optima. Creates a Tabu Search monitor. In the context of local search the behavior is similar to MakeOptimize(), creating an objective in a given sense. The behavior differs once a local optimum is reached: thereafter solutions which degrade the value of the objective are allowed if they are not &#34;tabu&#34;. A solution is &#34;tabu&#34; if it doesn&#39;t respect the following rules: - improving the best solution found so far - variables in the &#34;keep&#34; list must keep their value, variables in the &#34;forbid&#34; list must not take the value they have in the list. Variables with new values enter the tabu lists after each new solution found and leave the lists after a given number of iterations (called tenure). Only the variables passed to the method can enter the lists. The tabu criterion is softened by the tabu factor which gives the number of &#34;tabu&#34; violations which is tolerated; a factor of 1 means no violations allowed; a factor of 0 means all violations are allowed.&#34;&#34;&#34;
        return _pywrapcp.Solver_TabuSearch(self, maximize, v, step, vars, keep_tenure, forbid_tenure, tabu_factor)

    def SimulatedAnnealing(self, maximize: &#34;bool&#34;, v: &#34;IntVar&#34;, step: &#34;int64&#34;, initial_temperature: &#34;int64&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        r&#34;&#34;&#34; Creates a Simulated Annealing monitor.&#34;&#34;&#34;
        return _pywrapcp.Solver_SimulatedAnnealing(self, maximize, v, step, initial_temperature)

    def LubyRestart(self, scale_factor: &#34;int&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        r&#34;&#34;&#34; This search monitor will restart the search periodically. At the iteration n, it will restart after scale_factor * Luby(n) failures where Luby is the Luby Strategy (i.e. 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8...).&#34;&#34;&#34;
        return _pywrapcp.Solver_LubyRestart(self, scale_factor)

    def ConstantRestart(self, frequency: &#34;int&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        r&#34;&#34;&#34; This search monitor will restart the search periodically after &#39;frequency&#39; failures.&#34;&#34;&#34;
        return _pywrapcp.Solver_ConstantRestart(self, frequency)

    def TimeLimit(self, time_in_ms: &#34;int64&#34;) -&gt; &#34;operations_research::RegularLimit *&#34;:
        r&#34;&#34;&#34; Creates a search limit that constrains the running time given in milliseconds.&#34;&#34;&#34;
        return _pywrapcp.Solver_TimeLimit(self, time_in_ms)

    def BranchesLimit(self, branches: &#34;int64&#34;) -&gt; &#34;operations_research::RegularLimit *&#34;:
        r&#34;&#34;&#34; Creates a search limit that constrains the number of branches explored in the search tree.&#34;&#34;&#34;
        return _pywrapcp.Solver_BranchesLimit(self, branches)

    def FailuresLimit(self, failures: &#34;int64&#34;) -&gt; &#34;operations_research::RegularLimit *&#34;:
        r&#34;&#34;&#34; Creates a search limit that constrains the number of failures that can happen when exploring the search tree.&#34;&#34;&#34;
        return _pywrapcp.Solver_FailuresLimit(self, failures)

    def SolutionsLimit(self, solutions: &#34;int64&#34;) -&gt; &#34;operations_research::RegularLimit *&#34;:
        r&#34;&#34;&#34; Creates a search limit that constrains the number of solutions found during the search.&#34;&#34;&#34;
        return _pywrapcp.Solver_SolutionsLimit(self, solutions)

    def Limit(self, *args) -&gt; &#34;operations_research::SearchLimit *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Limits the search with the &#39;time&#39;, &#39;branches&#39;, &#39;failures&#39; and &#39;solutions&#39; limits.

        |

        *Overload 2:*
        Version reducing calls to wall timer by estimating number of remaining calls.

        |

        *Overload 3:*
        Creates a search limit which can either apply cumulatively or search-by-search.

        |

        *Overload 4:*
        Creates a search limit from its protobuf description

        |

        *Overload 5:*
        Creates a search limit that is reached when either of the underlying limit is reached. That is, the returned limit is more stringent than both argument limits.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_Limit(self, *args)

    def CustomLimit(self, limiter: &#34;std::function&lt; bool () &gt;&#34;) -&gt; &#34;operations_research::SearchLimit *&#34;:
        r&#34;&#34;&#34; Callback-based search limit. Search stops when limiter returns true; if this happens at a leaf the corresponding solution will be rejected.&#34;&#34;&#34;
        return _pywrapcp.Solver_CustomLimit(self, limiter)

    def SearchLog(self, *args) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        return _pywrapcp.Solver_SearchLog(self, *args)

    def SearchTrace(self, prefix: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        r&#34;&#34;&#34; Creates a search monitor that will trace precisely the behavior of the search. Use this only for low level debugging.&#34;&#34;&#34;
        return _pywrapcp.Solver_SearchTrace(self, prefix)

    def PrintModelVisitor(self) -&gt; &#34;operations_research::ModelVisitor *&#34;:
        r&#34;&#34;&#34; Prints the model.&#34;&#34;&#34;
        return _pywrapcp.Solver_PrintModelVisitor(self)

    def StatisticsModelVisitor(self) -&gt; &#34;operations_research::ModelVisitor *&#34;:
        r&#34;&#34;&#34; Displays some nice statistics on the model.&#34;&#34;&#34;
        return _pywrapcp.Solver_StatisticsModelVisitor(self)

    def AssignVariableValue(self, var: &#34;IntVar&#34;, val: &#34;int64&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        r&#34;&#34;&#34; Decisions.&#34;&#34;&#34;
        return _pywrapcp.Solver_AssignVariableValue(self, var, val)

    def VariableLessOrEqualValue(self, var: &#34;IntVar&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_VariableLessOrEqualValue(self, var, value)

    def VariableGreaterOrEqualValue(self, var: &#34;IntVar&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_VariableGreaterOrEqualValue(self, var, value)

    def SplitVariableDomain(self, var: &#34;IntVar&#34;, val: &#34;int64&#34;, start_with_lower_half: &#34;bool&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_SplitVariableDomain(self, var, val, start_with_lower_half)

    def AssignVariableValueOrFail(self, var: &#34;IntVar&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_AssignVariableValueOrFail(self, var, value)

    def AssignVariablesValues(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_AssignVariablesValues(self, vars, values)

    def FailDecision(self) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_FailDecision(self)

    def Decision(self, apply: &#34;operations_research::Solver::Action&#34;, refute: &#34;operations_research::Solver::Action&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        return _pywrapcp.Solver_Decision(self, apply, refute)

    def Compose(self, dbs: &#34;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_Compose(self, dbs)

    def Try(self, dbs: &#34;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_Try(self, dbs)

    def DefaultPhase(self, *args) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_DefaultPhase(self, *args)

    def ScheduleOrPostpone(self, var: &#34;IntervalVar&#34;, est: &#34;int64&#34;, marker: &#34;int64 *const&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        r&#34;&#34;&#34; Returns a decision that tries to schedule a task at a given time. On the Apply branch, it will set that interval var as performed and set its start to &#39;est&#39;. On the Refute branch, it will just update the &#39;marker&#39; to &#39;est&#39; + 1. This decision is used in the INTERVAL_SET_TIMES_FORWARD strategy.&#34;&#34;&#34;
        return _pywrapcp.Solver_ScheduleOrPostpone(self, var, est, marker)

    def ScheduleOrExpedite(self, var: &#34;IntervalVar&#34;, est: &#34;int64&#34;, marker: &#34;int64 *const&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        r&#34;&#34;&#34; Returns a decision that tries to schedule a task at a given time. On the Apply branch, it will set that interval var as performed and set its end to &#39;est&#39;. On the Refute branch, it will just update the &#39;marker&#39; to &#39;est&#39; - 1. This decision is used in the INTERVAL_SET_TIMES_BACKWARD strategy.&#34;&#34;&#34;
        return _pywrapcp.Solver_ScheduleOrExpedite(self, var, est, marker)

    def RankFirstInterval(self, sequence: &#34;SequenceVar&#34;, index: &#34;int&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        r&#34;&#34;&#34; Returns a decision that tries to rank first the ith interval var in the sequence variable.&#34;&#34;&#34;
        return _pywrapcp.Solver_RankFirstInterval(self, sequence, index)

    def RankLastInterval(self, sequence: &#34;SequenceVar&#34;, index: &#34;int&#34;) -&gt; &#34;operations_research::Decision *&#34;:
        r&#34;&#34;&#34; Returns a decision that tries to rank last the ith interval var in the sequence variable.&#34;&#34;&#34;
        return _pywrapcp.Solver_RankLastInterval(self, sequence, index)

    def Phase(self, *args) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_Phase(self, *args)

    def DecisionBuilderFromAssignment(self, assignment: &#34;Assignment&#34;, db: &#34;DecisionBuilder&#34;, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        r&#34;&#34;&#34; Returns a decision builder for which the left-most leaf corresponds to assignment, the rest of the tree being explored using &#39;db&#39;.&#34;&#34;&#34;
        return _pywrapcp.Solver_DecisionBuilderFromAssignment(self, assignment, db, vars)

    def ConstraintAdder(self, ct: &#34;Constraint&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        r&#34;&#34;&#34; Returns a decision builder that will add the given constraint to the model.&#34;&#34;&#34;
        return _pywrapcp.Solver_ConstraintAdder(self, ct)

    def SolveOnce(self, db: &#34;DecisionBuilder&#34;, monitors: &#34;std::vector&lt; operations_research::SearchMonitor * &gt; const &amp;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_SolveOnce(self, db, monitors)

    def NestedOptimize(self, *args) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_NestedOptimize(self, *args)

    def RestoreAssignment(self, assignment: &#34;Assignment&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        r&#34;&#34;&#34; Returns a DecisionBuilder which restores an Assignment (calls void Assignment::Restore())&#34;&#34;&#34;
        return _pywrapcp.Solver_RestoreAssignment(self, assignment)

    def StoreAssignment(self, assignment: &#34;Assignment&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        r&#34;&#34;&#34; Returns a DecisionBuilder which stores an Assignment (calls void Assignment::Store())&#34;&#34;&#34;
        return _pywrapcp.Solver_StoreAssignment(self, assignment)

    def Operator(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
        return _pywrapcp.Solver_Operator(self, *args)

    def RandomLnsOperator(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
        return _pywrapcp.Solver_RandomLnsOperator(self, *args)

    def MoveTowardTargetOperator(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Creates a local search operator that tries to move the assignment of some variables toward a target. The target is given as an Assignment. This operator generates neighbors in which the only difference compared to the current state is that one variable that belongs to the target assignment is set to its target value.

        |

        *Overload 2:*
        Creates a local search operator that tries to move the assignment of some variables toward a target. The target is given either as two vectors: a vector of variables and a vector of associated target values. The two vectors should be of the same length. This operator generates neighbors in which the only difference compared to the current state is that one variable that belongs to the given vector is set to its target value.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_MoveTowardTargetOperator(self, *args)

    def ConcatenateOperators(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
        return _pywrapcp.Solver_ConcatenateOperators(self, *args)

    def RandomConcatenateOperators(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
        r&#34;&#34;&#34;
        *Overload 1:*
        Randomized version of local search concatenator; calls a random operator at each call to MakeNextNeighbor().

        |

        *Overload 2:*
        Randomized version of local search concatenator; calls a random operator at each call to MakeNextNeighbor(). The provided seed is used to initialize the random number generator.
        &#34;&#34;&#34;
        return _pywrapcp.Solver_RandomConcatenateOperators(self, *args)

    def NeighborhoodLimit(self, op: &#34;LocalSearchOperator&#34;, limit: &#34;int64&#34;) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
        r&#34;&#34;&#34; Creates a local search operator that wraps another local search operator and limits the number of neighbors explored (i.e., calls to MakeNextNeighbor from the current solution (between two calls to Start()). When this limit is reached, MakeNextNeighbor() returns false. The counter is cleared when Start() is called.&#34;&#34;&#34;
        return _pywrapcp.Solver_NeighborhoodLimit(self, op, limit)

    def LocalSearchPhase(self, *args) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_LocalSearchPhase(self, *args)

    def LocalSearchPhaseParameters(self, *args) -&gt; &#34;operations_research::LocalSearchPhaseParameters *&#34;:
        return _pywrapcp.Solver_LocalSearchPhaseParameters(self, *args)

    def SearchDepth(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Gets the search depth of the current active search. Returns -1 if there is no active search opened.&#34;&#34;&#34;
        return _pywrapcp.Solver_SearchDepth(self)

    def SearchLeftDepth(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Gets the search left depth of the current active search. Returns -1 if there is no active search opened.&#34;&#34;&#34;
        return _pywrapcp.Solver_SearchLeftDepth(self)

    def SolveDepth(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Gets the number of nested searches. It returns 0 outside search, 1 during the top level search, 2 or more in case of nested searches.&#34;&#34;&#34;
        return _pywrapcp.Solver_SolveDepth(self)

    def Rand64(self, size: &#34;int64&#34;) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34; Returns a random value between 0 and &#39;size&#39; - 1;&#34;&#34;&#34;
        return _pywrapcp.Solver_Rand64(self, size)

    def Rand32(self, size: &#34;int32&#34;) -&gt; &#34;int32&#34;:
        r&#34;&#34;&#34; Returns a random value between 0 and &#39;size&#39; - 1;&#34;&#34;&#34;
        return _pywrapcp.Solver_Rand32(self, size)

    def ReSeed(self, seed: &#34;int32&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Reseed the solver random generator.&#34;&#34;&#34;
        return _pywrapcp.Solver_ReSeed(self, seed)

    def LocalSearchProfile(self) -&gt; &#34;std::string&#34;:
        r&#34;&#34;&#34; Returns local search profiling information in a human readable format. search profiles.&#34;&#34;&#34;
        return _pywrapcp.Solver_LocalSearchProfile(self)

    def Constraints(self) -&gt; &#34;int&#34;:
        r&#34;&#34;&#34; Counts the number of constraints that have been added to the solver before the search.&#34;&#34;&#34;
        return _pywrapcp.Solver_Constraints(self)

    def Accept(self, visitor: &#34;operations_research::ModelVisitor *const&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Accepts the given model visitor.&#34;&#34;&#34;
        return _pywrapcp.Solver_Accept(self, visitor)

    def FinishCurrentSearch(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; Tells the solver to kill or restart the current search.&#34;&#34;&#34;
        return _pywrapcp.Solver_FinishCurrentSearch(self)

    def RestartCurrentSearch(self) -&gt; &#34;void&#34;:
        return _pywrapcp.Solver_RestartCurrentSearch(self)

    def ShouldFail(self) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34; These methods are only useful for the SWIG wrappers, which need a way to externally cause the Solver to fail.&#34;&#34;&#34;
        return _pywrapcp.Solver_ShouldFail(self)

    def __str__(self) -&gt; &#34;std::string&#34;:
        return _pywrapcp.Solver___str__(self)

    def Add(self, ct):
      if isinstance(ct, PyConstraint):
        self.__python_constraints.append(ct)
      self.AddConstraint(ct)


    def TreeNoCycle(self, nexts: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, active: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, callback: &#34;operations_research::Solver::IndexFilter1&#34;=0) -&gt; &#34;operations_research::Constraint *&#34;:
        return _pywrapcp.Solver_TreeNoCycle(self, nexts, active, callback)

    def SearchLogWithCallback(self, period: &#34;int&#34;, callback: &#34;std::function&lt; std::string () &gt;&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        return _pywrapcp.Solver_SearchLogWithCallback(self, period, callback)

    def ElementFunction(self, values: &#34;std::function&lt; int64 (int64) &gt;&#34;, index: &#34;IntVar&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
        return _pywrapcp.Solver_ElementFunction(self, values, index)

    def VarEvalValStrPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_evaluator: &#34;std::function&lt; int64 (int64) &gt;&#34;, val_str: &#34;operations_research::Solver::IntValueStrategy&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_VarEvalValStrPhase(self, vars, var_evaluator, val_str)

    def VarStrValEvalPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_str: &#34;operations_research::Solver::IntVarStrategy&#34;, val_eval: &#34;operations_research::Solver::IndexEvaluator2&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_VarStrValEvalPhase(self, vars, var_str, val_eval)

    def VarEvalValEvalPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_eval: &#34;std::function&lt; int64 (int64) &gt;&#34;, val_eval: &#34;operations_research::Solver::IndexEvaluator2&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_VarEvalValEvalPhase(self, vars, var_eval, val_eval)

    def VarStrValEvalTieBreakPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_str: &#34;operations_research::Solver::IntVarStrategy&#34;, val_eval: &#34;operations_research::Solver::IndexEvaluator2&#34;, tie_breaker: &#34;std::function&lt; int64 (int64) &gt;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_VarStrValEvalTieBreakPhase(self, vars, var_str, val_eval, tie_breaker)

    def VarEvalValEvalTieBreakPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_eval: &#34;std::function&lt; int64 (int64) &gt;&#34;, val_eval: &#34;operations_research::Solver::IndexEvaluator2&#34;, tie_breaker: &#34;std::function&lt; int64 (int64) &gt;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_VarEvalValEvalTieBreakPhase(self, vars, var_eval, val_eval, tie_breaker)

    def EvalEvalStrPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, evaluator: &#34;operations_research::Solver::IndexEvaluator2&#34;, str: &#34;operations_research::Solver::EvaluatorStrategy&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_EvalEvalStrPhase(self, vars, evaluator, str)

    def EvalEvalStrTieBreakPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, evaluator: &#34;operations_research::Solver::IndexEvaluator2&#34;, tie_breaker: &#34;operations_research::Solver::IndexEvaluator1&#34;, str: &#34;operations_research::Solver::EvaluatorStrategy&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
        return _pywrapcp.Solver_EvalEvalStrTieBreakPhase(self, vars, evaluator, tie_breaker, str)

    def GuidedLocalSearch(self, *args) -&gt; &#34;operations_research::SearchMonitor *&#34;:
        return _pywrapcp.Solver_GuidedLocalSearch(self, *args)

    def SumObjectiveFilter(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, values: &#34;operations_research::Solver::IndexEvaluator2&#34;, filter_enum: &#34;operations_research::Solver::LocalSearchFilterBound&#34;) -&gt; &#34;operations_research::LocalSearchFilter *&#34;:
        return _pywrapcp.Solver_SumObjectiveFilter(self, vars, values, filter_enum)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pywrapcp.Solver.ASSIGN_CENTER_VALUE"><code class="name">var <span class="ident">ASSIGN_CENTER_VALUE</span></code></dt>
<dd>
<div class="desc"><p>Selects the first possible value which is the closest to the center of the domain of the selected variable. The center is defined as (min + max) / 2.</p></div>
</dd>
<dt id="pywrapcp.Solver.ASSIGN_MAX_VALUE"><code class="name">var <span class="ident">ASSIGN_MAX_VALUE</span></code></dt>
<dd>
<div class="desc"><p>Selects the max value of the selected variable.</p></div>
</dd>
<dt id="pywrapcp.Solver.ASSIGN_MIN_VALUE"><code class="name">var <span class="ident">ASSIGN_MIN_VALUE</span></code></dt>
<dd>
<div class="desc"><p>Selects the min value of the selected variable.</p></div>
</dd>
<dt id="pywrapcp.Solver.ASSIGN_RANDOM_VALUE"><code class="name">var <span class="ident">ASSIGN_RANDOM_VALUE</span></code></dt>
<dd>
<div class="desc"><p>Selects randomly one of the possible values of the selected variable.</p></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_FIRST_UNBOUND"><code class="name">var <span class="ident">CHOOSE_FIRST_UNBOUND</span></code></dt>
<dd>
<div class="desc"><p>Select the first unbound variable. Variables are considered in the order of the vector of IntVars used to create the selector.</p></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_HIGHEST_MAX"><code class="name">var <span class="ident">CHOOSE_HIGHEST_MAX</span></code></dt>
<dd>
<div class="desc"><p>Among unbound variables, select the variable with the highest maximal value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.</p></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_LOWEST_MIN"><code class="name">var <span class="ident">CHOOSE_LOWEST_MIN</span></code></dt>
<dd>
<div class="desc"><p>Among unbound variables, select the variable with the smallest minimal value. In case of a tie, the first one is selected, "first" defined by the order in the vector of IntVars used to create the selector.</p></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_MAX_REGRET_ON_MIN"><code class="name">var <span class="ident">CHOOSE_MAX_REGRET_ON_MIN</span></code></dt>
<dd>
<div class="desc"><p>Among unbound variables, select the variable with the largest gap between the first and the second values of the domain.</p></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_MAX_SIZE"><code class="name">var <span class="ident">CHOOSE_MAX_SIZE</span></code></dt>
<dd>
<div class="desc"><p>Among unbound variables, select the variable with the highest size. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.</p></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_MIN_SIZE"><code class="name">var <span class="ident">CHOOSE_MIN_SIZE</span></code></dt>
<dd>
<div class="desc"><p>Among unbound variables, select the variable with the smallest size. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.</p></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_MIN_SIZE_HIGHEST_MAX"><code class="name">var <span class="ident">CHOOSE_MIN_SIZE_HIGHEST_MAX</span></code></dt>
<dd>
<div class="desc"><p>Among unbound variables, select the variable with the smallest size, i.e., the smallest number of possible values. In case of a tie, the selected variable is the one with the highest max value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.</p></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_MIN_SIZE_HIGHEST_MIN"><code class="name">var <span class="ident">CHOOSE_MIN_SIZE_HIGHEST_MIN</span></code></dt>
<dd>
<div class="desc"><p>Among unbound variables, select the variable with the smallest size, i.e., the smallest number of possible values. In case of a tie, the selected variable is the one with the highest min value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.</p></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_MIN_SIZE_LOWEST_MAX"><code class="name">var <span class="ident">CHOOSE_MIN_SIZE_LOWEST_MAX</span></code></dt>
<dd>
<div class="desc"><p>Among unbound variables, select the variable with the smallest size, i.e., the smallest number of possible values. In case of a tie, the selected variables is the one with the lowest max value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.</p></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_MIN_SIZE_LOWEST_MIN"><code class="name">var <span class="ident">CHOOSE_MIN_SIZE_LOWEST_MIN</span></code></dt>
<dd>
<div class="desc"><p>Among unbound variables, select the variable with the smallest size, i.e., the smallest number of possible values. In case of a tie, the selected variables is the one with the lowest min value. In case of a tie, the first one is selected, first being defined by the order in the vector of IntVars used to create the selector.</p></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_MIN_SLACK_RANK_FORWARD"><code class="name">var <span class="ident">CHOOSE_MIN_SLACK_RANK_FORWARD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_PATH"><code class="name">var <span class="ident">CHOOSE_PATH</span></code></dt>
<dd>
<div class="desc"><p>Selects the next unbound variable on a path, the path being defined by the variables: var[i] corresponds to the index of the next of i.</p></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_RANDOM"><code class="name">var <span class="ident">CHOOSE_RANDOM</span></code></dt>
<dd>
<div class="desc"><p>Randomly select one of the remaining unbound variables.</p></div>
</dd>
<dt id="pywrapcp.Solver.CHOOSE_RANDOM_RANK_FORWARD"><code class="name">var <span class="ident">CHOOSE_RANDOM_RANK_FORWARD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.Solver.CROSS"><code class="name">var <span class="ident">CROSS</span></code></dt>
<dd>
<div class="desc"><p>Operator which cross exchanges the starting chains of 2 paths, including exchanging the whole paths. First and last nodes are not moved. Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8 (where (1, 5) and (6, 8) are first and last nodes of the paths and can therefore not be moved):
1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5
6 -&gt; [2] -&gt; 8
1 -&gt; [7] -&gt; 4 -&gt; 5
6 -&gt; [2 -&gt; 3] -&gt; 8
1 -&gt; [7] -&gt; 5
6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8</p></div>
</dd>
<dt id="pywrapcp.Solver.DECREMENT"><code class="name">var <span class="ident">DECREMENT</span></code></dt>
<dd>
<div class="desc"><p>Operator which defines a neighborhood to decrement values. The behavior is the same as INCREMENT, except values are decremented instead of incremented.</p></div>
</dd>
<dt id="pywrapcp.Solver.DELAYED_PRIORITY"><code class="name">var <span class="ident">DELAYED_PRIORITY</span></code></dt>
<dd>
<div class="desc"><p>DELAYED_PRIORITY is the lowest priority: Demons will be processed after VAR_PRIORITY and NORMAL_PRIORITY demons.</p></div>
</dd>
<dt id="pywrapcp.Solver.EQ"><code class="name">var <span class="ident">EQ</span></code></dt>
<dd>
<div class="desc"><p>Move is accepted when the current objective value is in the interval objective.Min .. objective.Max.</p></div>
</dd>
<dt id="pywrapcp.Solver.EXCHANGE"><code class="name">var <span class="ident">EXCHANGE</span></code></dt>
<dd>
<div class="desc"><p>Operator which exchanges the positions of two nodes. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (where (1, 5) are first and last nodes of the path and can therefore not be moved):
1 -&gt; [3] -&gt; [2] -&gt;
4
-&gt; 5
1 -&gt; [4] -&gt;
3
-&gt; [2] -&gt; 5
1 -&gt;
2
-&gt; [4] -&gt; [3] -&gt; 5</p></div>
</dd>
<dt id="pywrapcp.Solver.EXTENDEDSWAPACTIVE"><code class="name">var <span class="ident">EXTENDEDSWAPACTIVE</span></code></dt>
<dd>
<div class="desc"><p>Operator which makes an inactive node active and an active one inactive. It is similar to SwapActiveOperator except that it tries to insert the inactive node in all possible positions instead of just the position of the node made inactive. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive (where 1 and 4 are first and last nodes of the path) are:
1 -&gt; [5] -&gt;
3
-&gt; 4 with 2 inactive
1 -&gt;
3
-&gt; [5] -&gt; 4 with 2 inactive
1 -&gt; [5] -&gt;
2
-&gt; 4 with 3 inactive
1 -&gt;
2
-&gt; [5] -&gt; 4 with 3 inactive</p></div>
</dd>
<dt id="pywrapcp.Solver.FULLPATHLNS"><code class="name">var <span class="ident">FULLPATHLNS</span></code></dt>
<dd>
<div class="desc"><p>Operator which relaxes one entire path and all inactive nodes, thus defining num_paths neighbors.</p></div>
</dd>
<dt id="pywrapcp.Solver.GE"><code class="name">var <span class="ident">GE</span></code></dt>
<dd>
<div class="desc"><p>Move is accepted when the current objective value &gt;= objective.Min.</p></div>
</dd>
<dt id="pywrapcp.Solver.INCREMENT"><code class="name">var <span class="ident">INCREMENT</span></code></dt>
<dd>
<div class="desc"><p>Operator which defines one neighbor per variable. Each neighbor tries to increment by one the value of the corresponding variable. When a new solution is found the neighborhood is rebuilt from scratch, i.e., tries to increment values in the variable order. Consider for instance variables x and y. x is incremented one by one to its max, and when it is not possible to increment x anymore, y is incremented once. If this is a solution, then next neighbor tries to increment x.</p></div>
</dd>
<dt id="pywrapcp.Solver.INTERVAL_DEFAULT"><code class="name">var <span class="ident">INTERVAL_DEFAULT</span></code></dt>
<dd>
<div class="desc"><p>The default is INTERVAL_SET_TIMES_FORWARD.</p></div>
</dd>
<dt id="pywrapcp.Solver.INTERVAL_SET_TIMES_BACKWARD"><code class="name">var <span class="ident">INTERVAL_SET_TIMES_BACKWARD</span></code></dt>
<dd>
<div class="desc"><p>Selects the variable with the highest ending time of all variables, and fixes the ending time to this highest values.</p></div>
</dd>
<dt id="pywrapcp.Solver.INTERVAL_SET_TIMES_FORWARD"><code class="name">var <span class="ident">INTERVAL_SET_TIMES_FORWARD</span></code></dt>
<dd>
<div class="desc"><p>Selects the variable with the lowest starting time of all variables, and fixes its starting time to this lowest value.</p></div>
</dd>
<dt id="pywrapcp.Solver.INTERVAL_SIMPLE"><code class="name">var <span class="ident">INTERVAL_SIMPLE</span></code></dt>
<dd>
<div class="desc"><p>The simple is INTERVAL_SET_TIMES_FORWARD.</p></div>
</dd>
<dt id="pywrapcp.Solver.INT_VALUE_DEFAULT"><code class="name">var <span class="ident">INT_VALUE_DEFAULT</span></code></dt>
<dd>
<div class="desc"><p>The default behavior is ASSIGN_MIN_VALUE.</p></div>
</dd>
<dt id="pywrapcp.Solver.INT_VALUE_SIMPLE"><code class="name">var <span class="ident">INT_VALUE_SIMPLE</span></code></dt>
<dd>
<div class="desc"><p>The simple selection is ASSIGN_MIN_VALUE.</p></div>
</dd>
<dt id="pywrapcp.Solver.INT_VAR_DEFAULT"><code class="name">var <span class="ident">INT_VAR_DEFAULT</span></code></dt>
<dd>
<div class="desc"><p>The default behavior is CHOOSE_FIRST_UNBOUND.</p></div>
</dd>
<dt id="pywrapcp.Solver.INT_VAR_SIMPLE"><code class="name">var <span class="ident">INT_VAR_SIMPLE</span></code></dt>
<dd>
<div class="desc"><p>The simple selection is CHOOSE_FIRST_UNBOUND.</p></div>
</dd>
<dt id="pywrapcp.Solver.LE"><code class="name">var <span class="ident">LE</span></code></dt>
<dd>
<div class="desc"><p>Move is accepted when the current objective value &lt;= objective.Max.</p></div>
</dd>
<dt id="pywrapcp.Solver.MAKEACTIVE"><code class="name">var <span class="ident">MAKEACTIVE</span></code></dt>
<dd>
<div class="desc"><p>Operator which inserts an inactive node into a path. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive (where 1 and 4 are first and last nodes of the path) are:
1 -&gt; [5] -&gt;
2
-&gt;
3
-&gt; 4
1 -&gt;
2
-&gt; [5] -&gt;
3
-&gt; 4
1 -&gt;
2
-&gt;
3
-&gt; [5] -&gt; 4</p></div>
</dd>
<dt id="pywrapcp.Solver.MAKECHAININACTIVE"><code class="name">var <span class="ident">MAKECHAININACTIVE</span></code></dt>
<dd>
<div class="desc"><p>Operator which makes a "chain" of path nodes inactive. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first and last nodes of the path) are:
1 -&gt; 3 -&gt; 4 with 2 inactive
1 -&gt; 2 -&gt; 4 with 3 inactive
1 -&gt; 4 with 2 and 3 inactive</p></div>
</dd>
<dt id="pywrapcp.Solver.MAKEINACTIVE"><code class="name">var <span class="ident">MAKEINACTIVE</span></code></dt>
<dd>
<div class="desc"><p>Operator which makes path nodes inactive. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are first and last nodes of the path) are:
1 -&gt; 3 -&gt; 4 with 2 inactive
1 -&gt; 2 -&gt; 4 with 3 inactive</p></div>
</dd>
<dt id="pywrapcp.Solver.NORMAL_PRIORITY"><code class="name">var <span class="ident">NORMAL_PRIORITY</span></code></dt>
<dd>
<div class="desc"><p>NORMAL_PRIORITY is the highest priority: Demons will be processed first.</p></div>
</dd>
<dt id="pywrapcp.Solver.OROPT"><code class="name">var <span class="ident">OROPT</span></code></dt>
<dd>
<div class="desc"><p>Relocate: OROPT and RELOCATE. Operator which moves a sub-chain of a path to another position; the specified chain length is the fixed length of the chains being moved. When this length is 1, the operator simply moves a node to another position. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a chain length of 2 (where (1, 5) are first and last nodes of the path and can therefore not be moved):
1 -&gt;
4 -&gt; [2 -&gt; 3] -&gt; 5
1 -&gt; [3 -&gt; 4] -&gt; 2
-&gt; 5 Using Relocate with chain lengths of 1, 2 and 3 together is equivalent to the OrOpt operator on a path. The OrOpt operator is a limited
version of 3Opt (breaks 3 arcs on a path).</p></div>
</dd>
<dt id="pywrapcp.Solver.PATHLNS"><code class="name">var <span class="ident">PATHLNS</span></code></dt>
<dd>
<div class="desc"><p>Operator which relaxes two sub-chains of three consecutive arcs each. Each sub-chain is defined by a start node and the next three arcs. Those six arcs are relaxed to build a new neighbor. PATHLNS explores all possible pairs of starting nodes and so defines n^2 neighbors, n being the number of nodes. Note that the two sub-chains can be part of the same path; they even may overlap.</p></div>
</dd>
<dt id="pywrapcp.Solver.RELOCATE"><code class="name">var <span class="ident">RELOCATE</span></code></dt>
<dd>
<div class="desc"><p>Relocate neighborhood with length of 1 (see OROPT comment).</p></div>
</dd>
<dt id="pywrapcp.Solver.SEQUENCE_DEFAULT"><code class="name">var <span class="ident">SEQUENCE_DEFAULT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.Solver.SEQUENCE_SIMPLE"><code class="name">var <span class="ident">SEQUENCE_SIMPLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pywrapcp.Solver.SIMPLELNS"><code class="name">var <span class="ident">SIMPLELNS</span></code></dt>
<dd>
<div class="desc"><p>Operator which defines one neighbor per variable. Each neighbor relaxes one variable. When a new solution is found the neighborhood is rebuilt from scratch. Consider for instance variables x and y. First x is relaxed and the solver is looking for the best possible solution (with only x relaxed). Then y is relaxed, and the solver is looking for a new solution. If a new solution is found, then the next variable to be relaxed is x.</p></div>
</dd>
<dt id="pywrapcp.Solver.SPLIT_LOWER_HALF"><code class="name">var <span class="ident">SPLIT_LOWER_HALF</span></code></dt>
<dd>
<div class="desc"><p>Split the domain in two around the center, and choose the lower part first.</p></div>
</dd>
<dt id="pywrapcp.Solver.SPLIT_UPPER_HALF"><code class="name">var <span class="ident">SPLIT_UPPER_HALF</span></code></dt>
<dd>
<div class="desc"><p>Split the domain in two around the center, and choose the lower part first.</p></div>
</dd>
<dt id="pywrapcp.Solver.SWAPACTIVE"><code class="name">var <span class="ident">SWAPACTIVE</span></code></dt>
<dd>
<div class="desc"><p>Operator which replaces an active node by an inactive one. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive (where 1 and 4 are first and last nodes of the path) are:
1 -&gt; [5] -&gt;
3
-&gt; 4 with 2 inactive
1 -&gt;
2
-&gt; [5] -&gt; 4 with 3 inactive</p></div>
</dd>
<dt id="pywrapcp.Solver.TWOOPT"><code class="name">var <span class="ident">TWOOPT</span></code></dt>
<dd>
<div class="desc"><p>Operator which reverses a sub-chain of a path. It is called TwoOpt because it breaks two arcs on the path; resulting paths are called two-optimal. Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (where (1, 5) are first and last nodes of the path and can therefore not be moved):
1 -&gt; [3 -&gt; 2] -&gt; 4
-&gt; 5
1 -&gt; [4 -&gt; 3
-&gt; 2] -&gt; 5
1 -&gt;
2 -&gt; [4 -&gt; 3] -&gt; 5</p></div>
</dd>
<dt id="pywrapcp.Solver.UNACTIVELNS"><code class="name">var <span class="ident">UNACTIVELNS</span></code></dt>
<dd>
<div class="desc"><p>Operator which relaxes all inactive nodes and one sub-chain of six consecutive arcs. That way the path can be improved by inserting inactive nodes or swapping arcs.</p></div>
</dd>
<dt id="pywrapcp.Solver.VAR_PRIORITY"><code class="name">var <span class="ident">VAR_PRIORITY</span></code></dt>
<dd>
<div class="desc"><p>VAR_PRIORITY is between DELAYED_PRIORITY and NORMAL_PRIORITY.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pywrapcp.Solver.DefaultSolverParameters"><code class="name flex">
<span>def <span class="ident">DefaultSolverParameters</span></span>(<span>) -> 'operations_research::ConstraintSolverParameters'</span>
</code></dt>
<dd>
<div class="desc"><p>Create a ConstraintSolverParameters proto with all the default values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def DefaultSolverParameters() -&gt; &#34;operations_research::ConstraintSolverParameters&#34;:
    r&#34;&#34;&#34; Create a ConstraintSolverParameters proto with all the default values.&#34;&#34;&#34;
    return _pywrapcp.Solver_DefaultSolverParameters()</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.MemoryUsage"><code class="name flex">
<span>def <span class="ident">MemoryUsage</span></span>(<span>) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Current memory usage in bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def MemoryUsage() -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Current memory usage in bytes&#34;&#34;&#34;
    return _pywrapcp.Solver_MemoryUsage()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapcp.Solver.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<div class="desc"><p>The membership flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.Solver.AbsEquality"><code class="name flex">
<span>def <span class="ident">AbsEquality</span></span>(<span>self, var: IntVar, abs_var: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the constraint abs(var) == abs_var.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AbsEquality(self, var: &#34;IntVar&#34;, abs_var: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; Creates the constraint abs(var) == abs_var.&#34;&#34;&#34;
    return _pywrapcp.Solver_AbsEquality(self, var, abs_var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Accept"><code class="name flex">
<span>def <span class="ident">Accept</span></span>(<span>self, visitor: operations_research::ModelVisitor *const) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Accepts the given model visitor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Accept(self, visitor: &#34;operations_research::ModelVisitor *const&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Accepts the given model visitor.&#34;&#34;&#34;
    return _pywrapcp.Solver_Accept(self, visitor)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.AcceptedNeighbors"><code class="name flex">
<span>def <span class="ident">AcceptedNeighbors</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>The number of accepted neighbors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AcceptedNeighbors(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; The number of accepted neighbors.&#34;&#34;&#34;
    return _pywrapcp.Solver_AcceptedNeighbors(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Add"><code class="name flex">
<span>def <span class="ident">Add</span></span>(<span>self, ct)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Add(self, ct):
  if isinstance(ct, PyConstraint):
    self.__python_constraints.append(ct)
  self.AddConstraint(ct)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.AddConstraint"><code class="name flex">
<span>def <span class="ident">AddConstraint</span></span>(<span>self, c: Constraint) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the constraint 'c' to the model. After calling this method, and until there is a backtrack that undoes the addition, any assignment of variables to values must satisfy the given constraint in order to be considered feasible. There are two fairly different use cases: - the most common use case is modeling: the given constraint is really part of the problem that the user is trying to solve. In this use case, AddConstraint is called outside of search (i.e., with.. code-block:: c++</p>
<p>state() == OUTSIDE_SEARCH). Most users should only use AddConstraint in this way. In this case, the constraint will belong to the model forever: it cannot not be removed by backtracking. - a rarer use case is that 'c' is not a real constraint of the model. It may be a constraint generated by a branching decision (a constraint whose goal is to restrict the search space), a symmetry breaking constraint (a constraint that does restrict the search space, but in a way that cannot have an impact on the quality of the solutions in the subtree), or an inferred constraint that, while having no semantic value to the model (it does not restrict the set of solutions), is worth having because we believe it may strengthen the propagation. In these cases, it happens that the constraint is added during the search (i.e., with state() == IN_SEARCH or state() == IN_ROOT_NODE). When a constraint is added during a search, it applies only to the subtree of the search tree rooted at the current node, and will be automatically removed by backtracking. This method does not take ownership of the constraint. If the constraint has been created by any factory method (Solver::MakeXXX), it will automatically be deleted. However, power users who implement their own constraints should do: solver.AddConstraint(solver.RevAlloc(new MyConstraint(&hellip;));</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddConstraint(self, c: &#34;Constraint&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34;
    Adds the constraint &#39;c&#39; to the model. After calling this method, and until there is a backtrack that undoes the addition, any assignment of variables to values must satisfy the given constraint in order to be considered feasible. There are two fairly different use cases: - the most common use case is modeling: the given constraint is really part of the problem that the user is trying to solve. In this use case, AddConstraint is called outside of search (i.e., with.. code-block:: c++

       state() == OUTSIDE_SEARCH). Most users should only use AddConstraint in this way. In this case, the constraint will belong to the model forever: it cannot not be removed by backtracking. - a rarer use case is that &#39;c&#39; is not a real constraint of the model. It may be a constraint generated by a branching decision (a constraint whose goal is to restrict the search space), a symmetry breaking constraint (a constraint that does restrict the search space, but in a way that cannot have an impact on the quality of the solutions in the subtree), or an inferred constraint that, while having no semantic value to the model (it does not restrict the set of solutions), is worth having because we believe it may strengthen the propagation. In these cases, it happens that the constraint is added during the search (i.e., with state() == IN_SEARCH or state() == IN_ROOT_NODE). When a constraint is added during a search, it applies only to the subtree of the search tree rooted at the current node, and will be automatically removed by backtracking. This method does not take ownership of the constraint. If the constraint has been created by any factory method (Solver::MakeXXX), it will automatically be deleted. However, power users who implement their own constraints should do: solver.AddConstraint(solver.RevAlloc(new MyConstraint(...));
    &#34;&#34;&#34;
    return _pywrapcp.Solver_AddConstraint(self, c)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.AllDifferent"><code class="name flex">
<span>def <span class="ident">AllDifferent</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
All variables are pairwise different. This corresponds to the stronger version of the propagation algorithm.</p>
<p>|</p>
<p><em>Overload 2:</em>
All variables are pairwise different.
If 'stronger_propagation' is true, stronger, and potentially slower propagation will occur. This API will be deprecated in the future.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AllDifferent(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    All variables are pairwise different. This corresponds to the stronger version of the propagation algorithm.

    |

    *Overload 2:*
    All variables are pairwise different.  If &#39;stronger_propagation&#39; is true, stronger, and potentially slower propagation will occur. This API will be deprecated in the future.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_AllDifferent(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.AllDifferentExcept"><code class="name flex">
<span>def <span class="ident">AllDifferentExcept</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, escape_value: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>All variables are pairwise different, unless they are assigned to the escape value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AllDifferentExcept(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, escape_value: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; All variables are pairwise different, unless they are assigned to the escape value.&#34;&#34;&#34;
    return _pywrapcp.Solver_AllDifferentExcept(self, vars, escape_value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.AllSolutionCollector"><code class="name flex">
<span>def <span class="ident">AllSolutionCollector</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.SolutionCollector" href="#pywrapcp.SolutionCollector">SolutionCollector</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Collect all solutions of the search.</p>
<p>|</p>
<p><em>Overload 2:</em>
Collect all solutions of the search. The variables will need to be added later.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AllSolutionCollector(self, *args) -&gt; &#34;operations_research::SolutionCollector *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Collect all solutions of the search.

    |

    *Overload 2:*
    Collect all solutions of the search. The variables will need to be added later.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_AllSolutionCollector(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.AllowedAssignments"><code class="name flex">
<span>def <span class="ident">AllowedAssignments</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
This method creates a constraint where the graph of the relation between the variables is given in extension. There are 'arity' variables involved in the relation and the graph is given by a integer tuple set.</p>
<p>|</p>
<p><em>Overload 2:</em>
Compatibility layer for Python API.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AllowedAssignments(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    This method creates a constraint where the graph of the relation between the variables is given in extension. There are &#39;arity&#39; variables involved in the relation and the graph is given by a integer tuple set.

    |

    *Overload 2:*
    Compatibility layer for Python API.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_AllowedAssignments(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.AssignVariableValue"><code class="name flex">
<span>def <span class="ident">AssignVariableValue</span></span>(<span>self, var: IntVar, val: int64) -> 'operations_research::<a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Decisions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AssignVariableValue(self, var: &#34;IntVar&#34;, val: &#34;int64&#34;) -&gt; &#34;operations_research::Decision *&#34;:
    r&#34;&#34;&#34; Decisions.&#34;&#34;&#34;
    return _pywrapcp.Solver_AssignVariableValue(self, var, val)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.AssignVariableValueOrFail"><code class="name flex">
<span>def <span class="ident">AssignVariableValueOrFail</span></span>(<span>self, var: IntVar, value: int64) -> 'operations_research::<a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AssignVariableValueOrFail(self, var: &#34;IntVar&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::Decision *&#34;:
    return _pywrapcp.Solver_AssignVariableValueOrFail(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.AssignVariablesValues"><code class="name flex">
<span>def <span class="ident">AssignVariablesValues</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, values: std::vector< int64 > const &) -> 'operations_research::<a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AssignVariablesValues(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, values: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;operations_research::Decision *&#34;:
    return _pywrapcp.Solver_AssignVariablesValues(self, vars, values)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Assignment"><code class="name flex">
<span>def <span class="ident">Assignment</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
This method creates an empty assignment.</p>
<p>|</p>
<p><em>Overload 2:</em>
This method creates an assignment which is a copy of 'a'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Assignment(self, *args) -&gt; &#34;operations_research::Assignment *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    This method creates an empty assignment.

    |

    *Overload 2:*
    This method creates an assignment which is a copy of &#39;a&#39;.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_Assignment(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.BestValueSolutionCollector"><code class="name flex">
<span>def <span class="ident">BestValueSolutionCollector</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.SolutionCollector" href="#pywrapcp.SolutionCollector">SolutionCollector</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Collect the solution corresponding to the optimal value of the objective of 'assignment'; if 'assignment' does not have an objective no solution is collected. This collector only collects one solution corresponding to the best objective value (the first one found).</p>
<p>|</p>
<p><em>Overload 2:</em>
Collect the solution corresponding to the optimal value of the objective of 'assignment'; if 'assignment' does not have an objective no solution is collected. This collector only collects one solution corresponding to the best objective value (the first one found). The variables will need to be added later.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BestValueSolutionCollector(self, *args) -&gt; &#34;operations_research::SolutionCollector *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Collect the solution corresponding to the optimal value of the objective of &#39;assignment&#39;; if &#39;assignment&#39; does not have an objective no solution is collected. This collector only collects one solution corresponding to the best objective value (the first one found).

    |

    *Overload 2:*
    Collect the solution corresponding to the optimal value of the objective of &#39;assignment&#39;; if &#39;assignment&#39; does not have an objective no solution is collected. This collector only collects one solution corresponding to the best objective value (the first one found). The variables will need to be added later.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_BestValueSolutionCollector(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.BetweenCt"><code class="name flex">
<span>def <span class="ident">BetweenCt</span></span>(<span>self, expr: IntExpr, l: int64, u: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>(l &lt;= expr &lt;= u)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BetweenCt(self, expr: &#34;IntExpr&#34;, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; (l &lt;= expr &lt;= u)&#34;&#34;&#34;
    return _pywrapcp.Solver_BetweenCt(self, expr, l, u)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.BoolVar"><code class="name flex">
<span>def <span class="ident">BoolVar</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
MakeBoolVar will create a variable with a {0, 1} domain.</p>
<p>|</p>
<p><em>Overload 2:</em>
MakeBoolVar will create a variable with a {0, 1} domain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BoolVar(self, *args) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    MakeBoolVar will create a variable with a {0, 1} domain.

    |

    *Overload 2:*
    MakeBoolVar will create a variable with a {0, 1} domain.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_BoolVar(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Branches"><code class="name flex">
<span>def <span class="ident">Branches</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>The number of branches explored since the creation of the solver.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Branches(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; The number of branches explored since the creation of the solver.&#34;&#34;&#34;
    return _pywrapcp.Solver_Branches(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.BranchesLimit"><code class="name flex">
<span>def <span class="ident">BranchesLimit</span></span>(<span>self, branches: int64) -> 'operations_research::RegularLimit *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a search limit that constrains the number of branches explored in the search tree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BranchesLimit(self, branches: &#34;int64&#34;) -&gt; &#34;operations_research::RegularLimit *&#34;:
    r&#34;&#34;&#34; Creates a search limit that constrains the number of branches explored in the search tree.&#34;&#34;&#34;
    return _pywrapcp.Solver_BranchesLimit(self, branches)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.CheckAssignment"><code class="name flex">
<span>def <span class="ident">CheckAssignment</span></span>(<span>self, solution: Assignment) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the given assignment satisfies all relevant constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CheckAssignment(self, solution: &#34;Assignment&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Checks whether the given assignment satisfies all relevant constraints.&#34;&#34;&#34;
    return _pywrapcp.Solver_CheckAssignment(self, solution)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.CheckConstraint"><code class="name flex">
<span>def <span class="ident">CheckConstraint</span></span>(<span>self, ct: Constraint) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether adding this constraint will lead to an immediate failure. It will return false if the model is already inconsistent, or if adding the constraint makes it inconsistent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CheckConstraint(self, ct: &#34;Constraint&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34; Checks whether adding this constraint will lead to an immediate failure. It will return false if the model is already inconsistent, or if adding the constraint makes it inconsistent.&#34;&#34;&#34;
    return _pywrapcp.Solver_CheckConstraint(self, ct)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Circuit"><code class="name flex">
<span>def <span class="ident">Circuit</span></span>(<span>self, nexts: std::vector< operations_research::IntVar * > const &) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Force the "nexts" variable to create a complete Hamiltonian path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Circuit(self, nexts: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; Force the &#34;nexts&#34; variable to create a complete Hamiltonian path.&#34;&#34;&#34;
    return _pywrapcp.Solver_Circuit(self, nexts)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ClosureDemon"><code class="name flex">
<span>def <span class="ident">ClosureDemon</span></span>(<span>self, closure: operations_research::Solver::Closure) -> 'operations_research::<a title="pywrapcp.Demon" href="#pywrapcp.Demon">Demon</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a demon from a closure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ClosureDemon(self, closure: &#34;operations_research::Solver::Closure&#34;) -&gt; &#34;operations_research::Demon *&#34;:
    r&#34;&#34;&#34; Creates a demon from a closure.&#34;&#34;&#34;
    return _pywrapcp.Solver_ClosureDemon(self, closure)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Compose"><code class="name flex">
<span>def <span class="ident">Compose</span></span>(<span>self, dbs: std::vector< operations_research::DecisionBuilder * > const &) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Compose(self, dbs: &#34;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_Compose(self, dbs)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ConcatenateOperators"><code class="name flex">
<span>def <span class="ident">ConcatenateOperators</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConcatenateOperators(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
    return _pywrapcp.Solver_ConcatenateOperators(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ConditionalExpression"><code class="name flex">
<span>def <span class="ident">ConditionalExpression</span></span>(<span>self, condition: IntVar, expr: IntExpr, unperformed_value: int64) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Conditional Expr condition ? expr : unperformed_value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConditionalExpression(self, condition: &#34;IntVar&#34;, expr: &#34;IntExpr&#34;, unperformed_value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
    r&#34;&#34;&#34; Conditional Expr condition ? expr : unperformed_value&#34;&#34;&#34;
    return _pywrapcp.Solver_ConditionalExpression(self, condition, expr, unperformed_value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ConstantRestart"><code class="name flex">
<span>def <span class="ident">ConstantRestart</span></span>(<span>self, frequency: int) -> 'operations_research::<a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>This search monitor will restart the search periodically after 'frequency' failures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConstantRestart(self, frequency: &#34;int&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
    r&#34;&#34;&#34; This search monitor will restart the search periodically after &#39;frequency&#39; failures.&#34;&#34;&#34;
    return _pywrapcp.Solver_ConstantRestart(self, frequency)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ConstraintAdder"><code class="name flex">
<span>def <span class="ident">ConstraintAdder</span></span>(<span>self, ct: Constraint) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a decision builder that will add the given constraint to the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConstraintAdder(self, ct: &#34;Constraint&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    r&#34;&#34;&#34; Returns a decision builder that will add the given constraint to the model.&#34;&#34;&#34;
    return _pywrapcp.Solver_ConstraintAdder(self, ct)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ConstraintInitialPropagateCallback"><code class="name flex">
<span>def <span class="ident">ConstraintInitialPropagateCallback</span></span>(<span>self, ct: Constraint) -> 'operations_research::<a title="pywrapcp.Demon" href="#pywrapcp.Demon">Demon</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>This method is a specialized case of the MakeConstraintDemon method to call the InitiatePropagate of the constraint 'ct'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConstraintInitialPropagateCallback(self, ct: &#34;Constraint&#34;) -&gt; &#34;operations_research::Demon *&#34;:
    r&#34;&#34;&#34; This method is a specialized case of the MakeConstraintDemon method to call the InitiatePropagate of the constraint &#39;ct&#39;.&#34;&#34;&#34;
    return _pywrapcp.Solver_ConstraintInitialPropagateCallback(self, ct)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Constraints"><code class="name flex">
<span>def <span class="ident">Constraints</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Counts the number of constraints that have been added to the solver before the search.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Constraints(self) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Counts the number of constraints that have been added to the solver before the search.&#34;&#34;&#34;
    return _pywrapcp.Solver_Constraints(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ConvexPiecewiseExpr"><code class="name flex">
<span>def <span class="ident">ConvexPiecewiseExpr</span></span>(<span>self, expr: IntExpr, early_cost: int64, early_date: int64, late_date: int64, late_cost: int64) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Convex piecewise function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConvexPiecewiseExpr(self, expr: &#34;IntExpr&#34;, early_cost: &#34;int64&#34;, early_date: &#34;int64&#34;, late_date: &#34;int64&#34;, late_cost: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
    r&#34;&#34;&#34; Convex piecewise function.&#34;&#34;&#34;
    return _pywrapcp.Solver_ConvexPiecewiseExpr(self, expr, early_cost, early_date, late_date, late_cost)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Count"><code class="name flex">
<span>def <span class="ident">Count</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
|{i | vars[i] == value}| == max_count</p>
<p>|</p>
<p><em>Overload 2:</em>
|{i | vars[i] == value}| == max_count</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Count(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    |{i | vars[i] == value}| == max_count

    |

    *Overload 2:*
    |{i | vars[i] == value}| == max_count
    &#34;&#34;&#34;
    return _pywrapcp.Solver_Count(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Cover"><code class="name flex">
<span>def <span class="ident">Cover</span></span>(<span>self, vars: std::vector< operations_research::IntervalVar * > const &, target_var: IntervalVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>This constraint states that the target_var is the convex hull of the intervals. If none of the interval variables is performed, then the target var is unperformed too. Also, if the target variable is unperformed, then all the intervals variables are unperformed too.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Cover(self, vars: &#34;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&#34;, target_var: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; This constraint states that the target_var is the convex hull of the intervals. If none of the interval variables is performed, then the target var is unperformed too. Also, if the target variable is unperformed, then all the intervals variables are unperformed too.&#34;&#34;&#34;
    return _pywrapcp.Solver_Cover(self, vars, target_var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Cumulative"><code class="name flex">
<span>def <span class="ident">Cumulative</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
This constraint forces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.</p>
<p>|</p>
<p><em>Overload 2:</em>
This constraint forces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.</p>
<p>|</p>
<p><em>Overload 3:</em>
This constraint forces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.</p>
<p>|</p>
<p><em>Overload 4:</em>
This constraint enforces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.</p>
<p>|</p>
<p><em>Overload 5:</em>
This constraint enforces that, for any integer t, the sum of demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should be positive.</p>
<p>|</p>
<p><em>Overload 6:</em>
This constraint enforces that, for any integer t, the sum of demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should be positive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Cumulative(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    This constraint forces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.

    |

    *Overload 2:*
    This constraint forces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.

    |

    *Overload 3:*
    This constraint forces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.

    |

    *Overload 4:*
    This constraint enforces that, for any integer t, the sum of the demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should only contain non-negative values. Zero values are supported, and the corresponding intervals are filtered out, as they neither impact nor are impacted by this constraint.

    |

    *Overload 5:*
    This constraint enforces that, for any integer t, the sum of demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should be positive.

    |

    *Overload 6:*
    This constraint enforces that, for any integer t, the sum of demands corresponding to an interval containing t does not exceed the given capacity. Intervals and demands should be vectors of equal size. Demands should be positive.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_Cumulative(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.CustomLimit"><code class="name flex">
<span>def <span class="ident">CustomLimit</span></span>(<span>self, limiter: std::function< bool () >) -> 'operations_research::<a title="pywrapcp.SearchLimit" href="#pywrapcp.SearchLimit">SearchLimit</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Callback-based search limit. Search stops when limiter returns true; if this happens at a leaf the corresponding solution will be rejected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CustomLimit(self, limiter: &#34;std::function&lt; bool () &gt;&#34;) -&gt; &#34;operations_research::SearchLimit *&#34;:
    r&#34;&#34;&#34; Callback-based search limit. Search stops when limiter returns true; if this happens at a leaf the corresponding solution will be rejected.&#34;&#34;&#34;
    return _pywrapcp.Solver_CustomLimit(self, limiter)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Decision"><code class="name flex">
<span>def <span class="ident">Decision</span></span>(<span>self, apply: operations_research::Solver::Action, refute: operations_research::Solver::Action) -> 'operations_research::<a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Decision(self, apply: &#34;operations_research::Solver::Action&#34;, refute: &#34;operations_research::Solver::Action&#34;) -&gt; &#34;operations_research::Decision *&#34;:
    return _pywrapcp.Solver_Decision(self, apply, refute)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.DecisionBuilderFromAssignment"><code class="name flex">
<span>def <span class="ident">DecisionBuilderFromAssignment</span></span>(<span>self, assignment: Assignment, db: DecisionBuilder, vars: std::vector< operations_research::IntVar * > const &) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a decision builder for which the left-most leaf corresponds to assignment, the rest of the tree being explored using 'db'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DecisionBuilderFromAssignment(self, assignment: &#34;Assignment&#34;, db: &#34;DecisionBuilder&#34;, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    r&#34;&#34;&#34; Returns a decision builder for which the left-most leaf corresponds to assignment, the rest of the tree being explored using &#39;db&#39;.&#34;&#34;&#34;
    return _pywrapcp.Solver_DecisionBuilderFromAssignment(self, assignment, db, vars)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.DefaultPhase"><code class="name flex">
<span>def <span class="ident">DefaultPhase</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DefaultPhase(self, *args) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_DefaultPhase(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.DelayedConstraintInitialPropagateCallback"><code class="name flex">
<span>def <span class="ident">DelayedConstraintInitialPropagateCallback</span></span>(<span>self, ct: Constraint) -> 'operations_research::<a title="pywrapcp.Demon" href="#pywrapcp.Demon">Demon</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>This method is a specialized case of the MakeConstraintDemon method to call the InitiatePropagate of the constraint 'ct' with low priority.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DelayedConstraintInitialPropagateCallback(self, ct: &#34;Constraint&#34;) -&gt; &#34;operations_research::Demon *&#34;:
    r&#34;&#34;&#34; This method is a specialized case of the MakeConstraintDemon method to call the InitiatePropagate of the constraint &#39;ct&#39; with low priority.&#34;&#34;&#34;
    return _pywrapcp.Solver_DelayedConstraintInitialPropagateCallback(self, ct)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.DelayedPathCumul"><code class="name flex">
<span>def <span class="ident">DelayedPathCumul</span></span>(<span>self, nexts: std::vector< operations_research::IntVar * > const &, active: std::vector< operations_research::IntVar * > const &, cumuls: std::vector< operations_research::IntVar * > const &, transits: std::vector< operations_research::IntVar * > const &) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Delayed version of the same constraint: propagation on the nexts variables is delayed until all constraints have propagated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DelayedPathCumul(self, nexts: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, active: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, cumuls: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, transits: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; Delayed version of the same constraint: propagation on the nexts variables is delayed until all constraints have propagated.&#34;&#34;&#34;
    return _pywrapcp.Solver_DelayedPathCumul(self, nexts, active, cumuls, transits)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Deviation"><code class="name flex">
<span>def <span class="ident">Deviation</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, deviation_var: IntVar, total_sum: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Deviation constraint: sum_i |n * vars[i] - total_sum| &lt;= deviation_var and sum_i vars[i] == total_sum n = #vars</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Deviation(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, deviation_var: &#34;IntVar&#34;, total_sum: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; Deviation constraint: sum_i |n * vars[i] - total_sum| &lt;= deviation_var and sum_i vars[i] == total_sum n = #vars&#34;&#34;&#34;
    return _pywrapcp.Solver_Deviation(self, vars, deviation_var, total_sum)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.DisjunctiveConstraint"><code class="name flex">
<span>def <span class="ident">DisjunctiveConstraint</span></span>(<span>self, intervals: std::vector< operations_research::IntervalVar * > const &, name: std::string const &) -> 'operations_research::<a title="pywrapcp.DisjunctiveConstraint" href="#pywrapcp.DisjunctiveConstraint">DisjunctiveConstraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>This constraint forces all interval vars into an non-overlapping sequence. Intervals with zero duration can be scheduled anywhere.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DisjunctiveConstraint(self, intervals: &#34;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::DisjunctiveConstraint *&#34;:
    r&#34;&#34;&#34; This constraint forces all interval vars into an non-overlapping sequence. Intervals with zero duration can be scheduled anywhere.&#34;&#34;&#34;
    return _pywrapcp.Solver_DisjunctiveConstraint(self, intervals, name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Distribute"><code class="name flex">
<span>def <span class="ident">Distribute</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Aggregated version of count:
|{i | v[i] == values[j]}| == cards[j]</p>
<p>|</p>
<p><em>Overload 2:</em>
Aggregated version of count:
|{i | v[i] == values[j]}| == cards[j]</p>
<p>|</p>
<p><em>Overload 3:</em>
Aggregated version of count:
|{i | v[i] == j}| == cards[j]</p>
<p>|</p>
<p><em>Overload 4:</em>
Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1: card_min &lt;= |{i | v[i] == j}| &lt;= card_max</p>
<p>|</p>
<p><em>Overload 5:</em>
Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:
card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]</p>
<p>|</p>
<p><em>Overload 6:</em>
Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:
card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]</p>
<p>|</p>
<p><em>Overload 7:</em>
Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:
card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]</p>
<p>|</p>
<p><em>Overload 8:</em>
Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:
card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Distribute(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]

    |

    *Overload 2:*
    Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]

    |

    *Overload 3:*
    Aggregated version of count:  |{i | v[i] == j}| == cards[j]

    |

    *Overload 4:*
    Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1: card_min &lt;= |{i | v[i] == j}| &lt;= card_max

    |

    *Overload 5:*
    Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:    card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]

    |

    *Overload 6:*
    Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:    card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]

    |

    *Overload 7:*
    Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:    card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]

    |

    *Overload 8:*
    Aggregated version of count with bounded cardinalities: forall j in 0 .. card_size - 1:    card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]
    &#34;&#34;&#34;
    return _pywrapcp.Solver_Distribute(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Element"><code class="name flex">
<span>def <span class="ident">Element</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
values[index]</p>
<p>|</p>
<p><em>Overload 2:</em>
values[index]</p>
<p>|</p>
<p><em>Overload 3:</em>
Function-based element. The constraint takes ownership of the callback. The callback must be able to cope with any possible value in the domain of 'index' (potentially negative ones too).</p>
<p>|</p>
<p><em>Overload 4:</em>
2D version of function-based element expression, values(expr1, expr2).</p>
<p>|</p>
<p><em>Overload 5:</em>
vars[expr]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Element(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    values[index]

    |

    *Overload 2:*
    values[index]

    |

    *Overload 3:*
    Function-based element. The constraint takes ownership of the callback. The callback must be able to cope with any possible value in the domain of &#39;index&#39; (potentially negative ones too).

    |

    *Overload 4:*
    2D version of function-based element expression, values(expr1, expr2).

    |

    *Overload 5:*
    vars[expr]
    &#34;&#34;&#34;
    return _pywrapcp.Solver_Element(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ElementEquality"><code class="name flex">
<span>def <span class="ident">ElementEquality</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ElementEquality(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_ElementEquality(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ElementFunction"><code class="name flex">
<span>def <span class="ident">ElementFunction</span></span>(<span>self, values: std::function< int64 (int64) >, index: IntVar) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ElementFunction(self, values: &#34;std::function&lt; int64 (int64) &gt;&#34;, index: &#34;IntVar&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
    return _pywrapcp.Solver_ElementFunction(self, values, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.EndSearch"><code class="name flex">
<span>def <span class="ident">EndSearch</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EndSearch(self) -&gt; &#34;void&#34;:
    return _pywrapcp.Solver_EndSearch(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.EvalEvalStrPhase"><code class="name flex">
<span>def <span class="ident">EvalEvalStrPhase</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, evaluator: operations_research::Solver::IndexEvaluator2, str: operations_research::Solver::EvaluatorStrategy) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EvalEvalStrPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, evaluator: &#34;operations_research::Solver::IndexEvaluator2&#34;, str: &#34;operations_research::Solver::EvaluatorStrategy&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_EvalEvalStrPhase(self, vars, evaluator, str)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.EvalEvalStrTieBreakPhase"><code class="name flex">
<span>def <span class="ident">EvalEvalStrTieBreakPhase</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, evaluator: operations_research::Solver::IndexEvaluator2, tie_breaker: operations_research::Solver::IndexEvaluator1, str: operations_research::Solver::EvaluatorStrategy) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EvalEvalStrTieBreakPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, evaluator: &#34;operations_research::Solver::IndexEvaluator2&#34;, tie_breaker: &#34;operations_research::Solver::IndexEvaluator1&#34;, str: &#34;operations_research::Solver::EvaluatorStrategy&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_EvalEvalStrTieBreakPhase(self, vars, evaluator, tie_breaker, str)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Fail"><code class="name flex">
<span>def <span class="ident">Fail</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Abandon the current branch in the search tree. A backtrack will follow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Fail(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Abandon the current branch in the search tree. A backtrack will follow.&#34;&#34;&#34;
    return _pywrapcp.Solver_Fail(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.FailDecision"><code class="name flex">
<span>def <span class="ident">FailDecision</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FailDecision(self) -&gt; &#34;operations_research::Decision *&#34;:
    return _pywrapcp.Solver_FailDecision(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.FailStamp"><code class="name flex">
<span>def <span class="ident">FailStamp</span></span>(<span>self) -> 'uint64'</span>
</code></dt>
<dd>
<div class="desc"><p>The fail_stamp() is incremented after each backtrack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FailStamp(self) -&gt; &#34;uint64&#34;:
    r&#34;&#34;&#34; The fail_stamp() is incremented after each backtrack.&#34;&#34;&#34;
    return _pywrapcp.Solver_FailStamp(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Failures"><code class="name flex">
<span>def <span class="ident">Failures</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>The number of failures encountered since the creation of the solver.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Failures(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; The number of failures encountered since the creation of the solver.&#34;&#34;&#34;
    return _pywrapcp.Solver_Failures(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.FailuresLimit"><code class="name flex">
<span>def <span class="ident">FailuresLimit</span></span>(<span>self, failures: int64) -> 'operations_research::RegularLimit *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a search limit that constrains the number of failures that can happen when exploring the search tree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FailuresLimit(self, failures: &#34;int64&#34;) -&gt; &#34;operations_research::RegularLimit *&#34;:
    r&#34;&#34;&#34; Creates a search limit that constrains the number of failures that can happen when exploring the search tree.&#34;&#34;&#34;
    return _pywrapcp.Solver_FailuresLimit(self, failures)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.FalseConstraint"><code class="name flex">
<span>def <span class="ident">FalseConstraint</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FalseConstraint(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_FalseConstraint(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.FinishCurrentSearch"><code class="name flex">
<span>def <span class="ident">FinishCurrentSearch</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Tells the solver to kill or restart the current search.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FinishCurrentSearch(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Tells the solver to kill or restart the current search.&#34;&#34;&#34;
    return _pywrapcp.Solver_FinishCurrentSearch(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.FirstSolutionCollector"><code class="name flex">
<span>def <span class="ident">FirstSolutionCollector</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.SolutionCollector" href="#pywrapcp.SolutionCollector">SolutionCollector</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Collect the first solution of the search.</p>
<p>|</p>
<p><em>Overload 2:</em>
Collect the first solution of the search. The variables will need to be added later.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FirstSolutionCollector(self, *args) -&gt; &#34;operations_research::SolutionCollector *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Collect the first solution of the search.

    |

    *Overload 2:*
    Collect the first solution of the search. The variables will need to be added later.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_FirstSolutionCollector(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.FixedDurationEndSyncedOnEndIntervalVar"><code class="name flex">
<span>def <span class="ident">FixedDurationEndSyncedOnEndIntervalVar</span></span>(<span>self, interval_var: IntervalVar, duration: int64, offset: int64) -> 'operations_research::<a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an interval var with a fixed duration whose end is synchronized with the end of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FixedDurationEndSyncedOnEndIntervalVar(self, interval_var: &#34;IntervalVar&#34;, duration: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
    r&#34;&#34;&#34; Creates an interval var with a fixed duration whose end is synchronized with the end of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.&#34;&#34;&#34;
    return _pywrapcp.Solver_FixedDurationEndSyncedOnEndIntervalVar(self, interval_var, duration, offset)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.FixedDurationEndSyncedOnStartIntervalVar"><code class="name flex">
<span>def <span class="ident">FixedDurationEndSyncedOnStartIntervalVar</span></span>(<span>self, interval_var: IntervalVar, duration: int64, offset: int64) -> 'operations_research::<a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an interval var with a fixed duration whose end is synchronized with the start of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FixedDurationEndSyncedOnStartIntervalVar(self, interval_var: &#34;IntervalVar&#34;, duration: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
    r&#34;&#34;&#34; Creates an interval var with a fixed duration whose end is synchronized with the start of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.&#34;&#34;&#34;
    return _pywrapcp.Solver_FixedDurationEndSyncedOnStartIntervalVar(self, interval_var, duration, offset)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.FixedDurationIntervalVar"><code class="name flex">
<span>def <span class="ident">FixedDurationIntervalVar</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Creates an interval var with a fixed duration. The duration must be greater than 0. If optional is true, then the interval can be performed or unperformed. If optional is false, then the interval is always performed.</p>
<p>|</p>
<p><em>Overload 2:</em>
Creates a performed interval var with a fixed duration. The duration must be greater than 0.</p>
<p>|</p>
<p><em>Overload 3:</em>
Creates an interval var with a fixed duration, and performed_variable. The duration must be greater than 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FixedDurationIntervalVar(self, *args) -&gt; &#34;operations_research::IntervalVar *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Creates an interval var with a fixed duration. The duration must be greater than 0. If optional is true, then the interval can be performed or unperformed. If optional is false, then the interval is always performed.

    |

    *Overload 2:*
    Creates a performed interval var with a fixed duration. The duration must be greater than 0.

    |

    *Overload 3:*
    Creates an interval var with a fixed duration, and performed_variable. The duration must be greater than 0.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_FixedDurationIntervalVar(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.FixedDurationStartSyncedOnEndIntervalVar"><code class="name flex">
<span>def <span class="ident">FixedDurationStartSyncedOnEndIntervalVar</span></span>(<span>self, interval_var: IntervalVar, duration: int64, offset: int64) -> 'operations_research::<a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an interval var with a fixed duration whose start is synchronized with the end of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FixedDurationStartSyncedOnEndIntervalVar(self, interval_var: &#34;IntervalVar&#34;, duration: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
    r&#34;&#34;&#34; Creates an interval var with a fixed duration whose start is synchronized with the end of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.&#34;&#34;&#34;
    return _pywrapcp.Solver_FixedDurationStartSyncedOnEndIntervalVar(self, interval_var, duration, offset)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.FixedDurationStartSyncedOnStartIntervalVar"><code class="name flex">
<span>def <span class="ident">FixedDurationStartSyncedOnStartIntervalVar</span></span>(<span>self, interval_var: IntervalVar, duration: int64, offset: int64) -> 'operations_research::<a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an interval var with a fixed duration whose start is synchronized with the start of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FixedDurationStartSyncedOnStartIntervalVar(self, interval_var: &#34;IntervalVar&#34;, duration: &#34;int64&#34;, offset: &#34;int64&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
    r&#34;&#34;&#34; Creates an interval var with a fixed duration whose start is synchronized with the start of another interval, with a given offset. The performed status is also in sync with the performed status of the given interval variable.&#34;&#34;&#34;
    return _pywrapcp.Solver_FixedDurationStartSyncedOnStartIntervalVar(self, interval_var, duration, offset)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.FixedInterval"><code class="name flex">
<span>def <span class="ident">FixedInterval</span></span>(<span>self, start: int64, duration: int64, name: std::string const &) -> 'operations_research::<a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a fixed and performed interval.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FixedInterval(self, start: &#34;int64&#34;, duration: &#34;int64&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
    r&#34;&#34;&#34; Creates a fixed and performed interval.&#34;&#34;&#34;
    return _pywrapcp.Solver_FixedInterval(self, start, duration, name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.GuidedLocalSearch"><code class="name flex">
<span>def <span class="ident">GuidedLocalSearch</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GuidedLocalSearch(self, *args) -&gt; &#34;operations_research::SearchMonitor *&#34;:
    return _pywrapcp.Solver_GuidedLocalSearch(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IndexExpression"><code class="name flex">
<span>def <span class="ident">IndexExpression</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, value: int64) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the expression expr such that vars[expr] == value. It assumes that vars are all different.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IndexExpression(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
    r&#34;&#34;&#34; Returns the expression expr such that vars[expr] == value. It assumes that vars are all different.&#34;&#34;&#34;
    return _pywrapcp.Solver_IndexExpression(self, vars, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IndexOfConstraint"><code class="name flex">
<span>def <span class="ident">IndexOfConstraint</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, index: IntVar, target: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>This constraint is a special case of the element constraint with an array of integer variables, where the variables are all different and the index variable is constrained such that vars[index] == target.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IndexOfConstraint(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, index: &#34;IntVar&#34;, target: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; This constraint is a special case of the element constraint with an array of integer variables, where the variables are all different and the index variable is constrained such that vars[index] == target.&#34;&#34;&#34;
    return _pywrapcp.Solver_IndexOfConstraint(self, vars, index, target)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IntConst"><code class="name flex">
<span>def <span class="ident">IntConst</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
IntConst will create a constant expression.</p>
<p>|</p>
<p><em>Overload 2:</em>
IntConst will create a constant expression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IntConst(self, *args) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    IntConst will create a constant expression.

    |

    *Overload 2:*
    IntConst will create a constant expression.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_IntConst(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IntVar"><code class="name flex">
<span>def <span class="ident">IntVar</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
MakeIntVar will create the best range based int var for the bounds given.</p>
<p>|</p>
<p><em>Overload 2:</em>
MakeIntVar will create a variable with the given sparse domain.</p>
<p>|</p>
<p><em>Overload 3:</em>
MakeIntVar will create a variable with the given sparse domain.</p>
<p>|</p>
<p><em>Overload 4:</em>
MakeIntVar will create the best range based int var for the bounds given.</p>
<p>|</p>
<p><em>Overload 5:</em>
MakeIntVar will create a variable with the given sparse domain.</p>
<p>|</p>
<p><em>Overload 6:</em>
MakeIntVar will create a variable with the given sparse domain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IntVar(self, *args) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    MakeIntVar will create the best range based int var for the bounds given.

    |

    *Overload 2:*
    MakeIntVar will create a variable with the given sparse domain.

    |

    *Overload 3:*
    MakeIntVar will create a variable with the given sparse domain.

    |

    *Overload 4:*
    MakeIntVar will create the best range based int var for the bounds given.

    |

    *Overload 5:*
    MakeIntVar will create a variable with the given sparse domain.

    |

    *Overload 6:*
    MakeIntVar will create a variable with the given sparse domain.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_IntVar(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IntervalRelaxedMax"><code class="name flex">
<span>def <span class="ident">IntervalRelaxedMax</span></span>(<span>self, interval_var: IntervalVar) -> 'operations_research::<a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns an interval variable that wraps around the given one, relaxing the max start and end. Relaxing means making unbounded when optional. If the variable is non optional, this method returns interval_var. More precisely, such an interval variable behaves as follows: * When the underlying must be performed, the returned interval variable
behaves exactly as the underlying; * When the underlying may or may not be performed, the returned interval
variable behaves like the underlying, except that it is unbounded on
the max side; * When the underlying cannot be performed, the returned interval variable
is of duration 0 and must be performed in an interval unbounded on
both sides. This is very useful for implementing propagators that may only modify the start min or end min.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IntervalRelaxedMax(self, interval_var: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
    r&#34;&#34;&#34; Creates and returns an interval variable that wraps around the given one, relaxing the max start and end. Relaxing means making unbounded when optional. If the variable is non optional, this method returns interval_var. More precisely, such an interval variable behaves as follows: * When the underlying must be performed, the returned interval variable     behaves exactly as the underlying; * When the underlying may or may not be performed, the returned interval     variable behaves like the underlying, except that it is unbounded on     the max side; * When the underlying cannot be performed, the returned interval variable     is of duration 0 and must be performed in an interval unbounded on     both sides. This is very useful for implementing propagators that may only modify the start min or end min.&#34;&#34;&#34;
    return _pywrapcp.Solver_IntervalRelaxedMax(self, interval_var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IntervalRelaxedMin"><code class="name flex">
<span>def <span class="ident">IntervalRelaxedMin</span></span>(<span>self, interval_var: IntervalVar) -> 'operations_research::<a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and returns an interval variable that wraps around the given one, relaxing the min start and end. Relaxing means making unbounded when optional. If the variable is non-optional, this method returns interval_var. More precisely, such an interval variable behaves as follows: * When the underlying must be performed, the returned interval variable
behaves exactly as the underlying; * When the underlying may or may not be performed, the returned interval
variable behaves like the underlying, except that it is unbounded on
the min side; * When the underlying cannot be performed, the returned interval variable
is of duration 0 and must be performed in an interval unbounded on
both sides. This is very useful to implement propagators that may only modify the start max or end max.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IntervalRelaxedMin(self, interval_var: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
    r&#34;&#34;&#34; Creates and returns an interval variable that wraps around the given one, relaxing the min start and end. Relaxing means making unbounded when optional. If the variable is non-optional, this method returns interval_var. More precisely, such an interval variable behaves as follows: * When the underlying must be performed, the returned interval variable     behaves exactly as the underlying; * When the underlying may or may not be performed, the returned interval     variable behaves like the underlying, except that it is unbounded on     the min side; * When the underlying cannot be performed, the returned interval variable     is of duration 0 and must be performed in an interval unbounded on     both sides. This is very useful to implement propagators that may only modify the start max or end max.&#34;&#34;&#34;
    return _pywrapcp.Solver_IntervalRelaxedMin(self, interval_var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IntervalVar"><code class="name flex">
<span>def <span class="ident">IntervalVar</span></span>(<span>self, start_min: int64, start_max: int64, duration_min: int64, duration_max: int64, end_min: int64, end_max: int64, optional: bool, name: std::string const &) -> 'operations_research::<a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an interval var by specifying the bounds on start, duration, and end.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IntervalVar(self, start_min: &#34;int64&#34;, start_max: &#34;int64&#34;, duration_min: &#34;int64&#34;, duration_max: &#34;int64&#34;, end_min: &#34;int64&#34;, end_max: &#34;int64&#34;, optional: &#34;bool&#34;, name: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
    r&#34;&#34;&#34; Creates an interval var by specifying the bounds on start, duration, and end.&#34;&#34;&#34;
    return _pywrapcp.Solver_IntervalVar(self, start_min, start_max, duration_min, duration_max, end_min, end_max, optional, name)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.InversePermutationConstraint"><code class="name flex">
<span>def <span class="ident">InversePermutationConstraint</span></span>(<span>self, left: std::vector< operations_research::IntVar * > const &, right: std::vector< operations_research::IntVar * > const &) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a constraint that enforces that 'left' and 'right' both represent permutations of [0..left.size()-1], and that 'right' is the inverse permutation of 'left', i.e. for all i in [0..left.size()-1], right[left[i]] = i.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def InversePermutationConstraint(self, left: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, right: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; Creates a constraint that enforces that &#39;left&#39; and &#39;right&#39; both represent permutations of [0..left.size()-1], and that &#39;right&#39; is the inverse permutation of &#39;left&#39;, i.e. for all i in [0..left.size()-1], right[left[i]] = i.&#34;&#34;&#34;
    return _pywrapcp.Solver_InversePermutationConstraint(self, left, right)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsBetweenCt"><code class="name flex">
<span>def <span class="ident">IsBetweenCt</span></span>(<span>self, expr: IntExpr, l: int64, u: int64, b: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>b == (l &lt;= expr &lt;= u)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsBetweenCt(self, expr: &#34;IntExpr&#34;, l: &#34;int64&#34;, u: &#34;int64&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; b == (l &lt;= expr &lt;= u)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsBetweenCt(self, expr, l, u, b)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsBetweenVar"><code class="name flex">
<span>def <span class="ident">IsBetweenVar</span></span>(<span>self, v: IntExpr, l: int64, u: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsBetweenVar(self, v: &#34;IntExpr&#34;, l: &#34;int64&#34;, u: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    return _pywrapcp.Solver_IsBetweenVar(self, v, l, u)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsDifferentCstCt"><code class="name flex">
<span>def <span class="ident">IsDifferentCstCt</span></span>(<span>self, var: IntExpr, value: int64, boolvar: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>boolvar == (var != value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsDifferentCstCt(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;, boolvar: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; boolvar == (var != value)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsDifferentCstCt(self, var, value, boolvar)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsDifferentCstVar"><code class="name flex">
<span>def <span class="ident">IsDifferentCstVar</span></span>(<span>self, var: IntExpr, value: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>status var of (var != value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsDifferentCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; status var of (var != value)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsDifferentCstVar(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsDifferentCt"><code class="name flex">
<span>def <span class="ident">IsDifferentCt</span></span>(<span>self, v1: IntExpr, v2: IntExpr, b: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>b == (v1 != v2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsDifferentCt(self, v1: &#34;IntExpr&#34;, v2: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; b == (v1 != v2)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsDifferentCt(self, v1, v2, b)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsDifferentVar"><code class="name flex">
<span>def <span class="ident">IsDifferentVar</span></span>(<span>self, v1: IntExpr, v2: IntExpr) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>status var of (v1 != v2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsDifferentVar(self, v1: &#34;IntExpr&#34;, v2: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; status var of (v1 != v2)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsDifferentVar(self, v1, v2)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsEqualCstCt"><code class="name flex">
<span>def <span class="ident">IsEqualCstCt</span></span>(<span>self, var: IntExpr, value: int64, boolvar: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>boolvar == (var == value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsEqualCstCt(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;, boolvar: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; boolvar == (var == value)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsEqualCstCt(self, var, value, boolvar)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsEqualCstVar"><code class="name flex">
<span>def <span class="ident">IsEqualCstVar</span></span>(<span>self, var: IntExpr, value: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>status var of (var == value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsEqualCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; status var of (var == value)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsEqualCstVar(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsEqualCt"><code class="name flex">
<span>def <span class="ident">IsEqualCt</span></span>(<span>self, v1: IntExpr, v2: IntExpr, b: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>b == (v1 == v2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsEqualCt(self, v1: &#34;IntExpr&#34;, v2: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; b == (v1 == v2)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsEqualCt(self, v1, v2, b)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsEqualVar"><code class="name flex">
<span>def <span class="ident">IsEqualVar</span></span>(<span>self, v1: IntExpr, v2: IntExpr) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>status var of (v1 == v2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsEqualVar(self, v1: &#34;IntExpr&#34;, v2: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; status var of (v1 == v2)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsEqualVar(self, v1, v2)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsGreaterCstCt"><code class="name flex">
<span>def <span class="ident">IsGreaterCstCt</span></span>(<span>self, v: IntExpr, c: int64, b: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>b == (v &gt; c)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsGreaterCstCt(self, v: &#34;IntExpr&#34;, c: &#34;int64&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; b == (v &gt; c)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsGreaterCstCt(self, v, c, b)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsGreaterCstVar"><code class="name flex">
<span>def <span class="ident">IsGreaterCstVar</span></span>(<span>self, var: IntExpr, value: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>status var of (var &gt; value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsGreaterCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; status var of (var &gt; value)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsGreaterCstVar(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsGreaterCt"><code class="name flex">
<span>def <span class="ident">IsGreaterCt</span></span>(<span>self, left: IntExpr, right: IntExpr, b: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>b == (left &gt; right)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsGreaterCt(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; b == (left &gt; right)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsGreaterCt(self, left, right, b)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsGreaterOrEqualCstCt"><code class="name flex">
<span>def <span class="ident">IsGreaterOrEqualCstCt</span></span>(<span>self, var: IntExpr, value: int64, boolvar: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>boolvar == (var &gt;= value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsGreaterOrEqualCstCt(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;, boolvar: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; boolvar == (var &gt;= value)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsGreaterOrEqualCstCt(self, var, value, boolvar)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsGreaterOrEqualCstVar"><code class="name flex">
<span>def <span class="ident">IsGreaterOrEqualCstVar</span></span>(<span>self, var: IntExpr, value: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>status var of (var &gt;= value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsGreaterOrEqualCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; status var of (var &gt;= value)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsGreaterOrEqualCstVar(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsGreaterOrEqualCt"><code class="name flex">
<span>def <span class="ident">IsGreaterOrEqualCt</span></span>(<span>self, left: IntExpr, right: IntExpr, b: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>b == (left &gt;= right)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsGreaterOrEqualCt(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; b == (left &gt;= right)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsGreaterOrEqualCt(self, left, right, b)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsGreaterOrEqualVar"><code class="name flex">
<span>def <span class="ident">IsGreaterOrEqualVar</span></span>(<span>self, left: IntExpr, right: IntExpr) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>status var of (left &gt;= right)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsGreaterOrEqualVar(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; status var of (left &gt;= right)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsGreaterOrEqualVar(self, left, right)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsGreaterVar"><code class="name flex">
<span>def <span class="ident">IsGreaterVar</span></span>(<span>self, left: IntExpr, right: IntExpr) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>status var of (left &gt; right)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsGreaterVar(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; status var of (left &gt; right)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsGreaterVar(self, left, right)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsLessCstCt"><code class="name flex">
<span>def <span class="ident">IsLessCstCt</span></span>(<span>self, v: IntExpr, c: int64, b: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>b == (v &lt; c)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsLessCstCt(self, v: &#34;IntExpr&#34;, c: &#34;int64&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; b == (v &lt; c)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsLessCstCt(self, v, c, b)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsLessCstVar"><code class="name flex">
<span>def <span class="ident">IsLessCstVar</span></span>(<span>self, var: IntExpr, value: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>status var of (var &lt; value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsLessCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; status var of (var &lt; value)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsLessCstVar(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsLessCt"><code class="name flex">
<span>def <span class="ident">IsLessCt</span></span>(<span>self, left: IntExpr, right: IntExpr, b: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>b == (left &lt; right)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsLessCt(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; b == (left &lt; right)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsLessCt(self, left, right, b)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsLessOrEqualCstCt"><code class="name flex">
<span>def <span class="ident">IsLessOrEqualCstCt</span></span>(<span>self, var: IntExpr, value: int64, boolvar: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>boolvar == (var &lt;= value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsLessOrEqualCstCt(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;, boolvar: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; boolvar == (var &lt;= value)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsLessOrEqualCstCt(self, var, value, boolvar)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsLessOrEqualCstVar"><code class="name flex">
<span>def <span class="ident">IsLessOrEqualCstVar</span></span>(<span>self, var: IntExpr, value: int64) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>status var of (var &lt;= value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsLessOrEqualCstVar(self, var: &#34;IntExpr&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; status var of (var &lt;= value)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsLessOrEqualCstVar(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsLessOrEqualCt"><code class="name flex">
<span>def <span class="ident">IsLessOrEqualCt</span></span>(<span>self, left: IntExpr, right: IntExpr, b: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>b == (left &lt;= right)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsLessOrEqualCt(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;, b: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; b == (left &lt;= right)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsLessOrEqualCt(self, left, right, b)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsLessOrEqualVar"><code class="name flex">
<span>def <span class="ident">IsLessOrEqualVar</span></span>(<span>self, left: IntExpr, right: IntExpr) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>status var of (left &lt;= right)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsLessOrEqualVar(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; status var of (left &lt;= right)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsLessOrEqualVar(self, left, right)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsLessVar"><code class="name flex">
<span>def <span class="ident">IsLessVar</span></span>(<span>self, left: IntExpr, right: IntExpr) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>status var of (left &lt; right)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsLessVar(self, left: &#34;IntExpr&#34;, right: &#34;IntExpr&#34;) -&gt; &#34;operations_research::IntVar *&#34;:
    r&#34;&#34;&#34; status var of (left &lt; right)&#34;&#34;&#34;
    return _pywrapcp.Solver_IsLessVar(self, left, right)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsMemberCt"><code class="name flex">
<span>def <span class="ident">IsMemberCt</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsMemberCt(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_IsMemberCt(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.IsMemberVar"><code class="name flex">
<span>def <span class="ident">IsMemberVar</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def IsMemberVar(self, *args) -&gt; &#34;operations_research::IntVar *&#34;:
    return _pywrapcp.Solver_IsMemberVar(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.LastSolutionCollector"><code class="name flex">
<span>def <span class="ident">LastSolutionCollector</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.SolutionCollector" href="#pywrapcp.SolutionCollector">SolutionCollector</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Collect the last solution of the search.</p>
<p>|</p>
<p><em>Overload 2:</em>
Collect the last solution of the search. The variables will need to be added later.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LastSolutionCollector(self, *args) -&gt; &#34;operations_research::SolutionCollector *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Collect the last solution of the search.

    |

    *Overload 2:*
    Collect the last solution of the search. The variables will need to be added later.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_LastSolutionCollector(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.LexicalLess"><code class="name flex">
<span>def <span class="ident">LexicalLess</span></span>(<span>self, left: std::vector< operations_research::IntVar * > const &, right: std::vector< operations_research::IntVar * > const &) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a constraint that enforces that left is lexicographically less than right.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LexicalLess(self, left: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, right: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; Creates a constraint that enforces that left is lexicographically less than right.&#34;&#34;&#34;
    return _pywrapcp.Solver_LexicalLess(self, left, right)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.LexicalLessOrEqual"><code class="name flex">
<span>def <span class="ident">LexicalLessOrEqual</span></span>(<span>self, left: std::vector< operations_research::IntVar * > const &, right: std::vector< operations_research::IntVar * > const &) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a constraint that enforces that left is lexicographically less than or equal to right.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LexicalLessOrEqual(self, left: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, right: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; Creates a constraint that enforces that left is lexicographically less than or equal to right.&#34;&#34;&#34;
    return _pywrapcp.Solver_LexicalLessOrEqual(self, left, right)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Limit"><code class="name flex">
<span>def <span class="ident">Limit</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.SearchLimit" href="#pywrapcp.SearchLimit">SearchLimit</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Limits the search with the 'time', 'branches', 'failures' and 'solutions' limits.</p>
<p>|</p>
<p><em>Overload 2:</em>
Version reducing calls to wall timer by estimating number of remaining calls.</p>
<p>|</p>
<p><em>Overload 3:</em>
Creates a search limit which can either apply cumulatively or search-by-search.</p>
<p>|</p>
<p><em>Overload 4:</em>
Creates a search limit from its protobuf description</p>
<p>|</p>
<p><em>Overload 5:</em>
Creates a search limit that is reached when either of the underlying limit is reached. That is, the returned limit is more stringent than both argument limits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Limit(self, *args) -&gt; &#34;operations_research::SearchLimit *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Limits the search with the &#39;time&#39;, &#39;branches&#39;, &#39;failures&#39; and &#39;solutions&#39; limits.

    |

    *Overload 2:*
    Version reducing calls to wall timer by estimating number of remaining calls.

    |

    *Overload 3:*
    Creates a search limit which can either apply cumulatively or search-by-search.

    |

    *Overload 4:*
    Creates a search limit from its protobuf description

    |

    *Overload 5:*
    Creates a search limit that is reached when either of the underlying limit is reached. That is, the returned limit is more stringent than both argument limits.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_Limit(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.LocalSearchPhase"><code class="name flex">
<span>def <span class="ident">LocalSearchPhase</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LocalSearchPhase(self, *args) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_LocalSearchPhase(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.LocalSearchPhaseParameters"><code class="name flex">
<span>def <span class="ident">LocalSearchPhaseParameters</span></span>(<span>self, *args) -> 'operations_research::LocalSearchPhaseParameters *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LocalSearchPhaseParameters(self, *args) -&gt; &#34;operations_research::LocalSearchPhaseParameters *&#34;:
    return _pywrapcp.Solver_LocalSearchPhaseParameters(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.LocalSearchProfile"><code class="name flex">
<span>def <span class="ident">LocalSearchProfile</span></span>(<span>self) -> 'std::string'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns local search profiling information in a human readable format. search profiles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LocalSearchProfile(self) -&gt; &#34;std::string&#34;:
    r&#34;&#34;&#34; Returns local search profiling information in a human readable format. search profiles.&#34;&#34;&#34;
    return _pywrapcp.Solver_LocalSearchProfile(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.LubyRestart"><code class="name flex">
<span>def <span class="ident">LubyRestart</span></span>(<span>self, scale_factor: int) -> 'operations_research::<a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>This search monitor will restart the search periodically. At the iteration n, it will restart after scale_factor * Luby(n) failures where Luby is the Luby Strategy (i.e. 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8&hellip;).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LubyRestart(self, scale_factor: &#34;int&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
    r&#34;&#34;&#34; This search monitor will restart the search periodically. At the iteration n, it will restart after scale_factor * Luby(n) failures where Luby is the Luby Strategy (i.e. 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8...).&#34;&#34;&#34;
    return _pywrapcp.Solver_LubyRestart(self, scale_factor)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Max"><code class="name flex">
<span>def <span class="ident">Max</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
std::max(vars)</p>
<p>|</p>
<p><em>Overload 2:</em>
std::max(left, right)</p>
<p>|</p>
<p><em>Overload 3:</em>
std::max(expr, value)</p>
<p>|</p>
<p><em>Overload 4:</em>
std::max(expr, value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Max(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    std::max(vars)

    |

    *Overload 2:*
    std::max(left, right)

    |

    *Overload 3:*
    std::max(expr, value)

    |

    *Overload 4:*
    std::max(expr, value)
    &#34;&#34;&#34;
    return _pywrapcp.Solver_Max(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.MaxEquality"><code class="name flex">
<span>def <span class="ident">MaxEquality</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, max_var: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MaxEquality(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, max_var: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_MaxEquality(self, vars, max_var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Maximize"><code class="name flex">
<span>def <span class="ident">Maximize</span></span>(<span>self, v: IntVar, step: int64) -> 'operations_research::<a title="pywrapcp.OptimizeVar" href="#pywrapcp.OptimizeVar">OptimizeVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a maximization objective.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Maximize(self, v: &#34;IntVar&#34;, step: &#34;int64&#34;) -&gt; &#34;operations_research::OptimizeVar *&#34;:
    r&#34;&#34;&#34; Creates a maximization objective.&#34;&#34;&#34;
    return _pywrapcp.Solver_Maximize(self, v, step)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.MemberCt"><code class="name flex">
<span>def <span class="ident">MemberCt</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MemberCt(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_MemberCt(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Min"><code class="name flex">
<span>def <span class="ident">Min</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
std::min(vars)</p>
<p>|</p>
<p><em>Overload 2:</em>
std::min (left, right)</p>
<p>|</p>
<p><em>Overload 3:</em>
std::min(expr, value)</p>
<p>|</p>
<p><em>Overload 4:</em>
std::min(expr, value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Min(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    std::min(vars)

    |

    *Overload 2:*
    std::min (left, right)

    |

    *Overload 3:*
    std::min(expr, value)

    |

    *Overload 4:*
    std::min(expr, value)
    &#34;&#34;&#34;
    return _pywrapcp.Solver_Min(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.MinEquality"><code class="name flex">
<span>def <span class="ident">MinEquality</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, min_var: IntVar) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MinEquality(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, min_var: &#34;IntVar&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_MinEquality(self, vars, min_var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Minimize"><code class="name flex">
<span>def <span class="ident">Minimize</span></span>(<span>self, v: IntVar, step: int64) -> 'operations_research::<a title="pywrapcp.OptimizeVar" href="#pywrapcp.OptimizeVar">OptimizeVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a minimization objective.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Minimize(self, v: &#34;IntVar&#34;, step: &#34;int64&#34;) -&gt; &#34;operations_research::OptimizeVar *&#34;:
    r&#34;&#34;&#34; Creates a minimization objective.&#34;&#34;&#34;
    return _pywrapcp.Solver_Minimize(self, v, step)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.MirrorInterval"><code class="name flex">
<span>def <span class="ident">MirrorInterval</span></span>(<span>self, interval_var: IntervalVar) -> 'operations_research::<a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an interval var that is the mirror image of the given one, that is, the interval var obtained by reversing the axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MirrorInterval(self, interval_var: &#34;IntervalVar&#34;) -&gt; &#34;operations_research::IntervalVar *&#34;:
    r&#34;&#34;&#34; Creates an interval var that is the mirror image of the given one, that is, the interval var obtained by reversing the axis.&#34;&#34;&#34;
    return _pywrapcp.Solver_MirrorInterval(self, interval_var)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.MonotonicElement"><code class="name flex">
<span>def <span class="ident">MonotonicElement</span></span>(<span>self, values: operations_research::Solver::IndexEvaluator1, increasing: bool, index: IntVar) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Function based element. The constraint takes ownership of the callback.
The callback must be monotonic. It must be able to cope with any possible value in the domain of 'index' (potentially negative ones too). Furtermore, monotonicity is not checked. Thus giving a non-monotonic function, or specifying an incorrect increasing parameter will result in undefined behavior.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MonotonicElement(self, values: &#34;operations_research::Solver::IndexEvaluator1&#34;, increasing: &#34;bool&#34;, index: &#34;IntVar&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
    r&#34;&#34;&#34; Function based element. The constraint takes ownership of the callback.  The callback must be monotonic. It must be able to cope with any possible value in the domain of &#39;index&#39; (potentially negative ones too). Furtermore, monotonicity is not checked. Thus giving a non-monotonic function, or specifying an incorrect increasing parameter will result in undefined behavior.&#34;&#34;&#34;
    return _pywrapcp.Solver_MonotonicElement(self, values, increasing, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.MoveTowardTargetOperator"><code class="name flex">
<span>def <span class="ident">MoveTowardTargetOperator</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Creates a local search operator that tries to move the assignment of some variables toward a target. The target is given as an Assignment. This operator generates neighbors in which the only difference compared to the current state is that one variable that belongs to the target assignment is set to its target value.</p>
<p>|</p>
<p><em>Overload 2:</em>
Creates a local search operator that tries to move the assignment of some variables toward a target. The target is given either as two vectors: a vector of variables and a vector of associated target values. The two vectors should be of the same length. This operator generates neighbors in which the only difference compared to the current state is that one variable that belongs to the given vector is set to its target value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MoveTowardTargetOperator(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Creates a local search operator that tries to move the assignment of some variables toward a target. The target is given as an Assignment. This operator generates neighbors in which the only difference compared to the current state is that one variable that belongs to the target assignment is set to its target value.

    |

    *Overload 2:*
    Creates a local search operator that tries to move the assignment of some variables toward a target. The target is given either as two vectors: a vector of variables and a vector of associated target values. The two vectors should be of the same length. This operator generates neighbors in which the only difference compared to the current state is that one variable that belongs to the given vector is set to its target value.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_MoveTowardTargetOperator(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.NeighborhoodLimit"><code class="name flex">
<span>def <span class="ident">NeighborhoodLimit</span></span>(<span>self, op: LocalSearchOperator, limit: int64) -> 'operations_research::<a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a local search operator that wraps another local search operator and limits the number of neighbors explored (i.e., calls to MakeNextNeighbor from the current solution (between two calls to Start()). When this limit is reached, MakeNextNeighbor() returns false. The counter is cleared when Start() is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NeighborhoodLimit(self, op: &#34;LocalSearchOperator&#34;, limit: &#34;int64&#34;) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
    r&#34;&#34;&#34; Creates a local search operator that wraps another local search operator and limits the number of neighbors explored (i.e., calls to MakeNextNeighbor from the current solution (between two calls to Start()). When this limit is reached, MakeNextNeighbor() returns false. The counter is cleared when Start() is called.&#34;&#34;&#34;
    return _pywrapcp.Solver_NeighborhoodLimit(self, op, limit)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.NestedOptimize"><code class="name flex">
<span>def <span class="ident">NestedOptimize</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NestedOptimize(self, *args) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_NestedOptimize(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.NewSearch"><code class="name flex">
<span>def <span class="ident">NewSearch</span></span>(<span>self, *args) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NewSearch(self, *args) -&gt; &#34;void&#34;:
    return _pywrapcp.Solver_NewSearch(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.NextSolution"><code class="name flex">
<span>def <span class="ident">NextSolution</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NextSolution(self) -&gt; &#34;bool&#34;:
    return _pywrapcp.Solver_NextSolution(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.NonOverlappingBoxesConstraint"><code class="name flex">
<span>def <span class="ident">NonOverlappingBoxesConstraint</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NonOverlappingBoxesConstraint(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_NonOverlappingBoxesConstraint(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.NotMemberCt"><code class="name flex">
<span>def <span class="ident">NotMemberCt</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
expr not in set.</p>
<p>|</p>
<p><em>Overload 2:</em>
expr should not be in the list of forbidden intervals [start[i]..end[i]].</p>
<p>|</p>
<p><em>Overload 3:</em>
expr should not be in the list of forbidden intervals [start[i]..end[i]].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NotMemberCt(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    expr not in set.

    |

    *Overload 2:*
    expr should not be in the list of forbidden intervals [start[i]..end[i]].

    |

    *Overload 3:*
    expr should not be in the list of forbidden intervals [start[i]..end[i]].
    &#34;&#34;&#34;
    return _pywrapcp.Solver_NotMemberCt(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.NullIntersect"><code class="name flex">
<span>def <span class="ident">NullIntersect</span></span>(<span>self, first_vars: std::vector< operations_research::IntVar * > const &, second_vars: std::vector< operations_research::IntVar * > const &) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a constraint that states that all variables in the first vector are different from all variables in the second group. Thus the set of values in the first vector does not intersect with the set of values in the second vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NullIntersect(self, first_vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, second_vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; Creates a constraint that states that all variables in the first vector are different from all variables in the second group. Thus the set of values in the first vector does not intersect with the set of values in the second vector.&#34;&#34;&#34;
    return _pywrapcp.Solver_NullIntersect(self, first_vars, second_vars)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.NullIntersectExcept"><code class="name flex">
<span>def <span class="ident">NullIntersectExcept</span></span>(<span>self, first_vars: std::vector< operations_research::IntVar * > const &, second_vars: std::vector< operations_research::IntVar * > const &, escape_value: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a constraint that states that all variables in the first vector are different from all variables from the second group, unless they are assigned to the escape value. Thus the set of values in the first vector minus the escape value does not intersect with the set of values in the second vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NullIntersectExcept(self, first_vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, second_vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, escape_value: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; Creates a constraint that states that all variables in the first vector are different from all variables from the second group, unless they are assigned to the escape value. Thus the set of values in the first vector minus the escape value does not intersect with the set of values in the second vector.&#34;&#34;&#34;
    return _pywrapcp.Solver_NullIntersectExcept(self, first_vars, second_vars, escape_value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Operator"><code class="name flex">
<span>def <span class="ident">Operator</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Operator(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
    return _pywrapcp.Solver_Operator(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Optimize"><code class="name flex">
<span>def <span class="ident">Optimize</span></span>(<span>self, maximize: bool, v: IntVar, step: int64) -> 'operations_research::<a title="pywrapcp.OptimizeVar" href="#pywrapcp.OptimizeVar">OptimizeVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a objective with a given sense (true = maximization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Optimize(self, maximize: &#34;bool&#34;, v: &#34;IntVar&#34;, step: &#34;int64&#34;) -&gt; &#34;operations_research::OptimizeVar *&#34;:
    r&#34;&#34;&#34; Creates a objective with a given sense (true = maximization).&#34;&#34;&#34;
    return _pywrapcp.Solver_Optimize(self, maximize, v, step)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Pack"><code class="name flex">
<span>def <span class="ident">Pack</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, number_of_bins: int) -> 'operations_research::<a title="pywrapcp.Pack" href="#pywrapcp.Pack">Pack</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>This constraint packs all variables onto 'number_of_bins' variables.
For any given variable, a value of 'number_of_bins' indicates that the variable is not assigned to any bin. Dimensions, i.e., cumulative constraints on this packing, can be added directly from the pack class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Pack(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, number_of_bins: &#34;int&#34;) -&gt; &#34;operations_research::Pack *&#34;:
    r&#34;&#34;&#34; This constraint packs all variables onto &#39;number_of_bins&#39; variables.  For any given variable, a value of &#39;number_of_bins&#39; indicates that the variable is not assigned to any bin. Dimensions, i.e., cumulative constraints on this packing, can be added directly from the pack class.&#34;&#34;&#34;
    return _pywrapcp.Solver_Pack(self, vars, number_of_bins)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Parameters"><code class="name flex">
<span>def <span class="ident">Parameters</span></span>(<span>self) -> 'operations_research::ConstraintSolverParameters'</span>
</code></dt>
<dd>
<div class="desc"><p>Stored Parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Parameters(self) -&gt; &#34;operations_research::ConstraintSolverParameters&#34;:
    r&#34;&#34;&#34; Stored Parameters.&#34;&#34;&#34;
    return _pywrapcp.Solver_Parameters(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.PathCumul"><code class="name flex">
<span>def <span class="ident">PathCumul</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Creates a constraint which accumulates values along a path such that: cumuls[next[i]] = cumuls[i] + transits[i]. Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem.</p>
<p>|</p>
<p><em>Overload 2:</em>
Creates a constraint which accumulates values along a path such that: cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]). Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem. Ownership of transit_evaluator is taken and it must be a repeatable callback.</p>
<p>|</p>
<p><em>Overload 3:</em>
Creates a constraint which accumulates values along a path such that: cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]) + slacks[i]. Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem. Ownership of transit_evaluator is taken and it must be a repeatable callback.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PathCumul(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Creates a constraint which accumulates values along a path such that: cumuls[next[i]] = cumuls[i] + transits[i]. Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem.

    |

    *Overload 2:*
    Creates a constraint which accumulates values along a path such that: cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]). Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem. Ownership of transit_evaluator is taken and it must be a repeatable callback.

    |

    *Overload 3:*
    Creates a constraint which accumulates values along a path such that: cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]) + slacks[i]. Active variables indicate if the corresponding next variable is active; this could be useful to model unperformed nodes in a routing problem. Ownership of transit_evaluator is taken and it must be a repeatable callback.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_PathCumul(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Phase"><code class="name flex">
<span>def <span class="ident">Phase</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Phase(self, *args) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_Phase(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.PrintModelVisitor"><code class="name flex">
<span>def <span class="ident">PrintModelVisitor</span></span>(<span>self) -> 'operations_research::ModelVisitor *'</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PrintModelVisitor(self) -&gt; &#34;operations_research::ModelVisitor *&#34;:
    r&#34;&#34;&#34; Prints the model.&#34;&#34;&#34;
    return _pywrapcp.Solver_PrintModelVisitor(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Rand32"><code class="name flex">
<span>def <span class="ident">Rand32</span></span>(<span>self, size: int32) -> 'int32'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a random value between 0 and 'size' - 1;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Rand32(self, size: &#34;int32&#34;) -&gt; &#34;int32&#34;:
    r&#34;&#34;&#34; Returns a random value between 0 and &#39;size&#39; - 1;&#34;&#34;&#34;
    return _pywrapcp.Solver_Rand32(self, size)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Rand64"><code class="name flex">
<span>def <span class="ident">Rand64</span></span>(<span>self, size: int64) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a random value between 0 and 'size' - 1;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Rand64(self, size: &#34;int64&#34;) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; Returns a random value between 0 and &#39;size&#39; - 1;&#34;&#34;&#34;
    return _pywrapcp.Solver_Rand64(self, size)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.RandomConcatenateOperators"><code class="name flex">
<span>def <span class="ident">RandomConcatenateOperators</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Randomized version of local search concatenator; calls a random operator at each call to MakeNextNeighbor().</p>
<p>|</p>
<p><em>Overload 2:</em>
Randomized version of local search concatenator; calls a random operator at each call to MakeNextNeighbor(). The provided seed is used to initialize the random number generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RandomConcatenateOperators(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Randomized version of local search concatenator; calls a random operator at each call to MakeNextNeighbor().

    |

    *Overload 2:*
    Randomized version of local search concatenator; calls a random operator at each call to MakeNextNeighbor(). The provided seed is used to initialize the random number generator.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_RandomConcatenateOperators(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.RandomLnsOperator"><code class="name flex">
<span>def <span class="ident">RandomLnsOperator</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RandomLnsOperator(self, *args) -&gt; &#34;operations_research::LocalSearchOperator *&#34;:
    return _pywrapcp.Solver_RandomLnsOperator(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.RankFirstInterval"><code class="name flex">
<span>def <span class="ident">RankFirstInterval</span></span>(<span>self, sequence: SequenceVar, index: int) -> 'operations_research::<a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a decision that tries to rank first the ith interval var in the sequence variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RankFirstInterval(self, sequence: &#34;SequenceVar&#34;, index: &#34;int&#34;) -&gt; &#34;operations_research::Decision *&#34;:
    r&#34;&#34;&#34; Returns a decision that tries to rank first the ith interval var in the sequence variable.&#34;&#34;&#34;
    return _pywrapcp.Solver_RankFirstInterval(self, sequence, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.RankLastInterval"><code class="name flex">
<span>def <span class="ident">RankLastInterval</span></span>(<span>self, sequence: SequenceVar, index: int) -> 'operations_research::<a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a decision that tries to rank last the ith interval var in the sequence variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RankLastInterval(self, sequence: &#34;SequenceVar&#34;, index: &#34;int&#34;) -&gt; &#34;operations_research::Decision *&#34;:
    r&#34;&#34;&#34; Returns a decision that tries to rank last the ith interval var in the sequence variable.&#34;&#34;&#34;
    return _pywrapcp.Solver_RankLastInterval(self, sequence, index)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ReSeed"><code class="name flex">
<span>def <span class="ident">ReSeed</span></span>(<span>self, seed: int32) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>Reseed the solver random generator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ReSeed(self, seed: &#34;int32&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; Reseed the solver random generator.&#34;&#34;&#34;
    return _pywrapcp.Solver_ReSeed(self, seed)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.RestartCurrentSearch"><code class="name flex">
<span>def <span class="ident">RestartCurrentSearch</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RestartCurrentSearch(self) -&gt; &#34;void&#34;:
    return _pywrapcp.Solver_RestartCurrentSearch(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.RestartSearch"><code class="name flex">
<span>def <span class="ident">RestartSearch</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RestartSearch(self) -&gt; &#34;void&#34;:
    return _pywrapcp.Solver_RestartSearch(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.RestoreAssignment"><code class="name flex">
<span>def <span class="ident">RestoreAssignment</span></span>(<span>self, assignment: Assignment) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a DecisionBuilder which restores an Assignment (calls void Assignment::Restore())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RestoreAssignment(self, assignment: &#34;Assignment&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    r&#34;&#34;&#34; Returns a DecisionBuilder which restores an Assignment (calls void Assignment::Restore())&#34;&#34;&#34;
    return _pywrapcp.Solver_RestoreAssignment(self, assignment)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ScalProd"><code class="name flex">
<span>def <span class="ident">ScalProd</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
scalar product</p>
<p>|</p>
<p><em>Overload 2:</em>
scalar product</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ScalProd(self, *args) -&gt; &#34;operations_research::IntExpr *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    scalar product

    |

    *Overload 2:*
    scalar product
    &#34;&#34;&#34;
    return _pywrapcp.Solver_ScalProd(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ScalProdEquality"><code class="name flex">
<span>def <span class="ident">ScalProdEquality</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ScalProdEquality(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_ScalProdEquality(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ScalProdGreaterOrEqual"><code class="name flex">
<span>def <span class="ident">ScalProdGreaterOrEqual</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ScalProdGreaterOrEqual(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_ScalProdGreaterOrEqual(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ScalProdLessOrEqual"><code class="name flex">
<span>def <span class="ident">ScalProdLessOrEqual</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ScalProdLessOrEqual(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_ScalProdLessOrEqual(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ScheduleOrExpedite"><code class="name flex">
<span>def <span class="ident">ScheduleOrExpedite</span></span>(<span>self, var: IntervalVar, est: int64, marker: int64 *const) -> 'operations_research::<a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a decision that tries to schedule a task at a given time. On the Apply branch, it will set that interval var as performed and set its end to 'est'. On the Refute branch, it will just update the 'marker' to 'est' - 1. This decision is used in the INTERVAL_SET_TIMES_BACKWARD strategy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ScheduleOrExpedite(self, var: &#34;IntervalVar&#34;, est: &#34;int64&#34;, marker: &#34;int64 *const&#34;) -&gt; &#34;operations_research::Decision *&#34;:
    r&#34;&#34;&#34; Returns a decision that tries to schedule a task at a given time. On the Apply branch, it will set that interval var as performed and set its end to &#39;est&#39;. On the Refute branch, it will just update the &#39;marker&#39; to &#39;est&#39; - 1. This decision is used in the INTERVAL_SET_TIMES_BACKWARD strategy.&#34;&#34;&#34;
    return _pywrapcp.Solver_ScheduleOrExpedite(self, var, est, marker)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ScheduleOrPostpone"><code class="name flex">
<span>def <span class="ident">ScheduleOrPostpone</span></span>(<span>self, var: IntervalVar, est: int64, marker: int64 *const) -> 'operations_research::<a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a decision that tries to schedule a task at a given time. On the Apply branch, it will set that interval var as performed and set its start to 'est'. On the Refute branch, it will just update the 'marker' to 'est' + 1. This decision is used in the INTERVAL_SET_TIMES_FORWARD strategy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ScheduleOrPostpone(self, var: &#34;IntervalVar&#34;, est: &#34;int64&#34;, marker: &#34;int64 *const&#34;) -&gt; &#34;operations_research::Decision *&#34;:
    r&#34;&#34;&#34; Returns a decision that tries to schedule a task at a given time. On the Apply branch, it will set that interval var as performed and set its start to &#39;est&#39;. On the Refute branch, it will just update the &#39;marker&#39; to &#39;est&#39; + 1. This decision is used in the INTERVAL_SET_TIMES_FORWARD strategy.&#34;&#34;&#34;
    return _pywrapcp.Solver_ScheduleOrPostpone(self, var, est, marker)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SearchDepth"><code class="name flex">
<span>def <span class="ident">SearchDepth</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the search depth of the current active search. Returns -1 if there is no active search opened.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SearchDepth(self) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Gets the search depth of the current active search. Returns -1 if there is no active search opened.&#34;&#34;&#34;
    return _pywrapcp.Solver_SearchDepth(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SearchLeftDepth"><code class="name flex">
<span>def <span class="ident">SearchLeftDepth</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the search left depth of the current active search. Returns -1 if there is no active search opened.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SearchLeftDepth(self) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Gets the search left depth of the current active search. Returns -1 if there is no active search opened.&#34;&#34;&#34;
    return _pywrapcp.Solver_SearchLeftDepth(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SearchLog"><code class="name flex">
<span>def <span class="ident">SearchLog</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SearchLog(self, *args) -&gt; &#34;operations_research::SearchMonitor *&#34;:
    return _pywrapcp.Solver_SearchLog(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SearchLogWithCallback"><code class="name flex">
<span>def <span class="ident">SearchLogWithCallback</span></span>(<span>self, period: int, callback: std::function< std::string () >) -> 'operations_research::<a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SearchLogWithCallback(self, period: &#34;int&#34;, callback: &#34;std::function&lt; std::string () &gt;&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
    return _pywrapcp.Solver_SearchLogWithCallback(self, period, callback)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SearchTrace"><code class="name flex">
<span>def <span class="ident">SearchTrace</span></span>(<span>self, prefix: std::string const &) -> 'operations_research::<a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a search monitor that will trace precisely the behavior of the search. Use this only for low level debugging.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SearchTrace(self, prefix: &#34;std::string const &amp;&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
    r&#34;&#34;&#34; Creates a search monitor that will trace precisely the behavior of the search. Use this only for low level debugging.&#34;&#34;&#34;
    return _pywrapcp.Solver_SearchTrace(self, prefix)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SemiContinuousExpr"><code class="name flex">
<span>def <span class="ident">SemiContinuousExpr</span></span>(<span>self, expr: IntExpr, fixed_charge: int64, step: int64) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Semi continuous Expression (x &lt;= 0 -&gt; f(x) = 0; x &gt; 0 -&gt; f(x) = ax + b) a &gt;= 0 and b &gt;= 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SemiContinuousExpr(self, expr: &#34;IntExpr&#34;, fixed_charge: &#34;int64&#34;, step: &#34;int64&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
    r&#34;&#34;&#34; Semi continuous Expression (x &lt;= 0 -&gt; f(x) = 0; x &gt; 0 -&gt; f(x) = ax + b) a &gt;= 0 and b &gt;= 0&#34;&#34;&#34;
    return _pywrapcp.Solver_SemiContinuousExpr(self, expr, fixed_charge, step)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.ShouldFail"><code class="name flex">
<span>def <span class="ident">ShouldFail</span></span>(<span>self) -> 'void'</span>
</code></dt>
<dd>
<div class="desc"><p>These methods are only useful for the SWIG wrappers, which need a way to externally cause the Solver to fail.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ShouldFail(self) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34; These methods are only useful for the SWIG wrappers, which need a way to externally cause the Solver to fail.&#34;&#34;&#34;
    return _pywrapcp.Solver_ShouldFail(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SimulatedAnnealing"><code class="name flex">
<span>def <span class="ident">SimulatedAnnealing</span></span>(<span>self, maximize: bool, v: IntVar, step: int64, initial_temperature: int64) -> 'operations_research::<a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a Simulated Annealing monitor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SimulatedAnnealing(self, maximize: &#34;bool&#34;, v: &#34;IntVar&#34;, step: &#34;int64&#34;, initial_temperature: &#34;int64&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
    r&#34;&#34;&#34; Creates a Simulated Annealing monitor.&#34;&#34;&#34;
    return _pywrapcp.Solver_SimulatedAnnealing(self, maximize, v, step, initial_temperature)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Solutions"><code class="name flex">
<span>def <span class="ident">Solutions</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>The number of solutions found since the start of the search.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Solutions(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; The number of solutions found since the start of the search.&#34;&#34;&#34;
    return _pywrapcp.Solver_Solutions(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SolutionsLimit"><code class="name flex">
<span>def <span class="ident">SolutionsLimit</span></span>(<span>self, solutions: int64) -> 'operations_research::RegularLimit *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a search limit that constrains the number of solutions found during the search.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SolutionsLimit(self, solutions: &#34;int64&#34;) -&gt; &#34;operations_research::RegularLimit *&#34;:
    r&#34;&#34;&#34; Creates a search limit that constrains the number of solutions found during the search.&#34;&#34;&#34;
    return _pywrapcp.Solver_SolutionsLimit(self, solutions)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Solve"><code class="name flex">
<span>def <span class="ident">Solve</span></span>(<span>self, *args) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Solve(self, *args) -&gt; &#34;bool&#34;:
    return _pywrapcp.Solver_Solve(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SolveAndCommit"><code class="name flex">
<span>def <span class="ident">SolveAndCommit</span></span>(<span>self, *args) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SolveAndCommit(self, *args) -&gt; &#34;bool&#34;:
    return _pywrapcp.Solver_SolveAndCommit(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SolveDepth"><code class="name flex">
<span>def <span class="ident">SolveDepth</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the number of nested searches. It returns 0 outside search, 1 during the top level search, 2 or more in case of nested searches.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SolveDepth(self) -&gt; &#34;int&#34;:
    r&#34;&#34;&#34; Gets the number of nested searches. It returns 0 outside search, 1 during the top level search, 2 or more in case of nested searches.&#34;&#34;&#34;
    return _pywrapcp.Solver_SolveDepth(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SolveOnce"><code class="name flex">
<span>def <span class="ident">SolveOnce</span></span>(<span>self, db: DecisionBuilder, monitors: std::vector< operations_research::SearchMonitor * > const &) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SolveOnce(self, db: &#34;DecisionBuilder&#34;, monitors: &#34;std::vector&lt; operations_research::SearchMonitor * &gt; const &amp;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_SolveOnce(self, db, monitors)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SortingConstraint"><code class="name flex">
<span>def <span class="ident">SortingConstraint</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, sorted: std::vector< operations_research::IntVar * > const &) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a constraint binding the arrays of variables "vars" and "sorted_vars": sorted_vars[0] must be equal to the minimum of all variables in vars, and so on: the value of sorted_vars[i] must be equal to the i-th value of variables invars. This constraint propagates in both directions: from "vars" to "sorted_vars" and vice-versa. Behind the scenes, this constraint maintains that:
- sorted is always increasing.
- whatever the values of vars, there exists a permutation that
injects its values into the sorted variables. For more info, please have a look at:
<a href="https://mpi-inf.mpg.de/~mehlhorn/ftp/Mehlhorn-Thiel.pdf">https://mpi-inf.mpg.de/~mehlhorn/ftp/Mehlhorn-Thiel.pdf</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SortingConstraint(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, sorted: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; Creates a constraint binding the arrays of variables &#34;vars&#34; and &#34;sorted_vars&#34;: sorted_vars[0] must be equal to the minimum of all variables in vars, and so on: the value of sorted_vars[i] must be equal to the i-th value of variables invars. This constraint propagates in both directions: from &#34;vars&#34; to &#34;sorted_vars&#34; and vice-versa. Behind the scenes, this constraint maintains that:   - sorted is always increasing.   - whatever the values of vars, there exists a permutation that     injects its values into the sorted variables. For more info, please have a look at:   https://mpi-inf.mpg.de/~mehlhorn/ftp/Mehlhorn-Thiel.pdf&#34;&#34;&#34;
    return _pywrapcp.Solver_SortingConstraint(self, vars, sorted)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SplitVariableDomain"><code class="name flex">
<span>def <span class="ident">SplitVariableDomain</span></span>(<span>self, var: IntVar, val: int64, start_with_lower_half: bool) -> 'operations_research::<a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SplitVariableDomain(self, var: &#34;IntVar&#34;, val: &#34;int64&#34;, start_with_lower_half: &#34;bool&#34;) -&gt; &#34;operations_research::Decision *&#34;:
    return _pywrapcp.Solver_SplitVariableDomain(self, var, val, start_with_lower_half)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Stamp"><code class="name flex">
<span>def <span class="ident">Stamp</span></span>(<span>self) -> 'uint64'</span>
</code></dt>
<dd>
<div class="desc"><p>The stamp indicates how many moves in the search tree we have performed. It is useful to detect if we need to update same lazy structures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Stamp(self) -&gt; &#34;uint64&#34;:
    r&#34;&#34;&#34; The stamp indicates how many moves in the search tree we have performed. It is useful to detect if we need to update same lazy structures.&#34;&#34;&#34;
    return _pywrapcp.Solver_Stamp(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.StatisticsModelVisitor"><code class="name flex">
<span>def <span class="ident">StatisticsModelVisitor</span></span>(<span>self) -> 'operations_research::ModelVisitor *'</span>
</code></dt>
<dd>
<div class="desc"><p>Displays some nice statistics on the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StatisticsModelVisitor(self) -&gt; &#34;operations_research::ModelVisitor *&#34;:
    r&#34;&#34;&#34; Displays some nice statistics on the model.&#34;&#34;&#34;
    return _pywrapcp.Solver_StatisticsModelVisitor(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.StoreAssignment"><code class="name flex">
<span>def <span class="ident">StoreAssignment</span></span>(<span>self, assignment: Assignment) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a DecisionBuilder which stores an Assignment (calls void Assignment::Store())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StoreAssignment(self, assignment: &#34;Assignment&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    r&#34;&#34;&#34; Returns a DecisionBuilder which stores an Assignment (calls void Assignment::Store())&#34;&#34;&#34;
    return _pywrapcp.Solver_StoreAssignment(self, assignment)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SubCircuit"><code class="name flex">
<span>def <span class="ident">SubCircuit</span></span>(<span>self, nexts: std::vector< operations_research::IntVar * > const &) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Force the "nexts" variable to create a complete Hamiltonian path for those that do not loop upon themselves.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SubCircuit(self, nexts: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; Force the &#34;nexts&#34; variable to create a complete Hamiltonian path for those that do not loop upon themselves.&#34;&#34;&#34;
    return _pywrapcp.Solver_SubCircuit(self, nexts)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Sum"><code class="name flex">
<span>def <span class="ident">Sum</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &) -> 'operations_research::<a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>sum of all vars.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Sum(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;) -&gt; &#34;operations_research::IntExpr *&#34;:
    r&#34;&#34;&#34; sum of all vars.&#34;&#34;&#34;
    return _pywrapcp.Solver_Sum(self, vars)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SumEquality"><code class="name flex">
<span>def <span class="ident">SumEquality</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SumEquality(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_SumEquality(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SumGreaterOrEqual"><code class="name flex">
<span>def <span class="ident">SumGreaterOrEqual</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, cst: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SumGreaterOrEqual(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, cst: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_SumGreaterOrEqual(self, vars, cst)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SumLessOrEqual"><code class="name flex">
<span>def <span class="ident">SumLessOrEqual</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, cst: int64) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>Variation on arrays.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SumLessOrEqual(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, cst: &#34;int64&#34;) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; Variation on arrays.&#34;&#34;&#34;
    return _pywrapcp.Solver_SumLessOrEqual(self, vars, cst)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.SumObjectiveFilter"><code class="name flex">
<span>def <span class="ident">SumObjectiveFilter</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, values: operations_research::Solver::IndexEvaluator2, filter_enum: operations_research::Solver::LocalSearchFilterBound) -> 'operations_research::<a title="pywrapcp.LocalSearchFilter" href="#pywrapcp.LocalSearchFilter">LocalSearchFilter</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SumObjectiveFilter(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, values: &#34;operations_research::Solver::IndexEvaluator2&#34;, filter_enum: &#34;operations_research::Solver::LocalSearchFilterBound&#34;) -&gt; &#34;operations_research::LocalSearchFilter *&#34;:
    return _pywrapcp.Solver_SumObjectiveFilter(self, vars, values, filter_enum)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.TabuSearch"><code class="name flex">
<span>def <span class="ident">TabuSearch</span></span>(<span>self, maximize: bool, v: IntVar, step: int64, vars: std::vector< operations_research::IntVar * > const &, keep_tenure: int64, forbid_tenure: int64, tabu_factor: double) -> 'operations_research::<a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>MetaHeuristics which try to get the search out of local optima. Creates a Tabu Search monitor. In the context of local search the behavior is similar to MakeOptimize(), creating an objective in a given sense. The behavior differs once a local optimum is reached: thereafter solutions which degrade the value of the objective are allowed if they are not "tabu". A solution is "tabu" if it doesn't respect the following rules: - improving the best solution found so far - variables in the "keep" list must keep their value, variables in the "forbid" list must not take the value they have in the list. Variables with new values enter the tabu lists after each new solution found and leave the lists after a given number of iterations (called tenure). Only the variables passed to the method can enter the lists. The tabu criterion is softened by the tabu factor which gives the number of "tabu" violations which is tolerated; a factor of 1 means no violations allowed; a factor of 0 means all violations are allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TabuSearch(self, maximize: &#34;bool&#34;, v: &#34;IntVar&#34;, step: &#34;int64&#34;, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, keep_tenure: &#34;int64&#34;, forbid_tenure: &#34;int64&#34;, tabu_factor: &#34;double&#34;) -&gt; &#34;operations_research::SearchMonitor *&#34;:
    r&#34;&#34;&#34; MetaHeuristics which try to get the search out of local optima. Creates a Tabu Search monitor. In the context of local search the behavior is similar to MakeOptimize(), creating an objective in a given sense. The behavior differs once a local optimum is reached: thereafter solutions which degrade the value of the objective are allowed if they are not &#34;tabu&#34;. A solution is &#34;tabu&#34; if it doesn&#39;t respect the following rules: - improving the best solution found so far - variables in the &#34;keep&#34; list must keep their value, variables in the &#34;forbid&#34; list must not take the value they have in the list. Variables with new values enter the tabu lists after each new solution found and leave the lists after a given number of iterations (called tenure). Only the variables passed to the method can enter the lists. The tabu criterion is softened by the tabu factor which gives the number of &#34;tabu&#34; violations which is tolerated; a factor of 1 means no violations allowed; a factor of 0 means all violations are allowed.&#34;&#34;&#34;
    return _pywrapcp.Solver_TabuSearch(self, maximize, v, step, vars, keep_tenure, forbid_tenure, tabu_factor)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.TemporalDisjunction"><code class="name flex">
<span>def <span class="ident">TemporalDisjunction</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
This constraint implements a temporal disjunction between two interval vars t1 and t2. 'alt' indicates which alternative was chosen (alt == 0 is equivalent to t1 before t2).</p>
<p>|</p>
<p><em>Overload 2:</em>
This constraint implements a temporal disjunction between two interval vars.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TemporalDisjunction(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    This constraint implements a temporal disjunction between two interval vars t1 and t2. &#39;alt&#39; indicates which alternative was chosen (alt == 0 is equivalent to t1 before t2).

    |

    *Overload 2:*
    This constraint implements a temporal disjunction between two interval vars.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_TemporalDisjunction(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.TimeLimit"><code class="name flex">
<span>def <span class="ident">TimeLimit</span></span>(<span>self, time_in_ms: int64) -> 'operations_research::RegularLimit *'</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a search limit that constrains the running time given in milliseconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TimeLimit(self, time_in_ms: &#34;int64&#34;) -&gt; &#34;operations_research::RegularLimit *&#34;:
    r&#34;&#34;&#34; Creates a search limit that constrains the running time given in milliseconds.&#34;&#34;&#34;
    return _pywrapcp.Solver_TimeLimit(self, time_in_ms)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.TransitionConstraint"><code class="name flex">
<span>def <span class="ident">TransitionConstraint</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TransitionConstraint(self, *args) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_TransitionConstraint(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.TreeNoCycle"><code class="name flex">
<span>def <span class="ident">TreeNoCycle</span></span>(<span>self, nexts: std::vector< operations_research::IntVar * > const &, active: std::vector< operations_research::IntVar * > const &, callback: operations_research::Solver::IndexFilter1 = 0) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TreeNoCycle(self, nexts: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, active: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, callback: &#34;operations_research::Solver::IndexFilter1&#34;=0) -&gt; &#34;operations_research::Constraint *&#34;:
    return _pywrapcp.Solver_TreeNoCycle(self, nexts, active, callback)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.TrueConstraint"><code class="name flex">
<span>def <span class="ident">TrueConstraint</span></span>(<span>self) -> 'operations_research::<a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p>This constraint always succeeds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TrueConstraint(self) -&gt; &#34;operations_research::Constraint *&#34;:
    r&#34;&#34;&#34; This constraint always succeeds.&#34;&#34;&#34;
    return _pywrapcp.Solver_TrueConstraint(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.Try"><code class="name flex">
<span>def <span class="ident">Try</span></span>(<span>self, dbs: std::vector< operations_research::DecisionBuilder * > const &) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Try(self, dbs: &#34;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_Try(self, dbs)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.VarEvalValEvalPhase"><code class="name flex">
<span>def <span class="ident">VarEvalValEvalPhase</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, var_eval: std::function< int64 (int64) >, val_eval: operations_research::Solver::IndexEvaluator2) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VarEvalValEvalPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_eval: &#34;std::function&lt; int64 (int64) &gt;&#34;, val_eval: &#34;operations_research::Solver::IndexEvaluator2&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_VarEvalValEvalPhase(self, vars, var_eval, val_eval)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.VarEvalValEvalTieBreakPhase"><code class="name flex">
<span>def <span class="ident">VarEvalValEvalTieBreakPhase</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, var_eval: std::function< int64 (int64) >, val_eval: operations_research::Solver::IndexEvaluator2, tie_breaker: std::function< int64 (int64) >) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VarEvalValEvalTieBreakPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_eval: &#34;std::function&lt; int64 (int64) &gt;&#34;, val_eval: &#34;operations_research::Solver::IndexEvaluator2&#34;, tie_breaker: &#34;std::function&lt; int64 (int64) &gt;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_VarEvalValEvalTieBreakPhase(self, vars, var_eval, val_eval, tie_breaker)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.VarEvalValStrPhase"><code class="name flex">
<span>def <span class="ident">VarEvalValStrPhase</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, var_evaluator: std::function< int64 (int64) >, val_str: operations_research::Solver::IntValueStrategy) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VarEvalValStrPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_evaluator: &#34;std::function&lt; int64 (int64) &gt;&#34;, val_str: &#34;operations_research::Solver::IntValueStrategy&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_VarEvalValStrPhase(self, vars, var_evaluator, val_str)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.VarStrValEvalPhase"><code class="name flex">
<span>def <span class="ident">VarStrValEvalPhase</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, var_str: operations_research::Solver::IntVarStrategy, val_eval: operations_research::Solver::IndexEvaluator2) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VarStrValEvalPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_str: &#34;operations_research::Solver::IntVarStrategy&#34;, val_eval: &#34;operations_research::Solver::IndexEvaluator2&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_VarStrValEvalPhase(self, vars, var_str, val_eval)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.VarStrValEvalTieBreakPhase"><code class="name flex">
<span>def <span class="ident">VarStrValEvalTieBreakPhase</span></span>(<span>self, vars: std::vector< operations_research::IntVar * > const &, var_str: operations_research::Solver::IntVarStrategy, val_eval: operations_research::Solver::IndexEvaluator2, tie_breaker: std::function< int64 (int64) >) -> 'operations_research::<a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VarStrValEvalTieBreakPhase(self, vars: &#34;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#34;, var_str: &#34;operations_research::Solver::IntVarStrategy&#34;, val_eval: &#34;operations_research::Solver::IndexEvaluator2&#34;, tie_breaker: &#34;std::function&lt; int64 (int64) &gt;&#34;) -&gt; &#34;operations_research::DecisionBuilder *&#34;:
    return _pywrapcp.Solver_VarStrValEvalTieBreakPhase(self, vars, var_str, val_eval, tie_breaker)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.VariableGreaterOrEqualValue"><code class="name flex">
<span>def <span class="ident">VariableGreaterOrEqualValue</span></span>(<span>self, var: IntVar, value: int64) -> 'operations_research::<a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VariableGreaterOrEqualValue(self, var: &#34;IntVar&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::Decision *&#34;:
    return _pywrapcp.Solver_VariableGreaterOrEqualValue(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.VariableLessOrEqualValue"><code class="name flex">
<span>def <span class="ident">VariableLessOrEqualValue</span></span>(<span>self, var: IntVar, value: int64) -> 'operations_research::<a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a> *'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VariableLessOrEqualValue(self, var: &#34;IntVar&#34;, value: &#34;int64&#34;) -&gt; &#34;operations_research::Decision *&#34;:
    return _pywrapcp.Solver_VariableLessOrEqualValue(self, var, value)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.WallTime"><code class="name flex">
<span>def <span class="ident">WallTime</span></span>(<span>self) -> 'int64'</span>
</code></dt>
<dd>
<div class="desc"><p>DEPRECATED: Use Now() instead. Time elapsed, in ms since the creation of the solver.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WallTime(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34; DEPRECATED: Use Now() instead. Time elapsed, in ms since the creation of the solver.&#34;&#34;&#34;
    return _pywrapcp.Solver_WallTime(self)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.WeightedMaximize"><code class="name flex">
<span>def <span class="ident">WeightedMaximize</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.OptimizeVar" href="#pywrapcp.OptimizeVar">OptimizeVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Creates a maximization weigthed objective.</p>
<p>|</p>
<p><em>Overload 2:</em>
Creates a maximization weigthed objective.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WeightedMaximize(self, *args) -&gt; &#34;operations_research::OptimizeVar *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Creates a maximization weigthed objective.

    |

    *Overload 2:*
    Creates a maximization weigthed objective.
    &#34;&#34;&#34;
    return _pywrapcp.Solver_WeightedMaximize(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.WeightedMinimize"><code class="name flex">
<span>def <span class="ident">WeightedMinimize</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.OptimizeVar" href="#pywrapcp.OptimizeVar">OptimizeVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Creates a minimization weighted objective. The actual objective is scalar_prod(sub_objectives, weights).</p>
<p>|</p>
<p><em>Overload 2:</em>
Creates a minimization weighted objective. The actual objective is scalar_prod(sub_objectives, weights).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WeightedMinimize(self, *args) -&gt; &#34;operations_research::OptimizeVar *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Creates a minimization weighted objective. The actual objective is scalar_prod(sub_objectives, weights).

    |

    *Overload 2:*
    Creates a minimization weighted objective. The actual objective is scalar_prod(sub_objectives, weights).
    &#34;&#34;&#34;
    return _pywrapcp.Solver_WeightedMinimize(self, *args)</code></pre>
</details>
</dd>
<dt id="pywrapcp.Solver.WeightedOptimize"><code class="name flex">
<span>def <span class="ident">WeightedOptimize</span></span>(<span>self, *args) -> 'operations_research::<a title="pywrapcp.OptimizeVar" href="#pywrapcp.OptimizeVar">OptimizeVar</a> *'</span>
</code></dt>
<dd>
<div class="desc"><p><em>Overload 1:</em>
Creates a weighted objective with a given sense (true = maximization).</p>
<p>|</p>
<p><em>Overload 2:</em>
Creates a weighted objective with a given sense (true = maximization).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WeightedOptimize(self, *args) -&gt; &#34;operations_research::OptimizeVar *&#34;:
    r&#34;&#34;&#34;
    *Overload 1:*
    Creates a weighted objective with a given sense (true = maximization).

    |

    *Overload 2:*
    Creates a weighted objective with a given sense (true = maximization).
    &#34;&#34;&#34;
    return _pywrapcp.Solver_WeightedOptimize(self, *args)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywrapcp.TypeIncompatibilityChecker"><code class="flex name class">
<span>class <span class="ident">TypeIncompatibilityChecker</span></span>
<span>(</span><span>model: RoutingModel, check_hard_incompatibilities: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Checker for type incompatibilities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeIncompatibilityChecker(TypeRegulationsChecker):
    r&#34;&#34;&#34; Checker for type incompatibilities.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, model: &#34;RoutingModel&#34;, check_hard_incompatibilities: &#34;bool&#34;):
        _pywrapcp.TypeIncompatibilityChecker_swiginit(self, _pywrapcp.new_TypeIncompatibilityChecker(model, check_hard_incompatibilities))
    __swig_destroy__ = _pywrapcp.delete_TypeIncompatibilityChecker</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.TypeRegulationsChecker" href="#pywrapcp.TypeRegulationsChecker">TypeRegulationsChecker</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.TypeRegulationsChecker" href="#pywrapcp.TypeRegulationsChecker">TypeRegulationsChecker</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.TypeRegulationsChecker.thisown" href="#pywrapcp.TypeRegulationsChecker.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.TypeRegulationsChecker"><code class="flex name class">
<span>class <span class="ident">TypeRegulationsChecker</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeRegulationsChecker(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)

    def __init__(self, *args, **kwargs):
        raise AttributeError(&#34;No constructor defined - class is abstract&#34;)
    __repr__ = _swig_repr
    __swig_destroy__ = _pywrapcp.delete_TypeRegulationsChecker

    def CheckVehicle(self, vehicle: &#34;int&#34;, next_accessor: &#34;std::function&lt; int64 (int64) &gt; const &amp;&#34;) -&gt; &#34;bool&#34;:
        return _pywrapcp.TypeRegulationsChecker_CheckVehicle(self, vehicle, next_accessor)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pywrapcp.TypeIncompatibilityChecker" href="#pywrapcp.TypeIncompatibilityChecker">TypeIncompatibilityChecker</a></li>
<li><a title="pywrapcp.TypeRequirementChecker" href="#pywrapcp.TypeRequirementChecker">TypeRequirementChecker</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapcp.TypeRegulationsChecker.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<div class="desc"><p>The membership flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywrapcp.TypeRegulationsChecker.CheckVehicle"><code class="name flex">
<span>def <span class="ident">CheckVehicle</span></span>(<span>self, vehicle: int, next_accessor: std::function< int64 (int64) > const &) -> 'bool'</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CheckVehicle(self, vehicle: &#34;int&#34;, next_accessor: &#34;std::function&lt; int64 (int64) &gt; const &amp;&#34;) -&gt; &#34;bool&#34;:
    return _pywrapcp.TypeRegulationsChecker_CheckVehicle(self, vehicle, next_accessor)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pywrapcp.TypeRegulationsConstraint"><code class="flex name class">
<span>class <span class="ident">TypeRegulationsConstraint</span></span>
<span>(</span><span>model: RoutingModel)</span>
</code></dt>
<dd>
<div class="desc"><p>The following constraint ensures that incompatibilities and requirements between types are respected. It verifies both "hard" and "temporal" incompatibilities. Two nodes with hard incompatible types cannot be served by the same vehicle at all, while with a temporal incompatibility they can't be on the same route at the same time. The VisitTypePolicy of a node determines how visiting it impacts the type count on the route. For example, for - three temporally incompatible types T1 T2 and T3 - 2 pairs of nodes a1/r1 and a2/r2 of type T1 and T2 respectively, with
- a1 and a2 of VisitTypePolicy TYPE_ADDED_TO_VEHICLE
- r1 and r2 of policy ADDED_TYPE_REMOVED_FROM_VEHICLE - 3 nodes A, UV and AR of type T3, respectively with type policies
TYPE_ADDED_TO_VEHICLE, TYPE_ON_VEHICLE_UP_TO_VISIT and
TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED the configurations UV &ndash;&gt; a1 &ndash;&gt; r1 &ndash;&gt; a2 &ndash;&gt; r2,
a1 &ndash;&gt; r1 &ndash;&gt; a2 &ndash;&gt; r2 &ndash;&gt; A and a1 &ndash;&gt; r1 &ndash;&gt; AR &ndash;&gt; a2 &ndash;&gt; r2 are acceptable, whereas the configurations a1 &ndash;&gt; a2 &ndash;&gt; r1 &ndash;&gt; &hellip;, or A &ndash;&gt; a1 &ndash;&gt; r1 &ndash;&gt; &hellip;, or a1 &ndash;&gt; r1 &ndash;&gt; UV &ndash;&gt; &hellip; are not feasible. It also verifies same-vehicle and temporal type requirements. A node of type T_d with a same-vehicle requirement for type T_r needs to be served by the same vehicle as a node of type T_r. Temporal requirements, on the other hand, can take effect either when the dependent type is being added to the route or when it's removed from it, which is determined by the dependent node's VisitTypePolicy. In the above example: - If T3 is required on the same vehicle as T1, A, AR or UV must be on the
same vehicle as a1. - If T2 is required when adding T1, a2 must be visited <em>before</em> a1, and if
r2 is also visited on the route, it must be <em>after</em> a1, i.e. T2 must be on
the vehicle when a1 is visited:
&hellip; &ndash;&gt; a2 &ndash;&gt; &hellip; &ndash;&gt; a1 &ndash;&gt; &hellip; &ndash;&gt; r2 &ndash;&gt; &hellip; - If T3 is required when removing T1, T3 needs to be on the vehicle when
r1 is visited:
&hellip; &ndash;&gt; A &ndash;&gt; &hellip; &ndash;&gt; r1 &ndash;&gt; &hellip;
OR
&hellip; &ndash;&gt; r1 &ndash;&gt; &hellip; &ndash;&gt; UV &ndash;&gt; &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeRegulationsConstraint(Constraint):
    r&#34;&#34;&#34; The following constraint ensures that incompatibilities and requirements between types are respected. It verifies both &#34;hard&#34; and &#34;temporal&#34; incompatibilities. Two nodes with hard incompatible types cannot be served by the same vehicle at all, while with a temporal incompatibility they can&#39;t be on the same route at the same time. The VisitTypePolicy of a node determines how visiting it impacts the type count on the route. For example, for - three temporally incompatible types T1 T2 and T3 - 2 pairs of nodes a1/r1 and a2/r2 of type T1 and T2 respectively, with     - a1 and a2 of VisitTypePolicy TYPE_ADDED_TO_VEHICLE     - r1 and r2 of policy ADDED_TYPE_REMOVED_FROM_VEHICLE - 3 nodes A, UV and AR of type T3, respectively with type policies   TYPE_ADDED_TO_VEHICLE, TYPE_ON_VEHICLE_UP_TO_VISIT and   TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED the configurations UV --&gt; a1 --&gt; r1 --&gt; a2 --&gt; r2,   a1 --&gt; r1 --&gt; a2 --&gt; r2 --&gt; A and a1 --&gt; r1 --&gt; AR --&gt; a2 --&gt; r2 are acceptable, whereas the configurations a1 --&gt; a2 --&gt; r1 --&gt; ..., or A --&gt; a1 --&gt; r1 --&gt; ..., or a1 --&gt; r1 --&gt; UV --&gt; ... are not feasible. It also verifies same-vehicle and temporal type requirements. A node of type T_d with a same-vehicle requirement for type T_r needs to be served by the same vehicle as a node of type T_r. Temporal requirements, on the other hand, can take effect either when the dependent type is being added to the route or when it&#39;s removed from it, which is determined by the dependent node&#39;s VisitTypePolicy. In the above example: - If T3 is required on the same vehicle as T1, A, AR or UV must be on the   same vehicle as a1. - If T2 is required when adding T1, a2 must be visited *before* a1, and if   r2 is also visited on the route, it must be *after* a1, i.e. T2 must be on   the vehicle when a1 is visited:   ... --&gt; a2 --&gt; ... --&gt; a1 --&gt; ... --&gt; r2 --&gt; ... - If T3 is required when removing T1, T3 needs to be on the vehicle when   r1 is visited:   ... --&gt; A --&gt; ... --&gt; r1 --&gt; ...   OR   ... --&gt; r1 --&gt; ... --&gt; UV --&gt; ...&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, model: &#34;RoutingModel&#34;):
        _pywrapcp.TypeRegulationsConstraint_swiginit(self, _pywrapcp.new_TypeRegulationsConstraint(model))

    def Post(self) -&gt; &#34;void&#34;:
        return _pywrapcp.TypeRegulationsConstraint_Post(self)

    def InitialPropagateWrapper(self) -&gt; &#34;void&#34;:
        return _pywrapcp.TypeRegulationsConstraint_InitialPropagateWrapper(self)
    __swig_destroy__ = _pywrapcp.delete_TypeRegulationsConstraint</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a></li>
<li><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></li>
<li><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.Constraint.InitialPropagateWrapper" href="#pywrapcp.Constraint.InitialPropagateWrapper">InitialPropagateWrapper</a></code></li>
<li><code><a title="pywrapcp.Constraint.Name" href="#pywrapcp.PropagationBaseObject.Name">Name</a></code></li>
<li><code><a title="pywrapcp.Constraint.Post" href="#pywrapcp.Constraint.Post">Post</a></code></li>
<li><code><a title="pywrapcp.Constraint.Var" href="#pywrapcp.Constraint.Var">Var</a></code></li>
<li><code><a title="pywrapcp.Constraint.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pywrapcp.TypeRequirementChecker"><code class="flex name class">
<span>class <span class="ident">TypeRequirementChecker</span></span>
<span>(</span><span>model: RoutingModel)</span>
</code></dt>
<dd>
<div class="desc"><p>Checker for type requirements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeRequirementChecker(TypeRegulationsChecker):
    r&#34;&#34;&#34; Checker for type requirements.&#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr

    def __init__(self, model: &#34;RoutingModel&#34;):
        _pywrapcp.TypeRequirementChecker_swiginit(self, _pywrapcp.new_TypeRequirementChecker(model))
    __swig_destroy__ = _pywrapcp.delete_TypeRequirementChecker</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pywrapcp.TypeRegulationsChecker" href="#pywrapcp.TypeRegulationsChecker">TypeRegulationsChecker</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pywrapcp.TypeRegulationsChecker" href="#pywrapcp.TypeRegulationsChecker">TypeRegulationsChecker</a></b></code>:
<ul class="hlist">
<li><code><a title="pywrapcp.TypeRegulationsChecker.thisown" href="#pywrapcp.TypeRegulationsChecker.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="OR-Tools Home" href="https://google.github.io/or-tools/">
<img src="https://developers.google.com/optimization/images/orLogo.png" alt=""> OR-Tools
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pywrapcp.DefaultRoutingModelParameters" href="#pywrapcp.DefaultRoutingModelParameters">DefaultRoutingModelParameters</a></code></li>
<li><code><a title="pywrapcp.DefaultRoutingSearchParameters" href="#pywrapcp.DefaultRoutingSearchParameters">DefaultRoutingSearchParameters</a></code></li>
<li><code><a title="pywrapcp.FindErrorInRoutingSearchParameters" href="#pywrapcp.FindErrorInRoutingSearchParameters">FindErrorInRoutingSearchParameters</a></code></li>
<li><code><a title="pywrapcp.MakeSetValuesFromTargets" href="#pywrapcp.MakeSetValuesFromTargets">MakeSetValuesFromTargets</a></code></li>
<li><code><a title="pywrapcp.SolveModelWithSat" href="#pywrapcp.SolveModelWithSat">SolveModelWithSat</a></code></li>
<li><code><a title="pywrapcp.Solver_DefaultSolverParameters" href="#pywrapcp.Solver_DefaultSolverParameters">Solver_DefaultSolverParameters</a></code></li>
<li><code><a title="pywrapcp.Solver_MemoryUsage" href="#pywrapcp.Solver_MemoryUsage">Solver_MemoryUsage</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pywrapcp.Assignment" href="#pywrapcp.Assignment">Assignment</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.Assignment.Activate" href="#pywrapcp.Assignment.Activate">Activate</a></code></li>
<li><code><a title="pywrapcp.Assignment.Activated" href="#pywrapcp.Assignment.Activated">Activated</a></code></li>
<li><code><a title="pywrapcp.Assignment.Add" href="#pywrapcp.Assignment.Add">Add</a></code></li>
<li><code><a title="pywrapcp.Assignment.AddObjective" href="#pywrapcp.Assignment.AddObjective">AddObjective</a></code></li>
<li><code><a title="pywrapcp.Assignment.BackwardSequence" href="#pywrapcp.Assignment.BackwardSequence">BackwardSequence</a></code></li>
<li><code><a title="pywrapcp.Assignment.Bound" href="#pywrapcp.Assignment.Bound">Bound</a></code></li>
<li><code><a title="pywrapcp.Assignment.Clear" href="#pywrapcp.Assignment.Clear">Clear</a></code></li>
<li><code><a title="pywrapcp.Assignment.Deactivate" href="#pywrapcp.Assignment.Deactivate">Deactivate</a></code></li>
<li><code><a title="pywrapcp.Assignment.DebugString" href="#pywrapcp.Assignment.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.Assignment.DurationMax" href="#pywrapcp.Assignment.DurationMax">DurationMax</a></code></li>
<li><code><a title="pywrapcp.Assignment.DurationMin" href="#pywrapcp.Assignment.DurationMin">DurationMin</a></code></li>
<li><code><a title="pywrapcp.Assignment.DurationValue" href="#pywrapcp.Assignment.DurationValue">DurationValue</a></code></li>
<li><code><a title="pywrapcp.Assignment.Empty" href="#pywrapcp.Assignment.Empty">Empty</a></code></li>
<li><code><a title="pywrapcp.Assignment.EndMax" href="#pywrapcp.Assignment.EndMax">EndMax</a></code></li>
<li><code><a title="pywrapcp.Assignment.EndMin" href="#pywrapcp.Assignment.EndMin">EndMin</a></code></li>
<li><code><a title="pywrapcp.Assignment.EndValue" href="#pywrapcp.Assignment.EndValue">EndValue</a></code></li>
<li><code><a title="pywrapcp.Assignment.ForwardSequence" href="#pywrapcp.Assignment.ForwardSequence">ForwardSequence</a></code></li>
<li><code><a title="pywrapcp.Assignment.HasObjective" href="#pywrapcp.Assignment.HasObjective">HasObjective</a></code></li>
<li><code><a title="pywrapcp.Assignment.IntVarContainer" href="#pywrapcp.Assignment.IntVarContainer">IntVarContainer</a></code></li>
<li><code><a title="pywrapcp.Assignment.IntervalVarContainer" href="#pywrapcp.Assignment.IntervalVarContainer">IntervalVarContainer</a></code></li>
<li><code><a title="pywrapcp.Assignment.Load" href="#pywrapcp.Assignment.Load">Load</a></code></li>
<li><code><a title="pywrapcp.Assignment.Max" href="#pywrapcp.Assignment.Max">Max</a></code></li>
<li><code><a title="pywrapcp.Assignment.Min" href="#pywrapcp.Assignment.Min">Min</a></code></li>
<li><code><a title="pywrapcp.Assignment.MutableIntVarContainer" href="#pywrapcp.Assignment.MutableIntVarContainer">MutableIntVarContainer</a></code></li>
<li><code><a title="pywrapcp.Assignment.MutableIntervalVarContainer" href="#pywrapcp.Assignment.MutableIntervalVarContainer">MutableIntervalVarContainer</a></code></li>
<li><code><a title="pywrapcp.Assignment.MutableSequenceVarContainer" href="#pywrapcp.Assignment.MutableSequenceVarContainer">MutableSequenceVarContainer</a></code></li>
<li><code><a title="pywrapcp.Assignment.NumIntVars" href="#pywrapcp.Assignment.NumIntVars">NumIntVars</a></code></li>
<li><code><a title="pywrapcp.Assignment.NumIntervalVars" href="#pywrapcp.Assignment.NumIntervalVars">NumIntervalVars</a></code></li>
<li><code><a title="pywrapcp.Assignment.NumSequenceVars" href="#pywrapcp.Assignment.NumSequenceVars">NumSequenceVars</a></code></li>
<li><code><a title="pywrapcp.Assignment.Objective" href="#pywrapcp.Assignment.Objective">Objective</a></code></li>
<li><code><a title="pywrapcp.Assignment.ObjectiveBound" href="#pywrapcp.Assignment.ObjectiveBound">ObjectiveBound</a></code></li>
<li><code><a title="pywrapcp.Assignment.ObjectiveMax" href="#pywrapcp.Assignment.ObjectiveMax">ObjectiveMax</a></code></li>
<li><code><a title="pywrapcp.Assignment.ObjectiveMin" href="#pywrapcp.Assignment.ObjectiveMin">ObjectiveMin</a></code></li>
<li><code><a title="pywrapcp.Assignment.ObjectiveValue" href="#pywrapcp.Assignment.ObjectiveValue">ObjectiveValue</a></code></li>
<li><code><a title="pywrapcp.Assignment.PerformedMax" href="#pywrapcp.Assignment.PerformedMax">PerformedMax</a></code></li>
<li><code><a title="pywrapcp.Assignment.PerformedMin" href="#pywrapcp.Assignment.PerformedMin">PerformedMin</a></code></li>
<li><code><a title="pywrapcp.Assignment.PerformedValue" href="#pywrapcp.Assignment.PerformedValue">PerformedValue</a></code></li>
<li><code><a title="pywrapcp.Assignment.Restore" href="#pywrapcp.Assignment.Restore">Restore</a></code></li>
<li><code><a title="pywrapcp.Assignment.Save" href="#pywrapcp.Assignment.Save">Save</a></code></li>
<li><code><a title="pywrapcp.Assignment.SequenceVarContainer" href="#pywrapcp.Assignment.SequenceVarContainer">SequenceVarContainer</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetBackwardSequence" href="#pywrapcp.Assignment.SetBackwardSequence">SetBackwardSequence</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetDurationMax" href="#pywrapcp.Assignment.SetDurationMax">SetDurationMax</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetDurationMin" href="#pywrapcp.Assignment.SetDurationMin">SetDurationMin</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetDurationRange" href="#pywrapcp.Assignment.SetDurationRange">SetDurationRange</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetDurationValue" href="#pywrapcp.Assignment.SetDurationValue">SetDurationValue</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetEndMax" href="#pywrapcp.Assignment.SetEndMax">SetEndMax</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetEndMin" href="#pywrapcp.Assignment.SetEndMin">SetEndMin</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetEndRange" href="#pywrapcp.Assignment.SetEndRange">SetEndRange</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetEndValue" href="#pywrapcp.Assignment.SetEndValue">SetEndValue</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetForwardSequence" href="#pywrapcp.Assignment.SetForwardSequence">SetForwardSequence</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetMax" href="#pywrapcp.Assignment.SetMax">SetMax</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetMin" href="#pywrapcp.Assignment.SetMin">SetMin</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetObjectiveMax" href="#pywrapcp.Assignment.SetObjectiveMax">SetObjectiveMax</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetObjectiveMin" href="#pywrapcp.Assignment.SetObjectiveMin">SetObjectiveMin</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetObjectiveRange" href="#pywrapcp.Assignment.SetObjectiveRange">SetObjectiveRange</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetObjectiveValue" href="#pywrapcp.Assignment.SetObjectiveValue">SetObjectiveValue</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetPerformedMax" href="#pywrapcp.Assignment.SetPerformedMax">SetPerformedMax</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetPerformedMin" href="#pywrapcp.Assignment.SetPerformedMin">SetPerformedMin</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetPerformedRange" href="#pywrapcp.Assignment.SetPerformedRange">SetPerformedRange</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetPerformedValue" href="#pywrapcp.Assignment.SetPerformedValue">SetPerformedValue</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetRange" href="#pywrapcp.Assignment.SetRange">SetRange</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetSequence" href="#pywrapcp.Assignment.SetSequence">SetSequence</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetStartMax" href="#pywrapcp.Assignment.SetStartMax">SetStartMax</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetStartMin" href="#pywrapcp.Assignment.SetStartMin">SetStartMin</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetStartRange" href="#pywrapcp.Assignment.SetStartRange">SetStartRange</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetStartValue" href="#pywrapcp.Assignment.SetStartValue">SetStartValue</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetUnperformed" href="#pywrapcp.Assignment.SetUnperformed">SetUnperformed</a></code></li>
<li><code><a title="pywrapcp.Assignment.SetValue" href="#pywrapcp.Assignment.SetValue">SetValue</a></code></li>
<li><code><a title="pywrapcp.Assignment.Size" href="#pywrapcp.Assignment.Size">Size</a></code></li>
<li><code><a title="pywrapcp.Assignment.StartMax" href="#pywrapcp.Assignment.StartMax">StartMax</a></code></li>
<li><code><a title="pywrapcp.Assignment.StartMin" href="#pywrapcp.Assignment.StartMin">StartMin</a></code></li>
<li><code><a title="pywrapcp.Assignment.StartValue" href="#pywrapcp.Assignment.StartValue">StartValue</a></code></li>
<li><code><a title="pywrapcp.Assignment.Store" href="#pywrapcp.Assignment.Store">Store</a></code></li>
<li><code><a title="pywrapcp.Assignment.Unperformed" href="#pywrapcp.Assignment.Unperformed">Unperformed</a></code></li>
<li><code><a title="pywrapcp.Assignment.Value" href="#pywrapcp.Assignment.Value">Value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.AssignmentElement" href="#pywrapcp.AssignmentElement">AssignmentElement</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.AssignmentElement.Activate" href="#pywrapcp.AssignmentElement.Activate">Activate</a></code></li>
<li><code><a title="pywrapcp.AssignmentElement.Activated" href="#pywrapcp.AssignmentElement.Activated">Activated</a></code></li>
<li><code><a title="pywrapcp.AssignmentElement.Deactivate" href="#pywrapcp.AssignmentElement.Deactivate">Deactivate</a></code></li>
<li><code><a title="pywrapcp.AssignmentElement.thisown" href="#pywrapcp.AssignmentElement.thisown">thisown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.BaseLns" href="#pywrapcp.BaseLns">BaseLns</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.BaseLns.AppendToFragment" href="#pywrapcp.BaseLns.AppendToFragment">AppendToFragment</a></code></li>
<li><code><a title="pywrapcp.BaseLns.FragmentSize" href="#pywrapcp.BaseLns.FragmentSize">FragmentSize</a></code></li>
<li><code><a title="pywrapcp.BaseLns.InitFragments" href="#pywrapcp.BaseLns.InitFragments">InitFragments</a></code></li>
<li><code><a title="pywrapcp.BaseLns.NextFragment" href="#pywrapcp.BaseLns.NextFragment">NextFragment</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.BaseObject" href="#pywrapcp.BaseObject">BaseObject</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.BaseObject.DebugString" href="#pywrapcp.BaseObject.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.BaseObject.thisown" href="#pywrapcp.BaseObject.thisown">thisown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.BasePathFilter" href="#pywrapcp.BasePathFilter">BasePathFilter</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.BasePathFilter.OnSynchronize" href="#pywrapcp.BasePathFilter.OnSynchronize">OnSynchronize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.BooleanVar" href="#pywrapcp.BooleanVar">BooleanVar</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.BooleanVar.DebugString" href="#pywrapcp.BooleanVar.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.BooleanVar.Max" href="#pywrapcp.BooleanVar.Max">Max</a></code></li>
<li><code><a title="pywrapcp.BooleanVar.Min" href="#pywrapcp.BooleanVar.Min">Min</a></code></li>
<li><code><a title="pywrapcp.BooleanVar.SetMax" href="#pywrapcp.BooleanVar.SetMax">SetMax</a></code></li>
<li><code><a title="pywrapcp.BooleanVar.SetMin" href="#pywrapcp.BooleanVar.SetMin">SetMin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.CPFeasibilityFilter" href="#pywrapcp.CPFeasibilityFilter">CPFeasibilityFilter</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.CPFeasibilityFilter.DebugString" href="#pywrapcp.CPFeasibilityFilter.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.CPFeasibilityFilter.OnSynchronize" href="#pywrapcp.CPFeasibilityFilter.OnSynchronize">OnSynchronize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.ChangeValue" href="#pywrapcp.ChangeValue">ChangeValue</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.ChangeValue.ModifyValue" href="#pywrapcp.ChangeValue.ModifyValue">ModifyValue</a></code></li>
<li><code><a title="pywrapcp.ChangeValue.OneNeighbor" href="#pywrapcp.ChangeValue.OneNeighbor">OneNeighbor</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.Constraint" href="#pywrapcp.Constraint">Constraint</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.Constraint.DebugString" href="#pywrapcp.Constraint.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.Constraint.IndexOf" href="#pywrapcp.Constraint.IndexOf">IndexOf</a></code></li>
<li><code><a title="pywrapcp.Constraint.InitialPropagateWrapper" href="#pywrapcp.Constraint.InitialPropagateWrapper">InitialPropagateWrapper</a></code></li>
<li><code><a title="pywrapcp.Constraint.MapTo" href="#pywrapcp.Constraint.MapTo">MapTo</a></code></li>
<li><code><a title="pywrapcp.Constraint.Post" href="#pywrapcp.Constraint.Post">Post</a></code></li>
<li><code><a title="pywrapcp.Constraint.Square" href="#pywrapcp.Constraint.Square">Square</a></code></li>
<li><code><a title="pywrapcp.Constraint.Var" href="#pywrapcp.Constraint.Var">Var</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.Decision" href="#pywrapcp.Decision">Decision</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.Decision.ApplyWrapper" href="#pywrapcp.Decision.ApplyWrapper">ApplyWrapper</a></code></li>
<li><code><a title="pywrapcp.Decision.DebugString" href="#pywrapcp.Decision.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.Decision.RefuteWrapper" href="#pywrapcp.Decision.RefuteWrapper">RefuteWrapper</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.DecisionBuilder" href="#pywrapcp.DecisionBuilder">DecisionBuilder</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.DecisionBuilder.DebugString" href="#pywrapcp.DecisionBuilder.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.DecisionBuilder.NextWrapper" href="#pywrapcp.DecisionBuilder.NextWrapper">NextWrapper</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.DefaultPhaseParameters" href="#pywrapcp.DefaultPhaseParameters">DefaultPhaseParameters</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.DefaultPhaseParameters.CHOOSE_MAX_AVERAGE_IMPACT" href="#pywrapcp.DefaultPhaseParameters.CHOOSE_MAX_AVERAGE_IMPACT">CHOOSE_MAX_AVERAGE_IMPACT</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.CHOOSE_MAX_SUM_IMPACT" href="#pywrapcp.DefaultPhaseParameters.CHOOSE_MAX_SUM_IMPACT">CHOOSE_MAX_SUM_IMPACT</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.CHOOSE_MAX_VALUE_IMPACT" href="#pywrapcp.DefaultPhaseParameters.CHOOSE_MAX_VALUE_IMPACT">CHOOSE_MAX_VALUE_IMPACT</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.NONE" href="#pywrapcp.DefaultPhaseParameters.NONE">NONE</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.NORMAL" href="#pywrapcp.DefaultPhaseParameters.NORMAL">NORMAL</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.SELECT_MAX_IMPACT" href="#pywrapcp.DefaultPhaseParameters.SELECT_MAX_IMPACT">SELECT_MAX_IMPACT</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.SELECT_MIN_IMPACT" href="#pywrapcp.DefaultPhaseParameters.SELECT_MIN_IMPACT">SELECT_MIN_IMPACT</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.VERBOSE" href="#pywrapcp.DefaultPhaseParameters.VERBOSE">VERBOSE</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.decision_builder" href="#pywrapcp.DefaultPhaseParameters.decision_builder">decision_builder</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.display_level" href="#pywrapcp.DefaultPhaseParameters.display_level">display_level</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.heuristic_num_failures_limit" href="#pywrapcp.DefaultPhaseParameters.heuristic_num_failures_limit">heuristic_num_failures_limit</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.heuristic_period" href="#pywrapcp.DefaultPhaseParameters.heuristic_period">heuristic_period</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.initialization_splits" href="#pywrapcp.DefaultPhaseParameters.initialization_splits">initialization_splits</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.persistent_impact" href="#pywrapcp.DefaultPhaseParameters.persistent_impact">persistent_impact</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.random_seed" href="#pywrapcp.DefaultPhaseParameters.random_seed">random_seed</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.run_all_heuristics" href="#pywrapcp.DefaultPhaseParameters.run_all_heuristics">run_all_heuristics</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.thisown" href="#pywrapcp.DefaultPhaseParameters.thisown">thisown</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.value_selection_schema" href="#pywrapcp.DefaultPhaseParameters.value_selection_schema">value_selection_schema</a></code></li>
<li><code><a title="pywrapcp.DefaultPhaseParameters.var_selection_schema" href="#pywrapcp.DefaultPhaseParameters.var_selection_schema">var_selection_schema</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.Demon" href="#pywrapcp.Demon">Demon</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.Demon.DebugString" href="#pywrapcp.Demon.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.Demon.Desinhibit" href="#pywrapcp.Demon.Desinhibit">Desinhibit</a></code></li>
<li><code><a title="pywrapcp.Demon.Inhibit" href="#pywrapcp.Demon.Inhibit">Inhibit</a></code></li>
<li><code><a title="pywrapcp.Demon.Priority" href="#pywrapcp.Demon.Priority">Priority</a></code></li>
<li><code><a title="pywrapcp.Demon.RunWrapper" href="#pywrapcp.Demon.RunWrapper">RunWrapper</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.DisjunctiveConstraint" href="#pywrapcp.DisjunctiveConstraint">DisjunctiveConstraint</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.DisjunctiveConstraint.SequenceVar" href="#pywrapcp.DisjunctiveConstraint.SequenceVar">SequenceVar</a></code></li>
<li><code><a title="pywrapcp.DisjunctiveConstraint.SetTransitionTime" href="#pywrapcp.DisjunctiveConstraint.SetTransitionTime">SetTransitionTime</a></code></li>
<li><code><a title="pywrapcp.DisjunctiveConstraint.TransitionTime" href="#pywrapcp.DisjunctiveConstraint.TransitionTime">TransitionTime</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.GlobalVehicleBreaksConstraint" href="#pywrapcp.GlobalVehicleBreaksConstraint">GlobalVehicleBreaksConstraint</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.GlobalVehicleBreaksConstraint.DebugString" href="#pywrapcp.GlobalVehicleBreaksConstraint.DebugString">DebugString</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.IntExpr" href="#pywrapcp.IntExpr">IntExpr</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.IntExpr.Bound" href="#pywrapcp.IntExpr.Bound">Bound</a></code></li>
<li><code><a title="pywrapcp.IntExpr.IndexOf" href="#pywrapcp.IntExpr.IndexOf">IndexOf</a></code></li>
<li><code><a title="pywrapcp.IntExpr.IsMember" href="#pywrapcp.IntExpr.IsMember">IsMember</a></code></li>
<li><code><a title="pywrapcp.IntExpr.IsVar" href="#pywrapcp.IntExpr.IsVar">IsVar</a></code></li>
<li><code><a title="pywrapcp.IntExpr.MapTo" href="#pywrapcp.IntExpr.MapTo">MapTo</a></code></li>
<li><code><a title="pywrapcp.IntExpr.Max" href="#pywrapcp.IntExpr.Max">Max</a></code></li>
<li><code><a title="pywrapcp.IntExpr.Member" href="#pywrapcp.IntExpr.Member">Member</a></code></li>
<li><code><a title="pywrapcp.IntExpr.Min" href="#pywrapcp.IntExpr.Min">Min</a></code></li>
<li><code><a title="pywrapcp.IntExpr.NotMember" href="#pywrapcp.IntExpr.NotMember">NotMember</a></code></li>
<li><code><a title="pywrapcp.IntExpr.SetMax" href="#pywrapcp.IntExpr.SetMax">SetMax</a></code></li>
<li><code><a title="pywrapcp.IntExpr.SetMin" href="#pywrapcp.IntExpr.SetMin">SetMin</a></code></li>
<li><code><a title="pywrapcp.IntExpr.SetRange" href="#pywrapcp.IntExpr.SetRange">SetRange</a></code></li>
<li><code><a title="pywrapcp.IntExpr.SetValue" href="#pywrapcp.IntExpr.SetValue">SetValue</a></code></li>
<li><code><a title="pywrapcp.IntExpr.Square" href="#pywrapcp.IntExpr.Square">Square</a></code></li>
<li><code><a title="pywrapcp.IntExpr.Var" href="#pywrapcp.IntExpr.Var">Var</a></code></li>
<li><code><a title="pywrapcp.IntExpr.VarWithName" href="#pywrapcp.IntExpr.VarWithName">VarWithName</a></code></li>
<li><code><a title="pywrapcp.IntExpr.WhenRange" href="#pywrapcp.IntExpr.WhenRange">WhenRange</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.IntVar" href="#pywrapcp.IntVar">IntVar</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.IntVar.Contains" href="#pywrapcp.IntVar.Contains">Contains</a></code></li>
<li><code><a title="pywrapcp.IntVar.DomainIterator" href="#pywrapcp.IntVar.DomainIterator">DomainIterator</a></code></li>
<li><code><a title="pywrapcp.IntVar.DomainIteratorAux" href="#pywrapcp.IntVar.DomainIteratorAux">DomainIteratorAux</a></code></li>
<li><code><a title="pywrapcp.IntVar.HoleIterator" href="#pywrapcp.IntVar.HoleIterator">HoleIterator</a></code></li>
<li><code><a title="pywrapcp.IntVar.HoleIteratorAux" href="#pywrapcp.IntVar.HoleIteratorAux">HoleIteratorAux</a></code></li>
<li><code><a title="pywrapcp.IntVar.OldMax" href="#pywrapcp.IntVar.OldMax">OldMax</a></code></li>
<li><code><a title="pywrapcp.IntVar.OldMin" href="#pywrapcp.IntVar.OldMin">OldMin</a></code></li>
<li><code><a title="pywrapcp.IntVar.RemoveInterval" href="#pywrapcp.IntVar.RemoveInterval">RemoveInterval</a></code></li>
<li><code><a title="pywrapcp.IntVar.RemoveValue" href="#pywrapcp.IntVar.RemoveValue">RemoveValue</a></code></li>
<li><code><a title="pywrapcp.IntVar.RemoveValues" href="#pywrapcp.IntVar.RemoveValues">RemoveValues</a></code></li>
<li><code><a title="pywrapcp.IntVar.SetValues" href="#pywrapcp.IntVar.SetValues">SetValues</a></code></li>
<li><code><a title="pywrapcp.IntVar.Size" href="#pywrapcp.IntVar.Size">Size</a></code></li>
<li><code><a title="pywrapcp.IntVar.Value" href="#pywrapcp.IntVar.Value">Value</a></code></li>
<li><code><a title="pywrapcp.IntVar.WhenBound" href="#pywrapcp.IntVar.WhenBound">WhenBound</a></code></li>
<li><code><a title="pywrapcp.IntVar.WhenDomain" href="#pywrapcp.IntVar.WhenDomain">WhenDomain</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.IntVarContainer" href="#pywrapcp.IntVarContainer">IntVarContainer</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.IntVarContainer.Contains" href="#pywrapcp.IntVarContainer.Contains">Contains</a></code></li>
<li><code><a title="pywrapcp.IntVarContainer.Element" href="#pywrapcp.IntVarContainer.Element">Element</a></code></li>
<li><code><a title="pywrapcp.IntVarContainer.Restore" href="#pywrapcp.IntVarContainer.Restore">Restore</a></code></li>
<li><code><a title="pywrapcp.IntVarContainer.Size" href="#pywrapcp.IntVarContainer.Size">Size</a></code></li>
<li><code><a title="pywrapcp.IntVarContainer.Store" href="#pywrapcp.IntVarContainer.Store">Store</a></code></li>
<li><code><a title="pywrapcp.IntVarContainer.thisown" href="#pywrapcp.IntVarContainer.thisown">thisown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.IntVarElement" href="#pywrapcp.IntVarElement">IntVarElement</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.IntVarElement.Bound" href="#pywrapcp.IntVarElement.Bound">Bound</a></code></li>
<li><code><a title="pywrapcp.IntVarElement.Max" href="#pywrapcp.IntVarElement.Max">Max</a></code></li>
<li><code><a title="pywrapcp.IntVarElement.Min" href="#pywrapcp.IntVarElement.Min">Min</a></code></li>
<li><code><a title="pywrapcp.IntVarElement.SetMax" href="#pywrapcp.IntVarElement.SetMax">SetMax</a></code></li>
<li><code><a title="pywrapcp.IntVarElement.SetMin" href="#pywrapcp.IntVarElement.SetMin">SetMin</a></code></li>
<li><code><a title="pywrapcp.IntVarElement.SetRange" href="#pywrapcp.IntVarElement.SetRange">SetRange</a></code></li>
<li><code><a title="pywrapcp.IntVarElement.SetValue" href="#pywrapcp.IntVarElement.SetValue">SetValue</a></code></li>
<li><code><a title="pywrapcp.IntVarElement.Value" href="#pywrapcp.IntVarElement.Value">Value</a></code></li>
<li><code><a title="pywrapcp.IntVarElement.Var" href="#pywrapcp.IntVarElement.Var">Var</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.IntVarIterator" href="#pywrapcp.IntVarIterator">IntVarIterator</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.IntVarIterator.DebugString" href="#pywrapcp.IntVarIterator.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.IntVarIterator.Init" href="#pywrapcp.IntVarIterator.Init">Init</a></code></li>
<li><code><a title="pywrapcp.IntVarIterator.Next" href="#pywrapcp.IntVarIterator.Next">Next</a></code></li>
<li><code><a title="pywrapcp.IntVarIterator.Ok" href="#pywrapcp.IntVarIterator.Ok">Ok</a></code></li>
<li><code><a title="pywrapcp.IntVarIterator.Value" href="#pywrapcp.IntVarIterator.Value">Value</a></code></li>
<li><code><a title="pywrapcp.IntVarIterator.next" href="#pywrapcp.IntVarIterator.next">next</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.IntVarLocalSearchFilter" href="#pywrapcp.IntVarLocalSearchFilter">IntVarLocalSearchFilter</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.IntVarLocalSearchFilter.IndexFromVar" href="#pywrapcp.IntVarLocalSearchFilter.IndexFromVar">IndexFromVar</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchFilter.Size" href="#pywrapcp.IntVarLocalSearchFilter.Size">Size</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchFilter.Synchronize" href="#pywrapcp.IntVarLocalSearchFilter.Synchronize">Synchronize</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchFilter.Value" href="#pywrapcp.IntVarLocalSearchFilter.Value">Value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.IntVarLocalSearchOperator" href="#pywrapcp.IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.NextNeighbor" href="#pywrapcp.IntVarLocalSearchOperator.NextNeighbor">NextNeighbor</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperator.OneNeighbor" href="#pywrapcp.IntVarLocalSearchOperator.OneNeighbor">OneNeighbor</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.IntVarLocalSearchOperatorTemplate" href="#pywrapcp.IntVarLocalSearchOperatorTemplate">IntVarLocalSearchOperatorTemplate</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.IntVarLocalSearchOperatorTemplate.IsIncremental" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.IsIncremental">IsIncremental</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperatorTemplate.OldValue" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.OldValue">OldValue</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperatorTemplate.OnStart" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.OnStart">OnStart</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperatorTemplate.SetValue" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.SetValue">SetValue</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperatorTemplate.Size" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.Size">Size</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperatorTemplate.Start" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.Start">Start</a></code></li>
<li><code><a title="pywrapcp.IntVarLocalSearchOperatorTemplate.Value" href="#pywrapcp.IntVarLocalSearchOperatorTemplate.Value">Value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.IntervalVar" href="#pywrapcp.IntervalVar">IntervalVar</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.IntervalVar.AvoidsDate" href="#pywrapcp.IntervalVar.AvoidsDate">AvoidsDate</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.CannotBePerformed" href="#pywrapcp.IntervalVar.CannotBePerformed">CannotBePerformed</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.CrossesDate" href="#pywrapcp.IntervalVar.CrossesDate">CrossesDate</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.DurationExpr" href="#pywrapcp.IntervalVar.DurationExpr">DurationExpr</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.DurationMax" href="#pywrapcp.IntervalVar.DurationMax">DurationMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.DurationMin" href="#pywrapcp.IntervalVar.DurationMin">DurationMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndExpr" href="#pywrapcp.IntervalVar.EndExpr">EndExpr</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndMax" href="#pywrapcp.IntervalVar.EndMax">EndMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndMin" href="#pywrapcp.IntervalVar.EndMin">EndMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndsAfter" href="#pywrapcp.IntervalVar.EndsAfter">EndsAfter</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndsAfterEnd" href="#pywrapcp.IntervalVar.EndsAfterEnd">EndsAfterEnd</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndsAfterEndWithDelay" href="#pywrapcp.IntervalVar.EndsAfterEndWithDelay">EndsAfterEndWithDelay</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndsAfterStart" href="#pywrapcp.IntervalVar.EndsAfterStart">EndsAfterStart</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndsAfterStartWithDelay" href="#pywrapcp.IntervalVar.EndsAfterStartWithDelay">EndsAfterStartWithDelay</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndsAt" href="#pywrapcp.IntervalVar.EndsAt">EndsAt</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndsAtEnd" href="#pywrapcp.IntervalVar.EndsAtEnd">EndsAtEnd</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndsAtEndWithDelay" href="#pywrapcp.IntervalVar.EndsAtEndWithDelay">EndsAtEndWithDelay</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndsAtStart" href="#pywrapcp.IntervalVar.EndsAtStart">EndsAtStart</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndsAtStartWithDelay" href="#pywrapcp.IntervalVar.EndsAtStartWithDelay">EndsAtStartWithDelay</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.EndsBefore" href="#pywrapcp.IntervalVar.EndsBefore">EndsBefore</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.IsPerformedBound" href="#pywrapcp.IntervalVar.IsPerformedBound">IsPerformedBound</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.MayBePerformed" href="#pywrapcp.IntervalVar.MayBePerformed">MayBePerformed</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.MustBePerformed" href="#pywrapcp.IntervalVar.MustBePerformed">MustBePerformed</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.OldDurationMax" href="#pywrapcp.IntervalVar.OldDurationMax">OldDurationMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.OldDurationMin" href="#pywrapcp.IntervalVar.OldDurationMin">OldDurationMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.OldEndMax" href="#pywrapcp.IntervalVar.OldEndMax">OldEndMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.OldEndMin" href="#pywrapcp.IntervalVar.OldEndMin">OldEndMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.OldStartMax" href="#pywrapcp.IntervalVar.OldStartMax">OldStartMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.OldStartMin" href="#pywrapcp.IntervalVar.OldStartMin">OldStartMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.PerformedExpr" href="#pywrapcp.IntervalVar.PerformedExpr">PerformedExpr</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.SafeDurationExpr" href="#pywrapcp.IntervalVar.SafeDurationExpr">SafeDurationExpr</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.SafeEndExpr" href="#pywrapcp.IntervalVar.SafeEndExpr">SafeEndExpr</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.SafeStartExpr" href="#pywrapcp.IntervalVar.SafeStartExpr">SafeStartExpr</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.SetDurationMax" href="#pywrapcp.IntervalVar.SetDurationMax">SetDurationMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.SetDurationMin" href="#pywrapcp.IntervalVar.SetDurationMin">SetDurationMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.SetDurationRange" href="#pywrapcp.IntervalVar.SetDurationRange">SetDurationRange</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.SetEndMax" href="#pywrapcp.IntervalVar.SetEndMax">SetEndMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.SetEndMin" href="#pywrapcp.IntervalVar.SetEndMin">SetEndMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.SetEndRange" href="#pywrapcp.IntervalVar.SetEndRange">SetEndRange</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.SetPerformed" href="#pywrapcp.IntervalVar.SetPerformed">SetPerformed</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.SetStartMax" href="#pywrapcp.IntervalVar.SetStartMax">SetStartMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.SetStartMin" href="#pywrapcp.IntervalVar.SetStartMin">SetStartMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.SetStartRange" href="#pywrapcp.IntervalVar.SetStartRange">SetStartRange</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartExpr" href="#pywrapcp.IntervalVar.StartExpr">StartExpr</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartMax" href="#pywrapcp.IntervalVar.StartMax">StartMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartMin" href="#pywrapcp.IntervalVar.StartMin">StartMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartsAfter" href="#pywrapcp.IntervalVar.StartsAfter">StartsAfter</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartsAfterEnd" href="#pywrapcp.IntervalVar.StartsAfterEnd">StartsAfterEnd</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartsAfterEndWithDelay" href="#pywrapcp.IntervalVar.StartsAfterEndWithDelay">StartsAfterEndWithDelay</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartsAfterStart" href="#pywrapcp.IntervalVar.StartsAfterStart">StartsAfterStart</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartsAfterStartWithDelay" href="#pywrapcp.IntervalVar.StartsAfterStartWithDelay">StartsAfterStartWithDelay</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartsAt" href="#pywrapcp.IntervalVar.StartsAt">StartsAt</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartsAtEnd" href="#pywrapcp.IntervalVar.StartsAtEnd">StartsAtEnd</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartsAtEndWithDelay" href="#pywrapcp.IntervalVar.StartsAtEndWithDelay">StartsAtEndWithDelay</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartsAtStart" href="#pywrapcp.IntervalVar.StartsAtStart">StartsAtStart</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartsAtStartWithDelay" href="#pywrapcp.IntervalVar.StartsAtStartWithDelay">StartsAtStartWithDelay</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StartsBefore" href="#pywrapcp.IntervalVar.StartsBefore">StartsBefore</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StaysInSync" href="#pywrapcp.IntervalVar.StaysInSync">StaysInSync</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.StaysInSyncWithDelay" href="#pywrapcp.IntervalVar.StaysInSyncWithDelay">StaysInSyncWithDelay</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.WasPerformedBound" href="#pywrapcp.IntervalVar.WasPerformedBound">WasPerformedBound</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.WhenAnything" href="#pywrapcp.IntervalVar.WhenAnything">WhenAnything</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.WhenDurationBound" href="#pywrapcp.IntervalVar.WhenDurationBound">WhenDurationBound</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.WhenDurationRange" href="#pywrapcp.IntervalVar.WhenDurationRange">WhenDurationRange</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.WhenEndBound" href="#pywrapcp.IntervalVar.WhenEndBound">WhenEndBound</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.WhenEndRange" href="#pywrapcp.IntervalVar.WhenEndRange">WhenEndRange</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.WhenPerformedBound" href="#pywrapcp.IntervalVar.WhenPerformedBound">WhenPerformedBound</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.WhenStartBound" href="#pywrapcp.IntervalVar.WhenStartBound">WhenStartBound</a></code></li>
<li><code><a title="pywrapcp.IntervalVar.WhenStartRange" href="#pywrapcp.IntervalVar.WhenStartRange">WhenStartRange</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.IntervalVarContainer" href="#pywrapcp.IntervalVarContainer">IntervalVarContainer</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.IntervalVarContainer.Contains" href="#pywrapcp.IntervalVarContainer.Contains">Contains</a></code></li>
<li><code><a title="pywrapcp.IntervalVarContainer.Element" href="#pywrapcp.IntervalVarContainer.Element">Element</a></code></li>
<li><code><a title="pywrapcp.IntervalVarContainer.Restore" href="#pywrapcp.IntervalVarContainer.Restore">Restore</a></code></li>
<li><code><a title="pywrapcp.IntervalVarContainer.Size" href="#pywrapcp.IntervalVarContainer.Size">Size</a></code></li>
<li><code><a title="pywrapcp.IntervalVarContainer.Store" href="#pywrapcp.IntervalVarContainer.Store">Store</a></code></li>
<li><code><a title="pywrapcp.IntervalVarContainer.thisown" href="#pywrapcp.IntervalVarContainer.thisown">thisown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.IntervalVarElement" href="#pywrapcp.IntervalVarElement">IntervalVarElement</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.IntervalVarElement.DurationMax" href="#pywrapcp.IntervalVarElement.DurationMax">DurationMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.DurationMin" href="#pywrapcp.IntervalVarElement.DurationMin">DurationMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.DurationValue" href="#pywrapcp.IntervalVarElement.DurationValue">DurationValue</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.EndMax" href="#pywrapcp.IntervalVarElement.EndMax">EndMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.EndMin" href="#pywrapcp.IntervalVarElement.EndMin">EndMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.EndValue" href="#pywrapcp.IntervalVarElement.EndValue">EndValue</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.PerformedMax" href="#pywrapcp.IntervalVarElement.PerformedMax">PerformedMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.PerformedMin" href="#pywrapcp.IntervalVarElement.PerformedMin">PerformedMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.PerformedValue" href="#pywrapcp.IntervalVarElement.PerformedValue">PerformedValue</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetDurationMax" href="#pywrapcp.IntervalVarElement.SetDurationMax">SetDurationMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetDurationMin" href="#pywrapcp.IntervalVarElement.SetDurationMin">SetDurationMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetDurationRange" href="#pywrapcp.IntervalVarElement.SetDurationRange">SetDurationRange</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetDurationValue" href="#pywrapcp.IntervalVarElement.SetDurationValue">SetDurationValue</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetEndMax" href="#pywrapcp.IntervalVarElement.SetEndMax">SetEndMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetEndMin" href="#pywrapcp.IntervalVarElement.SetEndMin">SetEndMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetEndRange" href="#pywrapcp.IntervalVarElement.SetEndRange">SetEndRange</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetEndValue" href="#pywrapcp.IntervalVarElement.SetEndValue">SetEndValue</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetPerformedMax" href="#pywrapcp.IntervalVarElement.SetPerformedMax">SetPerformedMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetPerformedMin" href="#pywrapcp.IntervalVarElement.SetPerformedMin">SetPerformedMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetPerformedRange" href="#pywrapcp.IntervalVarElement.SetPerformedRange">SetPerformedRange</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetPerformedValue" href="#pywrapcp.IntervalVarElement.SetPerformedValue">SetPerformedValue</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetStartMax" href="#pywrapcp.IntervalVarElement.SetStartMax">SetStartMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetStartMin" href="#pywrapcp.IntervalVarElement.SetStartMin">SetStartMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetStartRange" href="#pywrapcp.IntervalVarElement.SetStartRange">SetStartRange</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.SetStartValue" href="#pywrapcp.IntervalVarElement.SetStartValue">SetStartValue</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.StartMax" href="#pywrapcp.IntervalVarElement.StartMax">StartMax</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.StartMin" href="#pywrapcp.IntervalVarElement.StartMin">StartMin</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.StartValue" href="#pywrapcp.IntervalVarElement.StartValue">StartValue</a></code></li>
<li><code><a title="pywrapcp.IntervalVarElement.Var" href="#pywrapcp.IntervalVarElement.Var">Var</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.LocalSearchFilter" href="#pywrapcp.LocalSearchFilter">LocalSearchFilter</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.LocalSearchFilter.Accept" href="#pywrapcp.LocalSearchFilter.Accept">Accept</a></code></li>
<li><code><a title="pywrapcp.LocalSearchFilter.IsIncremental" href="#pywrapcp.LocalSearchFilter.IsIncremental">IsIncremental</a></code></li>
<li><code><a title="pywrapcp.LocalSearchFilter.Synchronize" href="#pywrapcp.LocalSearchFilter.Synchronize">Synchronize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.LocalSearchOperator" href="#pywrapcp.LocalSearchOperator">LocalSearchOperator</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.LocalSearchOperator.NextNeighbor" href="#pywrapcp.LocalSearchOperator.NextNeighbor">NextNeighbor</a></code></li>
<li><code><a title="pywrapcp.LocalSearchOperator.Start" href="#pywrapcp.LocalSearchOperator.Start">Start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.NumericalRevInteger" href="#pywrapcp.NumericalRevInteger">NumericalRevInteger</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.NumericalRevInteger.Add" href="#pywrapcp.NumericalRevInteger.Add">Add</a></code></li>
<li><code><a title="pywrapcp.NumericalRevInteger.Decr" href="#pywrapcp.NumericalRevInteger.Decr">Decr</a></code></li>
<li><code><a title="pywrapcp.NumericalRevInteger.Incr" href="#pywrapcp.NumericalRevInteger.Incr">Incr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.OptimizeVar" href="#pywrapcp.OptimizeVar">OptimizeVar</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.OptimizeVar.AcceptDelta" href="#pywrapcp.OptimizeVar.AcceptDelta">AcceptDelta</a></code></li>
<li><code><a title="pywrapcp.OptimizeVar.Best" href="#pywrapcp.OptimizeVar.Best">Best</a></code></li>
<li><code><a title="pywrapcp.OptimizeVar.DebugString" href="#pywrapcp.OptimizeVar.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.OptimizeVar.Var" href="#pywrapcp.OptimizeVar.Var">Var</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.Pack" href="#pywrapcp.Pack">Pack</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.Pack.AddCountAssignedItemsDimension" href="#pywrapcp.Pack.AddCountAssignedItemsDimension">AddCountAssignedItemsDimension</a></code></li>
<li><code><a title="pywrapcp.Pack.AddCountUsedBinDimension" href="#pywrapcp.Pack.AddCountUsedBinDimension">AddCountUsedBinDimension</a></code></li>
<li><code><a title="pywrapcp.Pack.AddSumVariableWeightsLessOrEqualConstantDimension" href="#pywrapcp.Pack.AddSumVariableWeightsLessOrEqualConstantDimension">AddSumVariableWeightsLessOrEqualConstantDimension</a></code></li>
<li><code><a title="pywrapcp.Pack.AddWeightedSumEqualVarDimension" href="#pywrapcp.Pack.AddWeightedSumEqualVarDimension">AddWeightedSumEqualVarDimension</a></code></li>
<li><code><a title="pywrapcp.Pack.AddWeightedSumLessOrEqualConstantDimension" href="#pywrapcp.Pack.AddWeightedSumLessOrEqualConstantDimension">AddWeightedSumLessOrEqualConstantDimension</a></code></li>
<li><code><a title="pywrapcp.Pack.AddWeightedSumOfAssignedDimension" href="#pywrapcp.Pack.AddWeightedSumOfAssignedDimension">AddWeightedSumOfAssignedDimension</a></code></li>
<li><code><a title="pywrapcp.Pack.DebugString" href="#pywrapcp.Pack.DebugString">DebugString</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.PathOperator" href="#pywrapcp.PathOperator">PathOperator</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.PathOperator.Neighbor" href="#pywrapcp.PathOperator.Neighbor">Neighbor</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.PropagationBaseObject" href="#pywrapcp.PropagationBaseObject">PropagationBaseObject</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.PropagationBaseObject.DebugString" href="#pywrapcp.PropagationBaseObject.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.PropagationBaseObject.Name" href="#pywrapcp.PropagationBaseObject.Name">Name</a></code></li>
<li><code><a title="pywrapcp.PropagationBaseObject.solver" href="#pywrapcp.PropagationBaseObject.solver">solver</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.PyConstraint" href="#pywrapcp.PyConstraint">PyConstraint</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.PyConstraint.DebugString" href="#pywrapcp.PyConstraint.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.PyConstraint.DelayedDemon" href="#pywrapcp.PyConstraint.DelayedDemon">DelayedDemon</a></code></li>
<li><code><a title="pywrapcp.PyConstraint.DelayedInitialPropagateDemon" href="#pywrapcp.PyConstraint.DelayedInitialPropagateDemon">DelayedInitialPropagateDemon</a></code></li>
<li><code><a title="pywrapcp.PyConstraint.Demon" href="#pywrapcp.PyConstraint.Demon">Demon</a></code></li>
<li><code><a title="pywrapcp.PyConstraint.InitialPropagateDemon" href="#pywrapcp.PyConstraint.InitialPropagateDemon">InitialPropagateDemon</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.PyConstraintDemon" href="#pywrapcp.PyConstraintDemon">PyConstraintDemon</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.PyConstraintDemon.DebugString" href="#pywrapcp.PyConstraintDemon.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.PyConstraintDemon.Run" href="#pywrapcp.PyConstraintDemon.Run">Run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.PyDecision" href="#pywrapcp.PyDecision">PyDecision</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.PyDecision.DebugString" href="#pywrapcp.PyDecision.DebugString">DebugString</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.PyDecisionBuilder" href="#pywrapcp.PyDecisionBuilder">PyDecisionBuilder</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.PyDecisionBuilder.DebugString" href="#pywrapcp.PyDecisionBuilder.DebugString">DebugString</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.PyDemon" href="#pywrapcp.PyDemon">PyDemon</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.PyDemon.DebugString" href="#pywrapcp.PyDemon.DebugString">DebugString</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.RevBool" href="#pywrapcp.RevBool">RevBool</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.RevBool.SetValue" href="#pywrapcp.RevBool.SetValue">SetValue</a></code></li>
<li><code><a title="pywrapcp.RevBool.Value" href="#pywrapcp.RevBool.Value">Value</a></code></li>
<li><code><a title="pywrapcp.RevBool.thisown" href="#pywrapcp.RevBool.thisown">thisown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.RevInteger" href="#pywrapcp.RevInteger">RevInteger</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.RevInteger.SetValue" href="#pywrapcp.RevInteger.SetValue">SetValue</a></code></li>
<li><code><a title="pywrapcp.RevInteger.Value" href="#pywrapcp.RevInteger.Value">Value</a></code></li>
<li><code><a title="pywrapcp.RevInteger.thisown" href="#pywrapcp.RevInteger.thisown">thisown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.RoutingDimension" href="#pywrapcp.RoutingDimension">RoutingDimension</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.RoutingDimension.AddNodePrecedence" href="#pywrapcp.RoutingDimension.AddNodePrecedence">AddNodePrecedence</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.CumulVar" href="#pywrapcp.RoutingDimension.CumulVar">CumulVar</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.FixedTransitVar" href="#pywrapcp.RoutingDimension.FixedTransitVar">FixedTransitVar</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.GetCumulVarSoftLowerBound" href="#pywrapcp.RoutingDimension.GetCumulVarSoftLowerBound">GetCumulVarSoftLowerBound</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.GetCumulVarSoftLowerBoundCoefficient" href="#pywrapcp.RoutingDimension.GetCumulVarSoftLowerBoundCoefficient">GetCumulVarSoftLowerBoundCoefficient</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.GetCumulVarSoftUpperBound" href="#pywrapcp.RoutingDimension.GetCumulVarSoftUpperBound">GetCumulVarSoftUpperBound</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.GetCumulVarSoftUpperBoundCoefficient" href="#pywrapcp.RoutingDimension.GetCumulVarSoftUpperBoundCoefficient">GetCumulVarSoftUpperBoundCoefficient</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.GetGlobalOptimizerOffset" href="#pywrapcp.RoutingDimension.GetGlobalOptimizerOffset">GetGlobalOptimizerOffset</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.GetLocalOptimizerOffsetForVehicle" href="#pywrapcp.RoutingDimension.GetLocalOptimizerOffsetForVehicle">GetLocalOptimizerOffsetForVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.GetPostTravelEvaluatorOfVehicle" href="#pywrapcp.RoutingDimension.GetPostTravelEvaluatorOfVehicle">GetPostTravelEvaluatorOfVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.GetPreTravelEvaluatorOfVehicle" href="#pywrapcp.RoutingDimension.GetPreTravelEvaluatorOfVehicle">GetPreTravelEvaluatorOfVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.GetSpanCostCoefficientForVehicle" href="#pywrapcp.RoutingDimension.GetSpanCostCoefficientForVehicle">GetSpanCostCoefficientForVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.GetSpanUpperBoundForVehicle" href="#pywrapcp.RoutingDimension.GetSpanUpperBoundForVehicle">GetSpanUpperBoundForVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.GetTransitValue" href="#pywrapcp.RoutingDimension.GetTransitValue">GetTransitValue</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.GetTransitValueFromClass" href="#pywrapcp.RoutingDimension.GetTransitValueFromClass">GetTransitValueFromClass</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.HasBreakConstraints" href="#pywrapcp.RoutingDimension.HasBreakConstraints">HasBreakConstraints</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.HasCumulVarSoftLowerBound" href="#pywrapcp.RoutingDimension.HasCumulVarSoftLowerBound">HasCumulVarSoftLowerBound</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.HasCumulVarSoftUpperBound" href="#pywrapcp.RoutingDimension.HasCumulVarSoftUpperBound">HasCumulVarSoftUpperBound</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.HasPickupToDeliveryLimits" href="#pywrapcp.RoutingDimension.HasPickupToDeliveryLimits">HasPickupToDeliveryLimits</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.InitializeBreaks" href="#pywrapcp.RoutingDimension.InitializeBreaks">InitializeBreaks</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.SetBreakDistanceDurationOfVehicle" href="#pywrapcp.RoutingDimension.SetBreakDistanceDurationOfVehicle">SetBreakDistanceDurationOfVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.SetBreakIntervalsOfVehicle" href="#pywrapcp.RoutingDimension.SetBreakIntervalsOfVehicle">SetBreakIntervalsOfVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.SetCumulVarSoftLowerBound" href="#pywrapcp.RoutingDimension.SetCumulVarSoftLowerBound">SetCumulVarSoftLowerBound</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.SetCumulVarSoftUpperBound" href="#pywrapcp.RoutingDimension.SetCumulVarSoftUpperBound">SetCumulVarSoftUpperBound</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.SetGlobalSpanCostCoefficient" href="#pywrapcp.RoutingDimension.SetGlobalSpanCostCoefficient">SetGlobalSpanCostCoefficient</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.SetPickupToDeliveryLimitFunctionForPair" href="#pywrapcp.RoutingDimension.SetPickupToDeliveryLimitFunctionForPair">SetPickupToDeliveryLimitFunctionForPair</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.SetSpanCostCoefficientForAllVehicles" href="#pywrapcp.RoutingDimension.SetSpanCostCoefficientForAllVehicles">SetSpanCostCoefficientForAllVehicles</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.SetSpanCostCoefficientForVehicle" href="#pywrapcp.RoutingDimension.SetSpanCostCoefficientForVehicle">SetSpanCostCoefficientForVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.SetSpanUpperBoundForVehicle" href="#pywrapcp.RoutingDimension.SetSpanUpperBoundForVehicle">SetSpanUpperBoundForVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.ShortestTransitionSlack" href="#pywrapcp.RoutingDimension.ShortestTransitionSlack">ShortestTransitionSlack</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.SlackVar" href="#pywrapcp.RoutingDimension.SlackVar">SlackVar</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.TransitVar" href="#pywrapcp.RoutingDimension.TransitVar">TransitVar</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.base_dimension" href="#pywrapcp.RoutingDimension.base_dimension">base_dimension</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.global_span_cost_coefficient" href="#pywrapcp.RoutingDimension.global_span_cost_coefficient">global_span_cost_coefficient</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.model" href="#pywrapcp.RoutingDimension.model">model</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.name" href="#pywrapcp.RoutingDimension.name">name</a></code></li>
<li><code><a title="pywrapcp.RoutingDimension.thisown" href="#pywrapcp.RoutingDimension.thisown">thisown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.RoutingIndexManager" href="#pywrapcp.RoutingIndexManager">RoutingIndexManager</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.RoutingIndexManager.GetNumberOfIndices" href="#pywrapcp.RoutingIndexManager.GetNumberOfIndices">GetNumberOfIndices</a></code></li>
<li><code><a title="pywrapcp.RoutingIndexManager.GetNumberOfNodes" href="#pywrapcp.RoutingIndexManager.GetNumberOfNodes">GetNumberOfNodes</a></code></li>
<li><code><a title="pywrapcp.RoutingIndexManager.GetNumberOfVehicles" href="#pywrapcp.RoutingIndexManager.GetNumberOfVehicles">GetNumberOfVehicles</a></code></li>
<li><code><a title="pywrapcp.RoutingIndexManager.IndexToNode" href="#pywrapcp.RoutingIndexManager.IndexToNode">IndexToNode</a></code></li>
<li><code><a title="pywrapcp.RoutingIndexManager.NodeToIndex" href="#pywrapcp.RoutingIndexManager.NodeToIndex">NodeToIndex</a></code></li>
<li><code><a title="pywrapcp.RoutingIndexManager.thisown" href="#pywrapcp.RoutingIndexManager.thisown">thisown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.RoutingModel" href="#pywrapcp.RoutingModel">RoutingModel</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.RoutingModel.ADDED_TYPE_REMOVED_FROM_VEHICLE" href="#pywrapcp.RoutingModel.ADDED_TYPE_REMOVED_FROM_VEHICLE">ADDED_TYPE_REMOVED_FROM_VEHICLE</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.ActiveVar" href="#pywrapcp.RoutingModel.ActiveVar">ActiveVar</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddAtSolutionCallback" href="#pywrapcp.RoutingModel.AddAtSolutionCallback">AddAtSolutionCallback</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddConstantDimension" href="#pywrapcp.RoutingModel.AddConstantDimension">AddConstantDimension</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddConstantDimensionWithSlack" href="#pywrapcp.RoutingModel.AddConstantDimensionWithSlack">AddConstantDimensionWithSlack</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddDimension" href="#pywrapcp.RoutingModel.AddDimension">AddDimension</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddDimensionWithVehicleCapacity" href="#pywrapcp.RoutingModel.AddDimensionWithVehicleCapacity">AddDimensionWithVehicleCapacity</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddDimensionWithVehicleTransitAndCapacity" href="#pywrapcp.RoutingModel.AddDimensionWithVehicleTransitAndCapacity">AddDimensionWithVehicleTransitAndCapacity</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddDimensionWithVehicleTransits" href="#pywrapcp.RoutingModel.AddDimensionWithVehicleTransits">AddDimensionWithVehicleTransits</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddDisjunction" href="#pywrapcp.RoutingModel.AddDisjunction">AddDisjunction</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddHardTypeIncompatibility" href="#pywrapcp.RoutingModel.AddHardTypeIncompatibility">AddHardTypeIncompatibility</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddIntervalToAssignment" href="#pywrapcp.RoutingModel.AddIntervalToAssignment">AddIntervalToAssignment</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddLocalSearchFilter" href="#pywrapcp.RoutingModel.AddLocalSearchFilter">AddLocalSearchFilter</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddLocalSearchOperator" href="#pywrapcp.RoutingModel.AddLocalSearchOperator">AddLocalSearchOperator</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddMatrixDimension" href="#pywrapcp.RoutingModel.AddMatrixDimension">AddMatrixDimension</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddPickupAndDelivery" href="#pywrapcp.RoutingModel.AddPickupAndDelivery">AddPickupAndDelivery</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddPickupAndDeliverySets" href="#pywrapcp.RoutingModel.AddPickupAndDeliverySets">AddPickupAndDeliverySets</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddRequiredTypeAlternativesWhenAddingType" href="#pywrapcp.RoutingModel.AddRequiredTypeAlternativesWhenAddingType">AddRequiredTypeAlternativesWhenAddingType</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddRequiredTypeAlternativesWhenRemovingType" href="#pywrapcp.RoutingModel.AddRequiredTypeAlternativesWhenRemovingType">AddRequiredTypeAlternativesWhenRemovingType</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddSameVehicleRequiredTypeAlternatives" href="#pywrapcp.RoutingModel.AddSameVehicleRequiredTypeAlternatives">AddSameVehicleRequiredTypeAlternatives</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddSearchMonitor" href="#pywrapcp.RoutingModel.AddSearchMonitor">AddSearchMonitor</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddSoftSameVehicleConstraint" href="#pywrapcp.RoutingModel.AddSoftSameVehicleConstraint">AddSoftSameVehicleConstraint</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddTemporalTypeIncompatibility" href="#pywrapcp.RoutingModel.AddTemporalTypeIncompatibility">AddTemporalTypeIncompatibility</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddToAssignment" href="#pywrapcp.RoutingModel.AddToAssignment">AddToAssignment</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddVariableMaximizedByFinalizer" href="#pywrapcp.RoutingModel.AddVariableMaximizedByFinalizer">AddVariableMaximizedByFinalizer</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddVariableMinimizedByFinalizer" href="#pywrapcp.RoutingModel.AddVariableMinimizedByFinalizer">AddVariableMinimizedByFinalizer</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddVariableTargetToFinalizer" href="#pywrapcp.RoutingModel.AddVariableTargetToFinalizer">AddVariableTargetToFinalizer</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddVectorDimension" href="#pywrapcp.RoutingModel.AddVectorDimension">AddVectorDimension</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AddWeightedVariableMinimizedByFinalizer" href="#pywrapcp.RoutingModel.AddWeightedVariableMinimizedByFinalizer">AddWeightedVariableMinimizedByFinalizer</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.ApplyLocks" href="#pywrapcp.RoutingModel.ApplyLocks">ApplyLocks</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.ApplyLocksToAllVehicles" href="#pywrapcp.RoutingModel.ApplyLocksToAllVehicles">ApplyLocksToAllVehicles</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.ArcIsMoreConstrainedThanArc" href="#pywrapcp.RoutingModel.ArcIsMoreConstrainedThanArc">ArcIsMoreConstrainedThanArc</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AreEmptyRouteCostsConsideredForVehicle" href="#pywrapcp.RoutingModel.AreEmptyRouteCostsConsideredForVehicle">AreEmptyRouteCostsConsideredForVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.AssignmentToRoutes" href="#pywrapcp.RoutingModel.AssignmentToRoutes">AssignmentToRoutes</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.CheckLimit" href="#pywrapcp.RoutingModel.CheckLimit">CheckLimit</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.CloseModel" href="#pywrapcp.RoutingModel.CloseModel">CloseModel</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.CloseModelWithParameters" href="#pywrapcp.RoutingModel.CloseModelWithParameters">CloseModelWithParameters</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.CloseVisitTypes" href="#pywrapcp.RoutingModel.CloseVisitTypes">CloseVisitTypes</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.CompactAndCheckAssignment" href="#pywrapcp.RoutingModel.CompactAndCheckAssignment">CompactAndCheckAssignment</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.CompactAssignment" href="#pywrapcp.RoutingModel.CompactAssignment">CompactAssignment</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.ComputeLowerBound" href="#pywrapcp.RoutingModel.ComputeLowerBound">ComputeLowerBound</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.ConsiderEmptyRouteCostsForVehicle" href="#pywrapcp.RoutingModel.ConsiderEmptyRouteCostsForVehicle">ConsiderEmptyRouteCostsForVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.CostVar" href="#pywrapcp.RoutingModel.CostVar">CostVar</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.CostsAreHomogeneousAcrossVehicles" href="#pywrapcp.RoutingModel.CostsAreHomogeneousAcrossVehicles">CostsAreHomogeneousAcrossVehicles</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.DebugOutputAssignment" href="#pywrapcp.RoutingModel.DebugOutputAssignment">DebugOutputAssignment</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.End" href="#pywrapcp.RoutingModel.End">End</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetAllDimensionNames" href="#pywrapcp.RoutingModel.GetAllDimensionNames">GetAllDimensionNames</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetAmortizedLinearCostFactorOfVehicles" href="#pywrapcp.RoutingModel.GetAmortizedLinearCostFactorOfVehicles">GetAmortizedLinearCostFactorOfVehicles</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetAmortizedQuadraticCostFactorOfVehicles" href="#pywrapcp.RoutingModel.GetAmortizedQuadraticCostFactorOfVehicles">GetAmortizedQuadraticCostFactorOfVehicles</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetArcCostForClass" href="#pywrapcp.RoutingModel.GetArcCostForClass">GetArcCostForClass</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetArcCostForFirstSolution" href="#pywrapcp.RoutingModel.GetArcCostForFirstSolution">GetArcCostForFirstSolution</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetArcCostForVehicle" href="#pywrapcp.RoutingModel.GetArcCostForVehicle">GetArcCostForVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetAutomaticFirstSolutionStrategy" href="#pywrapcp.RoutingModel.GetAutomaticFirstSolutionStrategy">GetAutomaticFirstSolutionStrategy</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetCostClassIndexOfVehicle" href="#pywrapcp.RoutingModel.GetCostClassIndexOfVehicle">GetCostClassIndexOfVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetCostClassesCount" href="#pywrapcp.RoutingModel.GetCostClassesCount">GetCostClassesCount</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetDeliveryIndexPairs" href="#pywrapcp.RoutingModel.GetDeliveryIndexPairs">GetDeliveryIndexPairs</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetDepot" href="#pywrapcp.RoutingModel.GetDepot">GetDepot</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetDimensionOrDie" href="#pywrapcp.RoutingModel.GetDimensionOrDie">GetDimensionOrDie</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetDimensions" href="#pywrapcp.RoutingModel.GetDimensions">GetDimensions</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetDimensionsWithSoftOrSpanCosts" href="#pywrapcp.RoutingModel.GetDimensionsWithSoftOrSpanCosts">GetDimensionsWithSoftOrSpanCosts</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetDisjunctionIndices" href="#pywrapcp.RoutingModel.GetDisjunctionIndices">GetDisjunctionIndices</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetDisjunctionMaxCardinality" href="#pywrapcp.RoutingModel.GetDisjunctionMaxCardinality">GetDisjunctionMaxCardinality</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetDisjunctionPenalty" href="#pywrapcp.RoutingModel.GetDisjunctionPenalty">GetDisjunctionPenalty</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetFixedCostOfVehicle" href="#pywrapcp.RoutingModel.GetFixedCostOfVehicle">GetFixedCostOfVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetGlobalDimensionCumulOptimizers" href="#pywrapcp.RoutingModel.GetGlobalDimensionCumulOptimizers">GetGlobalDimensionCumulOptimizers</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetHardTypeIncompatibilitiesOfType" href="#pywrapcp.RoutingModel.GetHardTypeIncompatibilitiesOfType">GetHardTypeIncompatibilitiesOfType</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetHomogeneousCost" href="#pywrapcp.RoutingModel.GetHomogeneousCost">GetHomogeneousCost</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetLocalDimensionCumulMPOptimizers" href="#pywrapcp.RoutingModel.GetLocalDimensionCumulMPOptimizers">GetLocalDimensionCumulMPOptimizers</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetLocalDimensionCumulOptimizers" href="#pywrapcp.RoutingModel.GetLocalDimensionCumulOptimizers">GetLocalDimensionCumulOptimizers</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetMutableDimension" href="#pywrapcp.RoutingModel.GetMutableDimension">GetMutableDimension</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetMutableGlobalCumulOptimizer" href="#pywrapcp.RoutingModel.GetMutableGlobalCumulOptimizer">GetMutableGlobalCumulOptimizer</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetMutableLocalCumulMPOptimizer" href="#pywrapcp.RoutingModel.GetMutableLocalCumulMPOptimizer">GetMutableLocalCumulMPOptimizer</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetMutableLocalCumulOptimizer" href="#pywrapcp.RoutingModel.GetMutableLocalCumulOptimizer">GetMutableLocalCumulOptimizer</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetNonZeroCostClassesCount" href="#pywrapcp.RoutingModel.GetNonZeroCostClassesCount">GetNonZeroCostClassesCount</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetNumOfSingletonNodes" href="#pywrapcp.RoutingModel.GetNumOfSingletonNodes">GetNumOfSingletonNodes</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetNumberOfDecisionsInFirstSolution" href="#pywrapcp.RoutingModel.GetNumberOfDecisionsInFirstSolution">GetNumberOfDecisionsInFirstSolution</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetNumberOfDisjunctions" href="#pywrapcp.RoutingModel.GetNumberOfDisjunctions">GetNumberOfDisjunctions</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetNumberOfRejectsInFirstSolution" href="#pywrapcp.RoutingModel.GetNumberOfRejectsInFirstSolution">GetNumberOfRejectsInFirstSolution</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetNumberOfVisitTypes" href="#pywrapcp.RoutingModel.GetNumberOfVisitTypes">GetNumberOfVisitTypes</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetPerfectBinaryDisjunctions" href="#pywrapcp.RoutingModel.GetPerfectBinaryDisjunctions">GetPerfectBinaryDisjunctions</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetPickupAndDeliveryPolicyOfVehicle" href="#pywrapcp.RoutingModel.GetPickupAndDeliveryPolicyOfVehicle">GetPickupAndDeliveryPolicyOfVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetPickupIndexPairs" href="#pywrapcp.RoutingModel.GetPickupIndexPairs">GetPickupIndexPairs</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetPrimaryConstrainedDimension" href="#pywrapcp.RoutingModel.GetPrimaryConstrainedDimension">GetPrimaryConstrainedDimension</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetRequiredTypeAlternativesWhenAddingType" href="#pywrapcp.RoutingModel.GetRequiredTypeAlternativesWhenAddingType">GetRequiredTypeAlternativesWhenAddingType</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetRequiredTypeAlternativesWhenRemovingType" href="#pywrapcp.RoutingModel.GetRequiredTypeAlternativesWhenRemovingType">GetRequiredTypeAlternativesWhenRemovingType</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetSameVehicleIndicesOfIndex" href="#pywrapcp.RoutingModel.GetSameVehicleIndicesOfIndex">GetSameVehicleIndicesOfIndex</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetSameVehicleRequiredTypeAlternativesOfType" href="#pywrapcp.RoutingModel.GetSameVehicleRequiredTypeAlternativesOfType">GetSameVehicleRequiredTypeAlternativesOfType</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetTemporalTypeIncompatibilitiesOfType" href="#pywrapcp.RoutingModel.GetTemporalTypeIncompatibilitiesOfType">GetTemporalTypeIncompatibilitiesOfType</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetVehicleClassIndexOfVehicle" href="#pywrapcp.RoutingModel.GetVehicleClassIndexOfVehicle">GetVehicleClassIndexOfVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetVehicleClassesCount" href="#pywrapcp.RoutingModel.GetVehicleClassesCount">GetVehicleClassesCount</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetVisitType" href="#pywrapcp.RoutingModel.GetVisitType">GetVisitType</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.GetVisitTypePolicy" href="#pywrapcp.RoutingModel.GetVisitTypePolicy">GetVisitTypePolicy</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.HasDimension" href="#pywrapcp.RoutingModel.HasDimension">HasDimension</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.HasHardTypeIncompatibilities" href="#pywrapcp.RoutingModel.HasHardTypeIncompatibilities">HasHardTypeIncompatibilities</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.HasSameVehicleTypeRequirements" href="#pywrapcp.RoutingModel.HasSameVehicleTypeRequirements">HasSameVehicleTypeRequirements</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.HasTemporalTypeIncompatibilities" href="#pywrapcp.RoutingModel.HasTemporalTypeIncompatibilities">HasTemporalTypeIncompatibilities</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.HasTemporalTypeRequirements" href="#pywrapcp.RoutingModel.HasTemporalTypeRequirements">HasTemporalTypeRequirements</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.HasTypeRegulations" href="#pywrapcp.RoutingModel.HasTypeRegulations">HasTypeRegulations</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.HasVehicleWithCostClassIndex" href="#pywrapcp.RoutingModel.HasVehicleWithCostClassIndex">HasVehicleWithCostClassIndex</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.IgnoreDisjunctionsAlreadyForcedToZero" href="#pywrapcp.RoutingModel.IgnoreDisjunctionsAlreadyForcedToZero">IgnoreDisjunctionsAlreadyForcedToZero</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.IsEnd" href="#pywrapcp.RoutingModel.IsEnd">IsEnd</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.IsMatchingModel" href="#pywrapcp.RoutingModel.IsMatchingModel">IsMatchingModel</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.IsStart" href="#pywrapcp.RoutingModel.IsStart">IsStart</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.IsVehicleAllowedForIndex" href="#pywrapcp.RoutingModel.IsVehicleAllowedForIndex">IsVehicleAllowedForIndex</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.IsVehicleUsed" href="#pywrapcp.RoutingModel.IsVehicleUsed">IsVehicleUsed</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.MakeGuidedSlackFinalizer" href="#pywrapcp.RoutingModel.MakeGuidedSlackFinalizer">MakeGuidedSlackFinalizer</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.MakePathSpansAndTotalSlacks" href="#pywrapcp.RoutingModel.MakePathSpansAndTotalSlacks">MakePathSpansAndTotalSlacks</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.MakeSelfDependentDimensionFinalizer" href="#pywrapcp.RoutingModel.MakeSelfDependentDimensionFinalizer">MakeSelfDependentDimensionFinalizer</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.MutablePreAssignment" href="#pywrapcp.RoutingModel.MutablePreAssignment">MutablePreAssignment</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.Next" href="#pywrapcp.RoutingModel.Next">Next</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.NextVar" href="#pywrapcp.RoutingModel.NextVar">NextVar</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.PICKUP_AND_DELIVERY_FIFO" href="#pywrapcp.RoutingModel.PICKUP_AND_DELIVERY_FIFO">PICKUP_AND_DELIVERY_FIFO</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.PICKUP_AND_DELIVERY_LIFO" href="#pywrapcp.RoutingModel.PICKUP_AND_DELIVERY_LIFO">PICKUP_AND_DELIVERY_LIFO</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.PICKUP_AND_DELIVERY_NO_ORDER" href="#pywrapcp.RoutingModel.PICKUP_AND_DELIVERY_NO_ORDER">PICKUP_AND_DELIVERY_NO_ORDER</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.PackCumulsOfOptimizerDimensionsFromAssignment" href="#pywrapcp.RoutingModel.PackCumulsOfOptimizerDimensionsFromAssignment">PackCumulsOfOptimizerDimensionsFromAssignment</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.PreAssignment" href="#pywrapcp.RoutingModel.PreAssignment">PreAssignment</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.ROUTING_FAIL" href="#pywrapcp.RoutingModel.ROUTING_FAIL">ROUTING_FAIL</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.ROUTING_FAIL_TIMEOUT" href="#pywrapcp.RoutingModel.ROUTING_FAIL_TIMEOUT">ROUTING_FAIL_TIMEOUT</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.ROUTING_INVALID" href="#pywrapcp.RoutingModel.ROUTING_INVALID">ROUTING_INVALID</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.ROUTING_NOT_SOLVED" href="#pywrapcp.RoutingModel.ROUTING_NOT_SOLVED">ROUTING_NOT_SOLVED</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.ROUTING_SUCCESS" href="#pywrapcp.RoutingModel.ROUTING_SUCCESS">ROUTING_SUCCESS</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.ReadAssignment" href="#pywrapcp.RoutingModel.ReadAssignment">ReadAssignment</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.ReadAssignmentFromRoutes" href="#pywrapcp.RoutingModel.ReadAssignmentFromRoutes">ReadAssignmentFromRoutes</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.RegisterPositiveTransitCallback" href="#pywrapcp.RoutingModel.RegisterPositiveTransitCallback">RegisterPositiveTransitCallback</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.RegisterPositiveUnaryTransitCallback" href="#pywrapcp.RoutingModel.RegisterPositiveUnaryTransitCallback">RegisterPositiveUnaryTransitCallback</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.RegisterTransitCallback" href="#pywrapcp.RoutingModel.RegisterTransitCallback">RegisterTransitCallback</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.RegisterUnaryTransitCallback" href="#pywrapcp.RoutingModel.RegisterUnaryTransitCallback">RegisterUnaryTransitCallback</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.RemainingTime" href="#pywrapcp.RoutingModel.RemainingTime">RemainingTime</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.RestoreAssignment" href="#pywrapcp.RoutingModel.RestoreAssignment">RestoreAssignment</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.RoutesToAssignment" href="#pywrapcp.RoutingModel.RoutesToAssignment">RoutesToAssignment</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SetAllowedVehiclesForIndex" href="#pywrapcp.RoutingModel.SetAllowedVehiclesForIndex">SetAllowedVehiclesForIndex</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SetAmortizedCostFactorsOfAllVehicles" href="#pywrapcp.RoutingModel.SetAmortizedCostFactorsOfAllVehicles">SetAmortizedCostFactorsOfAllVehicles</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SetAmortizedCostFactorsOfVehicle" href="#pywrapcp.RoutingModel.SetAmortizedCostFactorsOfVehicle">SetAmortizedCostFactorsOfVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SetArcCostEvaluatorOfAllVehicles" href="#pywrapcp.RoutingModel.SetArcCostEvaluatorOfAllVehicles">SetArcCostEvaluatorOfAllVehicles</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SetArcCostEvaluatorOfVehicle" href="#pywrapcp.RoutingModel.SetArcCostEvaluatorOfVehicle">SetArcCostEvaluatorOfVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SetAssignmentFromOtherModelAssignment" href="#pywrapcp.RoutingModel.SetAssignmentFromOtherModelAssignment">SetAssignmentFromOtherModelAssignment</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SetFirstSolutionEvaluator" href="#pywrapcp.RoutingModel.SetFirstSolutionEvaluator">SetFirstSolutionEvaluator</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SetFixedCostOfAllVehicles" href="#pywrapcp.RoutingModel.SetFixedCostOfAllVehicles">SetFixedCostOfAllVehicles</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SetFixedCostOfVehicle" href="#pywrapcp.RoutingModel.SetFixedCostOfVehicle">SetFixedCostOfVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SetPickupAndDeliveryPolicyOfAllVehicles" href="#pywrapcp.RoutingModel.SetPickupAndDeliveryPolicyOfAllVehicles">SetPickupAndDeliveryPolicyOfAllVehicles</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SetPickupAndDeliveryPolicyOfVehicle" href="#pywrapcp.RoutingModel.SetPickupAndDeliveryPolicyOfVehicle">SetPickupAndDeliveryPolicyOfVehicle</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SetPrimaryConstrainedDimension" href="#pywrapcp.RoutingModel.SetPrimaryConstrainedDimension">SetPrimaryConstrainedDimension</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SetVisitType" href="#pywrapcp.RoutingModel.SetVisitType">SetVisitType</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.Size" href="#pywrapcp.RoutingModel.Size">Size</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.Solve" href="#pywrapcp.RoutingModel.Solve">Solve</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SolveFromAssignmentWithParameters" href="#pywrapcp.RoutingModel.SolveFromAssignmentWithParameters">SolveFromAssignmentWithParameters</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.SolveWithParameters" href="#pywrapcp.RoutingModel.SolveWithParameters">SolveWithParameters</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.Start" href="#pywrapcp.RoutingModel.Start">Start</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.TYPE_ADDED_TO_VEHICLE" href="#pywrapcp.RoutingModel.TYPE_ADDED_TO_VEHICLE">TYPE_ADDED_TO_VEHICLE</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.TYPE_ON_VEHICLE_UP_TO_VISIT" href="#pywrapcp.RoutingModel.TYPE_ON_VEHICLE_UP_TO_VISIT">TYPE_ON_VEHICLE_UP_TO_VISIT</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED" href="#pywrapcp.RoutingModel.TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED">TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.TransitCallback" href="#pywrapcp.RoutingModel.TransitCallback">TransitCallback</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.UnaryTransitCallbackOrNull" href="#pywrapcp.RoutingModel.UnaryTransitCallbackOrNull">UnaryTransitCallbackOrNull</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.UnperformedPenalty" href="#pywrapcp.RoutingModel.UnperformedPenalty">UnperformedPenalty</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.UnperformedPenaltyOrValue" href="#pywrapcp.RoutingModel.UnperformedPenaltyOrValue">UnperformedPenaltyOrValue</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.VehicleCostsConsideredVar" href="#pywrapcp.RoutingModel.VehicleCostsConsideredVar">VehicleCostsConsideredVar</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.VehicleIndex" href="#pywrapcp.RoutingModel.VehicleIndex">VehicleIndex</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.VehicleVar" href="#pywrapcp.RoutingModel.VehicleVar">VehicleVar</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.WriteAssignment" href="#pywrapcp.RoutingModel.WriteAssignment">WriteAssignment</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.kNoDimension" href="#pywrapcp.RoutingModel.kNoDimension">kNoDimension</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.kNoDisjunction" href="#pywrapcp.RoutingModel.kNoDisjunction">kNoDisjunction</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.kNoPenalty" href="#pywrapcp.RoutingModel.kNoPenalty">kNoPenalty</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.nodes" href="#pywrapcp.RoutingModel.nodes">nodes</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.solver" href="#pywrapcp.RoutingModel.solver">solver</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.status" href="#pywrapcp.RoutingModel.status">status</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.thisown" href="#pywrapcp.RoutingModel.thisown">thisown</a></code></li>
<li><code><a title="pywrapcp.RoutingModel.vehicles" href="#pywrapcp.RoutingModel.vehicles">vehicles</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.RoutingModelVisitor" href="#pywrapcp.RoutingModelVisitor">RoutingModelVisitor</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.RoutingModelVisitor.kLightElement" href="#pywrapcp.RoutingModelVisitor.kLightElement">kLightElement</a></code></li>
<li><code><a title="pywrapcp.RoutingModelVisitor.kLightElement2" href="#pywrapcp.RoutingModelVisitor.kLightElement2">kLightElement2</a></code></li>
<li><code><a title="pywrapcp.RoutingModelVisitor.kRemoveValues" href="#pywrapcp.RoutingModelVisitor.kRemoveValues">kRemoveValues</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.SearchLimit" href="#pywrapcp.SearchLimit">SearchLimit</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.SearchLimit.Check" href="#pywrapcp.SearchLimit.Check">Check</a></code></li>
<li><code><a title="pywrapcp.SearchLimit.Crossed" href="#pywrapcp.SearchLimit.Crossed">Crossed</a></code></li>
<li><code><a title="pywrapcp.SearchLimit.DebugString" href="#pywrapcp.SearchLimit.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.SearchLimit.EnterSearch" href="#pywrapcp.SearchLimit.EnterSearch">EnterSearch</a></code></li>
<li><code><a title="pywrapcp.SearchLimit.Init" href="#pywrapcp.SearchLimit.Init">Init</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.SearchMonitor" href="#pywrapcp.SearchMonitor">SearchMonitor</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.SearchMonitor.AcceptDelta" href="#pywrapcp.SearchMonitor.AcceptDelta">AcceptDelta</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.AcceptNeighbor" href="#pywrapcp.SearchMonitor.AcceptNeighbor">AcceptNeighbor</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.AcceptSolution" href="#pywrapcp.SearchMonitor.AcceptSolution">AcceptSolution</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.AfterDecision" href="#pywrapcp.SearchMonitor.AfterDecision">AfterDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.ApplyDecision" href="#pywrapcp.SearchMonitor.ApplyDecision">ApplyDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.AtSolution" href="#pywrapcp.SearchMonitor.AtSolution">AtSolution</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.BeginFail" href="#pywrapcp.SearchMonitor.BeginFail">BeginFail</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.BeginInitialPropagation" href="#pywrapcp.SearchMonitor.BeginInitialPropagation">BeginInitialPropagation</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.BeginNextDecision" href="#pywrapcp.SearchMonitor.BeginNextDecision">BeginNextDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EndFail" href="#pywrapcp.SearchMonitor.EndFail">EndFail</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EndInitialPropagation" href="#pywrapcp.SearchMonitor.EndInitialPropagation">EndInitialPropagation</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EndNextDecision" href="#pywrapcp.SearchMonitor.EndNextDecision">EndNextDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.EnterSearch" href="#pywrapcp.SearchMonitor.EnterSearch">EnterSearch</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.ExitSearch" href="#pywrapcp.SearchMonitor.ExitSearch">ExitSearch</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.LocalOptimum" href="#pywrapcp.SearchMonitor.LocalOptimum">LocalOptimum</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.NoMoreSolutions" href="#pywrapcp.SearchMonitor.NoMoreSolutions">NoMoreSolutions</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.RefuteDecision" href="#pywrapcp.SearchMonitor.RefuteDecision">RefuteDecision</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.RestartSearch" href="#pywrapcp.SearchMonitor.RestartSearch">RestartSearch</a></code></li>
<li><code><a title="pywrapcp.SearchMonitor.solver" href="#pywrapcp.SearchMonitor.solver">solver</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.SequenceVar" href="#pywrapcp.SequenceVar">SequenceVar</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.SequenceVar.DebugString" href="#pywrapcp.SequenceVar.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.SequenceVar.Interval" href="#pywrapcp.SequenceVar.Interval">Interval</a></code></li>
<li><code><a title="pywrapcp.SequenceVar.Next" href="#pywrapcp.SequenceVar.Next">Next</a></code></li>
<li><code><a title="pywrapcp.SequenceVar.RankFirst" href="#pywrapcp.SequenceVar.RankFirst">RankFirst</a></code></li>
<li><code><a title="pywrapcp.SequenceVar.RankLast" href="#pywrapcp.SequenceVar.RankLast">RankLast</a></code></li>
<li><code><a title="pywrapcp.SequenceVar.RankNotFirst" href="#pywrapcp.SequenceVar.RankNotFirst">RankNotFirst</a></code></li>
<li><code><a title="pywrapcp.SequenceVar.RankNotLast" href="#pywrapcp.SequenceVar.RankNotLast">RankNotLast</a></code></li>
<li><code><a title="pywrapcp.SequenceVar.Size" href="#pywrapcp.SequenceVar.Size">Size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.SequenceVarContainer" href="#pywrapcp.SequenceVarContainer">SequenceVarContainer</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.SequenceVarContainer.Contains" href="#pywrapcp.SequenceVarContainer.Contains">Contains</a></code></li>
<li><code><a title="pywrapcp.SequenceVarContainer.Element" href="#pywrapcp.SequenceVarContainer.Element">Element</a></code></li>
<li><code><a title="pywrapcp.SequenceVarContainer.Restore" href="#pywrapcp.SequenceVarContainer.Restore">Restore</a></code></li>
<li><code><a title="pywrapcp.SequenceVarContainer.Size" href="#pywrapcp.SequenceVarContainer.Size">Size</a></code></li>
<li><code><a title="pywrapcp.SequenceVarContainer.Store" href="#pywrapcp.SequenceVarContainer.Store">Store</a></code></li>
<li><code><a title="pywrapcp.SequenceVarContainer.thisown" href="#pywrapcp.SequenceVarContainer.thisown">thisown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.SequenceVarElement" href="#pywrapcp.SequenceVarElement">SequenceVarElement</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.SequenceVarElement.BackwardSequence" href="#pywrapcp.SequenceVarElement.BackwardSequence">BackwardSequence</a></code></li>
<li><code><a title="pywrapcp.SequenceVarElement.ForwardSequence" href="#pywrapcp.SequenceVarElement.ForwardSequence">ForwardSequence</a></code></li>
<li><code><a title="pywrapcp.SequenceVarElement.SetBackwardSequence" href="#pywrapcp.SequenceVarElement.SetBackwardSequence">SetBackwardSequence</a></code></li>
<li><code><a title="pywrapcp.SequenceVarElement.SetForwardSequence" href="#pywrapcp.SequenceVarElement.SetForwardSequence">SetForwardSequence</a></code></li>
<li><code><a title="pywrapcp.SequenceVarElement.SetSequence" href="#pywrapcp.SequenceVarElement.SetSequence">SetSequence</a></code></li>
<li><code><a title="pywrapcp.SequenceVarElement.SetUnperformed" href="#pywrapcp.SequenceVarElement.SetUnperformed">SetUnperformed</a></code></li>
<li><code><a title="pywrapcp.SequenceVarElement.Unperformed" href="#pywrapcp.SequenceVarElement.Unperformed">Unperformed</a></code></li>
<li><code><a title="pywrapcp.SequenceVarElement.Var" href="#pywrapcp.SequenceVarElement.Var">Var</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.SequenceVarLocalSearchOperator" href="#pywrapcp.SequenceVarLocalSearchOperator">SequenceVarLocalSearchOperator</a></code></h4>
</li>
<li>
<h4><code><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate">SequenceVarLocalSearchOperatorTemplate</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate.IsIncremental" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate.IsIncremental">IsIncremental</a></code></li>
<li><code><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate.OldValue" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate.OldValue">OldValue</a></code></li>
<li><code><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate.OnStart" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate.OnStart">OnStart</a></code></li>
<li><code><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate.SetValue" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate.SetValue">SetValue</a></code></li>
<li><code><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate.Size" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate.Size">Size</a></code></li>
<li><code><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate.Start" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate.Start">Start</a></code></li>
<li><code><a title="pywrapcp.SequenceVarLocalSearchOperatorTemplate.Value" href="#pywrapcp.SequenceVarLocalSearchOperatorTemplate.Value">Value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.SolutionCollector" href="#pywrapcp.SolutionCollector">SolutionCollector</a></code></h4>
<ul class="two-column">
<li><code><a title="pywrapcp.SolutionCollector.Add" href="#pywrapcp.SolutionCollector.Add">Add</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.AddObjective" href="#pywrapcp.SolutionCollector.AddObjective">AddObjective</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.BackwardSequence" href="#pywrapcp.SolutionCollector.BackwardSequence">BackwardSequence</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.Branches" href="#pywrapcp.SolutionCollector.Branches">Branches</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.DebugString" href="#pywrapcp.SolutionCollector.DebugString">DebugString</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.DurationValue" href="#pywrapcp.SolutionCollector.DurationValue">DurationValue</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.EndValue" href="#pywrapcp.SolutionCollector.EndValue">EndValue</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.Failures" href="#pywrapcp.SolutionCollector.Failures">Failures</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.ForwardSequence" href="#pywrapcp.SolutionCollector.ForwardSequence">ForwardSequence</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.ObjectiveValue" href="#pywrapcp.SolutionCollector.ObjectiveValue">ObjectiveValue</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.PerformedValue" href="#pywrapcp.SolutionCollector.PerformedValue">PerformedValue</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.Solution" href="#pywrapcp.SolutionCollector.Solution">Solution</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.SolutionCount" href="#pywrapcp.SolutionCollector.SolutionCount">SolutionCount</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.StartValue" href="#pywrapcp.SolutionCollector.StartValue">StartValue</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.Unperformed" href="#pywrapcp.SolutionCollector.Unperformed">Unperformed</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.Value" href="#pywrapcp.SolutionCollector.Value">Value</a></code></li>
<li><code><a title="pywrapcp.SolutionCollector.WallTime" href="#pywrapcp.SolutionCollector.WallTime">WallTime</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.Solver" href="#pywrapcp.Solver">Solver</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.Solver.ASSIGN_CENTER_VALUE" href="#pywrapcp.Solver.ASSIGN_CENTER_VALUE">ASSIGN_CENTER_VALUE</a></code></li>
<li><code><a title="pywrapcp.Solver.ASSIGN_MAX_VALUE" href="#pywrapcp.Solver.ASSIGN_MAX_VALUE">ASSIGN_MAX_VALUE</a></code></li>
<li><code><a title="pywrapcp.Solver.ASSIGN_MIN_VALUE" href="#pywrapcp.Solver.ASSIGN_MIN_VALUE">ASSIGN_MIN_VALUE</a></code></li>
<li><code><a title="pywrapcp.Solver.ASSIGN_RANDOM_VALUE" href="#pywrapcp.Solver.ASSIGN_RANDOM_VALUE">ASSIGN_RANDOM_VALUE</a></code></li>
<li><code><a title="pywrapcp.Solver.AbsEquality" href="#pywrapcp.Solver.AbsEquality">AbsEquality</a></code></li>
<li><code><a title="pywrapcp.Solver.Accept" href="#pywrapcp.Solver.Accept">Accept</a></code></li>
<li><code><a title="pywrapcp.Solver.AcceptedNeighbors" href="#pywrapcp.Solver.AcceptedNeighbors">AcceptedNeighbors</a></code></li>
<li><code><a title="pywrapcp.Solver.Add" href="#pywrapcp.Solver.Add">Add</a></code></li>
<li><code><a title="pywrapcp.Solver.AddConstraint" href="#pywrapcp.Solver.AddConstraint">AddConstraint</a></code></li>
<li><code><a title="pywrapcp.Solver.AllDifferent" href="#pywrapcp.Solver.AllDifferent">AllDifferent</a></code></li>
<li><code><a title="pywrapcp.Solver.AllDifferentExcept" href="#pywrapcp.Solver.AllDifferentExcept">AllDifferentExcept</a></code></li>
<li><code><a title="pywrapcp.Solver.AllSolutionCollector" href="#pywrapcp.Solver.AllSolutionCollector">AllSolutionCollector</a></code></li>
<li><code><a title="pywrapcp.Solver.AllowedAssignments" href="#pywrapcp.Solver.AllowedAssignments">AllowedAssignments</a></code></li>
<li><code><a title="pywrapcp.Solver.AssignVariableValue" href="#pywrapcp.Solver.AssignVariableValue">AssignVariableValue</a></code></li>
<li><code><a title="pywrapcp.Solver.AssignVariableValueOrFail" href="#pywrapcp.Solver.AssignVariableValueOrFail">AssignVariableValueOrFail</a></code></li>
<li><code><a title="pywrapcp.Solver.AssignVariablesValues" href="#pywrapcp.Solver.AssignVariablesValues">AssignVariablesValues</a></code></li>
<li><code><a title="pywrapcp.Solver.Assignment" href="#pywrapcp.Solver.Assignment">Assignment</a></code></li>
<li><code><a title="pywrapcp.Solver.BestValueSolutionCollector" href="#pywrapcp.Solver.BestValueSolutionCollector">BestValueSolutionCollector</a></code></li>
<li><code><a title="pywrapcp.Solver.BetweenCt" href="#pywrapcp.Solver.BetweenCt">BetweenCt</a></code></li>
<li><code><a title="pywrapcp.Solver.BoolVar" href="#pywrapcp.Solver.BoolVar">BoolVar</a></code></li>
<li><code><a title="pywrapcp.Solver.Branches" href="#pywrapcp.Solver.Branches">Branches</a></code></li>
<li><code><a title="pywrapcp.Solver.BranchesLimit" href="#pywrapcp.Solver.BranchesLimit">BranchesLimit</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_FIRST_UNBOUND" href="#pywrapcp.Solver.CHOOSE_FIRST_UNBOUND">CHOOSE_FIRST_UNBOUND</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_HIGHEST_MAX" href="#pywrapcp.Solver.CHOOSE_HIGHEST_MAX">CHOOSE_HIGHEST_MAX</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_LOWEST_MIN" href="#pywrapcp.Solver.CHOOSE_LOWEST_MIN">CHOOSE_LOWEST_MIN</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_MAX_REGRET_ON_MIN" href="#pywrapcp.Solver.CHOOSE_MAX_REGRET_ON_MIN">CHOOSE_MAX_REGRET_ON_MIN</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_MAX_SIZE" href="#pywrapcp.Solver.CHOOSE_MAX_SIZE">CHOOSE_MAX_SIZE</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_MIN_SIZE" href="#pywrapcp.Solver.CHOOSE_MIN_SIZE">CHOOSE_MIN_SIZE</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_MIN_SIZE_HIGHEST_MAX" href="#pywrapcp.Solver.CHOOSE_MIN_SIZE_HIGHEST_MAX">CHOOSE_MIN_SIZE_HIGHEST_MAX</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_MIN_SIZE_HIGHEST_MIN" href="#pywrapcp.Solver.CHOOSE_MIN_SIZE_HIGHEST_MIN">CHOOSE_MIN_SIZE_HIGHEST_MIN</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_MIN_SIZE_LOWEST_MAX" href="#pywrapcp.Solver.CHOOSE_MIN_SIZE_LOWEST_MAX">CHOOSE_MIN_SIZE_LOWEST_MAX</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_MIN_SIZE_LOWEST_MIN" href="#pywrapcp.Solver.CHOOSE_MIN_SIZE_LOWEST_MIN">CHOOSE_MIN_SIZE_LOWEST_MIN</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_MIN_SLACK_RANK_FORWARD" href="#pywrapcp.Solver.CHOOSE_MIN_SLACK_RANK_FORWARD">CHOOSE_MIN_SLACK_RANK_FORWARD</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_PATH" href="#pywrapcp.Solver.CHOOSE_PATH">CHOOSE_PATH</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_RANDOM" href="#pywrapcp.Solver.CHOOSE_RANDOM">CHOOSE_RANDOM</a></code></li>
<li><code><a title="pywrapcp.Solver.CHOOSE_RANDOM_RANK_FORWARD" href="#pywrapcp.Solver.CHOOSE_RANDOM_RANK_FORWARD">CHOOSE_RANDOM_RANK_FORWARD</a></code></li>
<li><code><a title="pywrapcp.Solver.CROSS" href="#pywrapcp.Solver.CROSS">CROSS</a></code></li>
<li><code><a title="pywrapcp.Solver.CheckAssignment" href="#pywrapcp.Solver.CheckAssignment">CheckAssignment</a></code></li>
<li><code><a title="pywrapcp.Solver.CheckConstraint" href="#pywrapcp.Solver.CheckConstraint">CheckConstraint</a></code></li>
<li><code><a title="pywrapcp.Solver.Circuit" href="#pywrapcp.Solver.Circuit">Circuit</a></code></li>
<li><code><a title="pywrapcp.Solver.ClosureDemon" href="#pywrapcp.Solver.ClosureDemon">ClosureDemon</a></code></li>
<li><code><a title="pywrapcp.Solver.Compose" href="#pywrapcp.Solver.Compose">Compose</a></code></li>
<li><code><a title="pywrapcp.Solver.ConcatenateOperators" href="#pywrapcp.Solver.ConcatenateOperators">ConcatenateOperators</a></code></li>
<li><code><a title="pywrapcp.Solver.ConditionalExpression" href="#pywrapcp.Solver.ConditionalExpression">ConditionalExpression</a></code></li>
<li><code><a title="pywrapcp.Solver.ConstantRestart" href="#pywrapcp.Solver.ConstantRestart">ConstantRestart</a></code></li>
<li><code><a title="pywrapcp.Solver.ConstraintAdder" href="#pywrapcp.Solver.ConstraintAdder">ConstraintAdder</a></code></li>
<li><code><a title="pywrapcp.Solver.ConstraintInitialPropagateCallback" href="#pywrapcp.Solver.ConstraintInitialPropagateCallback">ConstraintInitialPropagateCallback</a></code></li>
<li><code><a title="pywrapcp.Solver.Constraints" href="#pywrapcp.Solver.Constraints">Constraints</a></code></li>
<li><code><a title="pywrapcp.Solver.ConvexPiecewiseExpr" href="#pywrapcp.Solver.ConvexPiecewiseExpr">ConvexPiecewiseExpr</a></code></li>
<li><code><a title="pywrapcp.Solver.Count" href="#pywrapcp.Solver.Count">Count</a></code></li>
<li><code><a title="pywrapcp.Solver.Cover" href="#pywrapcp.Solver.Cover">Cover</a></code></li>
<li><code><a title="pywrapcp.Solver.Cumulative" href="#pywrapcp.Solver.Cumulative">Cumulative</a></code></li>
<li><code><a title="pywrapcp.Solver.CustomLimit" href="#pywrapcp.Solver.CustomLimit">CustomLimit</a></code></li>
<li><code><a title="pywrapcp.Solver.DECREMENT" href="#pywrapcp.Solver.DECREMENT">DECREMENT</a></code></li>
<li><code><a title="pywrapcp.Solver.DELAYED_PRIORITY" href="#pywrapcp.Solver.DELAYED_PRIORITY">DELAYED_PRIORITY</a></code></li>
<li><code><a title="pywrapcp.Solver.Decision" href="#pywrapcp.Solver.Decision">Decision</a></code></li>
<li><code><a title="pywrapcp.Solver.DecisionBuilderFromAssignment" href="#pywrapcp.Solver.DecisionBuilderFromAssignment">DecisionBuilderFromAssignment</a></code></li>
<li><code><a title="pywrapcp.Solver.DefaultPhase" href="#pywrapcp.Solver.DefaultPhase">DefaultPhase</a></code></li>
<li><code><a title="pywrapcp.Solver.DefaultSolverParameters" href="#pywrapcp.Solver.DefaultSolverParameters">DefaultSolverParameters</a></code></li>
<li><code><a title="pywrapcp.Solver.DelayedConstraintInitialPropagateCallback" href="#pywrapcp.Solver.DelayedConstraintInitialPropagateCallback">DelayedConstraintInitialPropagateCallback</a></code></li>
<li><code><a title="pywrapcp.Solver.DelayedPathCumul" href="#pywrapcp.Solver.DelayedPathCumul">DelayedPathCumul</a></code></li>
<li><code><a title="pywrapcp.Solver.Deviation" href="#pywrapcp.Solver.Deviation">Deviation</a></code></li>
<li><code><a title="pywrapcp.Solver.DisjunctiveConstraint" href="#pywrapcp.Solver.DisjunctiveConstraint">DisjunctiveConstraint</a></code></li>
<li><code><a title="pywrapcp.Solver.Distribute" href="#pywrapcp.Solver.Distribute">Distribute</a></code></li>
<li><code><a title="pywrapcp.Solver.EQ" href="#pywrapcp.Solver.EQ">EQ</a></code></li>
<li><code><a title="pywrapcp.Solver.EXCHANGE" href="#pywrapcp.Solver.EXCHANGE">EXCHANGE</a></code></li>
<li><code><a title="pywrapcp.Solver.EXTENDEDSWAPACTIVE" href="#pywrapcp.Solver.EXTENDEDSWAPACTIVE">EXTENDEDSWAPACTIVE</a></code></li>
<li><code><a title="pywrapcp.Solver.Element" href="#pywrapcp.Solver.Element">Element</a></code></li>
<li><code><a title="pywrapcp.Solver.ElementEquality" href="#pywrapcp.Solver.ElementEquality">ElementEquality</a></code></li>
<li><code><a title="pywrapcp.Solver.ElementFunction" href="#pywrapcp.Solver.ElementFunction">ElementFunction</a></code></li>
<li><code><a title="pywrapcp.Solver.EndSearch" href="#pywrapcp.Solver.EndSearch">EndSearch</a></code></li>
<li><code><a title="pywrapcp.Solver.EvalEvalStrPhase" href="#pywrapcp.Solver.EvalEvalStrPhase">EvalEvalStrPhase</a></code></li>
<li><code><a title="pywrapcp.Solver.EvalEvalStrTieBreakPhase" href="#pywrapcp.Solver.EvalEvalStrTieBreakPhase">EvalEvalStrTieBreakPhase</a></code></li>
<li><code><a title="pywrapcp.Solver.FULLPATHLNS" href="#pywrapcp.Solver.FULLPATHLNS">FULLPATHLNS</a></code></li>
<li><code><a title="pywrapcp.Solver.Fail" href="#pywrapcp.Solver.Fail">Fail</a></code></li>
<li><code><a title="pywrapcp.Solver.FailDecision" href="#pywrapcp.Solver.FailDecision">FailDecision</a></code></li>
<li><code><a title="pywrapcp.Solver.FailStamp" href="#pywrapcp.Solver.FailStamp">FailStamp</a></code></li>
<li><code><a title="pywrapcp.Solver.Failures" href="#pywrapcp.Solver.Failures">Failures</a></code></li>
<li><code><a title="pywrapcp.Solver.FailuresLimit" href="#pywrapcp.Solver.FailuresLimit">FailuresLimit</a></code></li>
<li><code><a title="pywrapcp.Solver.FalseConstraint" href="#pywrapcp.Solver.FalseConstraint">FalseConstraint</a></code></li>
<li><code><a title="pywrapcp.Solver.FinishCurrentSearch" href="#pywrapcp.Solver.FinishCurrentSearch">FinishCurrentSearch</a></code></li>
<li><code><a title="pywrapcp.Solver.FirstSolutionCollector" href="#pywrapcp.Solver.FirstSolutionCollector">FirstSolutionCollector</a></code></li>
<li><code><a title="pywrapcp.Solver.FixedDurationEndSyncedOnEndIntervalVar" href="#pywrapcp.Solver.FixedDurationEndSyncedOnEndIntervalVar">FixedDurationEndSyncedOnEndIntervalVar</a></code></li>
<li><code><a title="pywrapcp.Solver.FixedDurationEndSyncedOnStartIntervalVar" href="#pywrapcp.Solver.FixedDurationEndSyncedOnStartIntervalVar">FixedDurationEndSyncedOnStartIntervalVar</a></code></li>
<li><code><a title="pywrapcp.Solver.FixedDurationIntervalVar" href="#pywrapcp.Solver.FixedDurationIntervalVar">FixedDurationIntervalVar</a></code></li>
<li><code><a title="pywrapcp.Solver.FixedDurationStartSyncedOnEndIntervalVar" href="#pywrapcp.Solver.FixedDurationStartSyncedOnEndIntervalVar">FixedDurationStartSyncedOnEndIntervalVar</a></code></li>
<li><code><a title="pywrapcp.Solver.FixedDurationStartSyncedOnStartIntervalVar" href="#pywrapcp.Solver.FixedDurationStartSyncedOnStartIntervalVar">FixedDurationStartSyncedOnStartIntervalVar</a></code></li>
<li><code><a title="pywrapcp.Solver.FixedInterval" href="#pywrapcp.Solver.FixedInterval">FixedInterval</a></code></li>
<li><code><a title="pywrapcp.Solver.GE" href="#pywrapcp.Solver.GE">GE</a></code></li>
<li><code><a title="pywrapcp.Solver.GuidedLocalSearch" href="#pywrapcp.Solver.GuidedLocalSearch">GuidedLocalSearch</a></code></li>
<li><code><a title="pywrapcp.Solver.INCREMENT" href="#pywrapcp.Solver.INCREMENT">INCREMENT</a></code></li>
<li><code><a title="pywrapcp.Solver.INTERVAL_DEFAULT" href="#pywrapcp.Solver.INTERVAL_DEFAULT">INTERVAL_DEFAULT</a></code></li>
<li><code><a title="pywrapcp.Solver.INTERVAL_SET_TIMES_BACKWARD" href="#pywrapcp.Solver.INTERVAL_SET_TIMES_BACKWARD">INTERVAL_SET_TIMES_BACKWARD</a></code></li>
<li><code><a title="pywrapcp.Solver.INTERVAL_SET_TIMES_FORWARD" href="#pywrapcp.Solver.INTERVAL_SET_TIMES_FORWARD">INTERVAL_SET_TIMES_FORWARD</a></code></li>
<li><code><a title="pywrapcp.Solver.INTERVAL_SIMPLE" href="#pywrapcp.Solver.INTERVAL_SIMPLE">INTERVAL_SIMPLE</a></code></li>
<li><code><a title="pywrapcp.Solver.INT_VALUE_DEFAULT" href="#pywrapcp.Solver.INT_VALUE_DEFAULT">INT_VALUE_DEFAULT</a></code></li>
<li><code><a title="pywrapcp.Solver.INT_VALUE_SIMPLE" href="#pywrapcp.Solver.INT_VALUE_SIMPLE">INT_VALUE_SIMPLE</a></code></li>
<li><code><a title="pywrapcp.Solver.INT_VAR_DEFAULT" href="#pywrapcp.Solver.INT_VAR_DEFAULT">INT_VAR_DEFAULT</a></code></li>
<li><code><a title="pywrapcp.Solver.INT_VAR_SIMPLE" href="#pywrapcp.Solver.INT_VAR_SIMPLE">INT_VAR_SIMPLE</a></code></li>
<li><code><a title="pywrapcp.Solver.IndexExpression" href="#pywrapcp.Solver.IndexExpression">IndexExpression</a></code></li>
<li><code><a title="pywrapcp.Solver.IndexOfConstraint" href="#pywrapcp.Solver.IndexOfConstraint">IndexOfConstraint</a></code></li>
<li><code><a title="pywrapcp.Solver.IntConst" href="#pywrapcp.Solver.IntConst">IntConst</a></code></li>
<li><code><a title="pywrapcp.Solver.IntVar" href="#pywrapcp.Solver.IntVar">IntVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IntervalRelaxedMax" href="#pywrapcp.Solver.IntervalRelaxedMax">IntervalRelaxedMax</a></code></li>
<li><code><a title="pywrapcp.Solver.IntervalRelaxedMin" href="#pywrapcp.Solver.IntervalRelaxedMin">IntervalRelaxedMin</a></code></li>
<li><code><a title="pywrapcp.Solver.IntervalVar" href="#pywrapcp.Solver.IntervalVar">IntervalVar</a></code></li>
<li><code><a title="pywrapcp.Solver.InversePermutationConstraint" href="#pywrapcp.Solver.InversePermutationConstraint">InversePermutationConstraint</a></code></li>
<li><code><a title="pywrapcp.Solver.IsBetweenCt" href="#pywrapcp.Solver.IsBetweenCt">IsBetweenCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsBetweenVar" href="#pywrapcp.Solver.IsBetweenVar">IsBetweenVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IsDifferentCstCt" href="#pywrapcp.Solver.IsDifferentCstCt">IsDifferentCstCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsDifferentCstVar" href="#pywrapcp.Solver.IsDifferentCstVar">IsDifferentCstVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IsDifferentCt" href="#pywrapcp.Solver.IsDifferentCt">IsDifferentCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsDifferentVar" href="#pywrapcp.Solver.IsDifferentVar">IsDifferentVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IsEqualCstCt" href="#pywrapcp.Solver.IsEqualCstCt">IsEqualCstCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsEqualCstVar" href="#pywrapcp.Solver.IsEqualCstVar">IsEqualCstVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IsEqualCt" href="#pywrapcp.Solver.IsEqualCt">IsEqualCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsEqualVar" href="#pywrapcp.Solver.IsEqualVar">IsEqualVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IsGreaterCstCt" href="#pywrapcp.Solver.IsGreaterCstCt">IsGreaterCstCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsGreaterCstVar" href="#pywrapcp.Solver.IsGreaterCstVar">IsGreaterCstVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IsGreaterCt" href="#pywrapcp.Solver.IsGreaterCt">IsGreaterCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsGreaterOrEqualCstCt" href="#pywrapcp.Solver.IsGreaterOrEqualCstCt">IsGreaterOrEqualCstCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsGreaterOrEqualCstVar" href="#pywrapcp.Solver.IsGreaterOrEqualCstVar">IsGreaterOrEqualCstVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IsGreaterOrEqualCt" href="#pywrapcp.Solver.IsGreaterOrEqualCt">IsGreaterOrEqualCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsGreaterOrEqualVar" href="#pywrapcp.Solver.IsGreaterOrEqualVar">IsGreaterOrEqualVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IsGreaterVar" href="#pywrapcp.Solver.IsGreaterVar">IsGreaterVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IsLessCstCt" href="#pywrapcp.Solver.IsLessCstCt">IsLessCstCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsLessCstVar" href="#pywrapcp.Solver.IsLessCstVar">IsLessCstVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IsLessCt" href="#pywrapcp.Solver.IsLessCt">IsLessCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsLessOrEqualCstCt" href="#pywrapcp.Solver.IsLessOrEqualCstCt">IsLessOrEqualCstCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsLessOrEqualCstVar" href="#pywrapcp.Solver.IsLessOrEqualCstVar">IsLessOrEqualCstVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IsLessOrEqualCt" href="#pywrapcp.Solver.IsLessOrEqualCt">IsLessOrEqualCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsLessOrEqualVar" href="#pywrapcp.Solver.IsLessOrEqualVar">IsLessOrEqualVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IsLessVar" href="#pywrapcp.Solver.IsLessVar">IsLessVar</a></code></li>
<li><code><a title="pywrapcp.Solver.IsMemberCt" href="#pywrapcp.Solver.IsMemberCt">IsMemberCt</a></code></li>
<li><code><a title="pywrapcp.Solver.IsMemberVar" href="#pywrapcp.Solver.IsMemberVar">IsMemberVar</a></code></li>
<li><code><a title="pywrapcp.Solver.LE" href="#pywrapcp.Solver.LE">LE</a></code></li>
<li><code><a title="pywrapcp.Solver.LastSolutionCollector" href="#pywrapcp.Solver.LastSolutionCollector">LastSolutionCollector</a></code></li>
<li><code><a title="pywrapcp.Solver.LexicalLess" href="#pywrapcp.Solver.LexicalLess">LexicalLess</a></code></li>
<li><code><a title="pywrapcp.Solver.LexicalLessOrEqual" href="#pywrapcp.Solver.LexicalLessOrEqual">LexicalLessOrEqual</a></code></li>
<li><code><a title="pywrapcp.Solver.Limit" href="#pywrapcp.Solver.Limit">Limit</a></code></li>
<li><code><a title="pywrapcp.Solver.LocalSearchPhase" href="#pywrapcp.Solver.LocalSearchPhase">LocalSearchPhase</a></code></li>
<li><code><a title="pywrapcp.Solver.LocalSearchPhaseParameters" href="#pywrapcp.Solver.LocalSearchPhaseParameters">LocalSearchPhaseParameters</a></code></li>
<li><code><a title="pywrapcp.Solver.LocalSearchProfile" href="#pywrapcp.Solver.LocalSearchProfile">LocalSearchProfile</a></code></li>
<li><code><a title="pywrapcp.Solver.LubyRestart" href="#pywrapcp.Solver.LubyRestart">LubyRestart</a></code></li>
<li><code><a title="pywrapcp.Solver.MAKEACTIVE" href="#pywrapcp.Solver.MAKEACTIVE">MAKEACTIVE</a></code></li>
<li><code><a title="pywrapcp.Solver.MAKECHAININACTIVE" href="#pywrapcp.Solver.MAKECHAININACTIVE">MAKECHAININACTIVE</a></code></li>
<li><code><a title="pywrapcp.Solver.MAKEINACTIVE" href="#pywrapcp.Solver.MAKEINACTIVE">MAKEINACTIVE</a></code></li>
<li><code><a title="pywrapcp.Solver.Max" href="#pywrapcp.Solver.Max">Max</a></code></li>
<li><code><a title="pywrapcp.Solver.MaxEquality" href="#pywrapcp.Solver.MaxEquality">MaxEquality</a></code></li>
<li><code><a title="pywrapcp.Solver.Maximize" href="#pywrapcp.Solver.Maximize">Maximize</a></code></li>
<li><code><a title="pywrapcp.Solver.MemberCt" href="#pywrapcp.Solver.MemberCt">MemberCt</a></code></li>
<li><code><a title="pywrapcp.Solver.MemoryUsage" href="#pywrapcp.Solver.MemoryUsage">MemoryUsage</a></code></li>
<li><code><a title="pywrapcp.Solver.Min" href="#pywrapcp.Solver.Min">Min</a></code></li>
<li><code><a title="pywrapcp.Solver.MinEquality" href="#pywrapcp.Solver.MinEquality">MinEquality</a></code></li>
<li><code><a title="pywrapcp.Solver.Minimize" href="#pywrapcp.Solver.Minimize">Minimize</a></code></li>
<li><code><a title="pywrapcp.Solver.MirrorInterval" href="#pywrapcp.Solver.MirrorInterval">MirrorInterval</a></code></li>
<li><code><a title="pywrapcp.Solver.MonotonicElement" href="#pywrapcp.Solver.MonotonicElement">MonotonicElement</a></code></li>
<li><code><a title="pywrapcp.Solver.MoveTowardTargetOperator" href="#pywrapcp.Solver.MoveTowardTargetOperator">MoveTowardTargetOperator</a></code></li>
<li><code><a title="pywrapcp.Solver.NORMAL_PRIORITY" href="#pywrapcp.Solver.NORMAL_PRIORITY">NORMAL_PRIORITY</a></code></li>
<li><code><a title="pywrapcp.Solver.NeighborhoodLimit" href="#pywrapcp.Solver.NeighborhoodLimit">NeighborhoodLimit</a></code></li>
<li><code><a title="pywrapcp.Solver.NestedOptimize" href="#pywrapcp.Solver.NestedOptimize">NestedOptimize</a></code></li>
<li><code><a title="pywrapcp.Solver.NewSearch" href="#pywrapcp.Solver.NewSearch">NewSearch</a></code></li>
<li><code><a title="pywrapcp.Solver.NextSolution" href="#pywrapcp.Solver.NextSolution">NextSolution</a></code></li>
<li><code><a title="pywrapcp.Solver.NonOverlappingBoxesConstraint" href="#pywrapcp.Solver.NonOverlappingBoxesConstraint">NonOverlappingBoxesConstraint</a></code></li>
<li><code><a title="pywrapcp.Solver.NotMemberCt" href="#pywrapcp.Solver.NotMemberCt">NotMemberCt</a></code></li>
<li><code><a title="pywrapcp.Solver.NullIntersect" href="#pywrapcp.Solver.NullIntersect">NullIntersect</a></code></li>
<li><code><a title="pywrapcp.Solver.NullIntersectExcept" href="#pywrapcp.Solver.NullIntersectExcept">NullIntersectExcept</a></code></li>
<li><code><a title="pywrapcp.Solver.OROPT" href="#pywrapcp.Solver.OROPT">OROPT</a></code></li>
<li><code><a title="pywrapcp.Solver.Operator" href="#pywrapcp.Solver.Operator">Operator</a></code></li>
<li><code><a title="pywrapcp.Solver.Optimize" href="#pywrapcp.Solver.Optimize">Optimize</a></code></li>
<li><code><a title="pywrapcp.Solver.PATHLNS" href="#pywrapcp.Solver.PATHLNS">PATHLNS</a></code></li>
<li><code><a title="pywrapcp.Solver.Pack" href="#pywrapcp.Solver.Pack">Pack</a></code></li>
<li><code><a title="pywrapcp.Solver.Parameters" href="#pywrapcp.Solver.Parameters">Parameters</a></code></li>
<li><code><a title="pywrapcp.Solver.PathCumul" href="#pywrapcp.Solver.PathCumul">PathCumul</a></code></li>
<li><code><a title="pywrapcp.Solver.Phase" href="#pywrapcp.Solver.Phase">Phase</a></code></li>
<li><code><a title="pywrapcp.Solver.PrintModelVisitor" href="#pywrapcp.Solver.PrintModelVisitor">PrintModelVisitor</a></code></li>
<li><code><a title="pywrapcp.Solver.RELOCATE" href="#pywrapcp.Solver.RELOCATE">RELOCATE</a></code></li>
<li><code><a title="pywrapcp.Solver.Rand32" href="#pywrapcp.Solver.Rand32">Rand32</a></code></li>
<li><code><a title="pywrapcp.Solver.Rand64" href="#pywrapcp.Solver.Rand64">Rand64</a></code></li>
<li><code><a title="pywrapcp.Solver.RandomConcatenateOperators" href="#pywrapcp.Solver.RandomConcatenateOperators">RandomConcatenateOperators</a></code></li>
<li><code><a title="pywrapcp.Solver.RandomLnsOperator" href="#pywrapcp.Solver.RandomLnsOperator">RandomLnsOperator</a></code></li>
<li><code><a title="pywrapcp.Solver.RankFirstInterval" href="#pywrapcp.Solver.RankFirstInterval">RankFirstInterval</a></code></li>
<li><code><a title="pywrapcp.Solver.RankLastInterval" href="#pywrapcp.Solver.RankLastInterval">RankLastInterval</a></code></li>
<li><code><a title="pywrapcp.Solver.ReSeed" href="#pywrapcp.Solver.ReSeed">ReSeed</a></code></li>
<li><code><a title="pywrapcp.Solver.RestartCurrentSearch" href="#pywrapcp.Solver.RestartCurrentSearch">RestartCurrentSearch</a></code></li>
<li><code><a title="pywrapcp.Solver.RestartSearch" href="#pywrapcp.Solver.RestartSearch">RestartSearch</a></code></li>
<li><code><a title="pywrapcp.Solver.RestoreAssignment" href="#pywrapcp.Solver.RestoreAssignment">RestoreAssignment</a></code></li>
<li><code><a title="pywrapcp.Solver.SEQUENCE_DEFAULT" href="#pywrapcp.Solver.SEQUENCE_DEFAULT">SEQUENCE_DEFAULT</a></code></li>
<li><code><a title="pywrapcp.Solver.SEQUENCE_SIMPLE" href="#pywrapcp.Solver.SEQUENCE_SIMPLE">SEQUENCE_SIMPLE</a></code></li>
<li><code><a title="pywrapcp.Solver.SIMPLELNS" href="#pywrapcp.Solver.SIMPLELNS">SIMPLELNS</a></code></li>
<li><code><a title="pywrapcp.Solver.SPLIT_LOWER_HALF" href="#pywrapcp.Solver.SPLIT_LOWER_HALF">SPLIT_LOWER_HALF</a></code></li>
<li><code><a title="pywrapcp.Solver.SPLIT_UPPER_HALF" href="#pywrapcp.Solver.SPLIT_UPPER_HALF">SPLIT_UPPER_HALF</a></code></li>
<li><code><a title="pywrapcp.Solver.SWAPACTIVE" href="#pywrapcp.Solver.SWAPACTIVE">SWAPACTIVE</a></code></li>
<li><code><a title="pywrapcp.Solver.ScalProd" href="#pywrapcp.Solver.ScalProd">ScalProd</a></code></li>
<li><code><a title="pywrapcp.Solver.ScalProdEquality" href="#pywrapcp.Solver.ScalProdEquality">ScalProdEquality</a></code></li>
<li><code><a title="pywrapcp.Solver.ScalProdGreaterOrEqual" href="#pywrapcp.Solver.ScalProdGreaterOrEqual">ScalProdGreaterOrEqual</a></code></li>
<li><code><a title="pywrapcp.Solver.ScalProdLessOrEqual" href="#pywrapcp.Solver.ScalProdLessOrEqual">ScalProdLessOrEqual</a></code></li>
<li><code><a title="pywrapcp.Solver.ScheduleOrExpedite" href="#pywrapcp.Solver.ScheduleOrExpedite">ScheduleOrExpedite</a></code></li>
<li><code><a title="pywrapcp.Solver.ScheduleOrPostpone" href="#pywrapcp.Solver.ScheduleOrPostpone">ScheduleOrPostpone</a></code></li>
<li><code><a title="pywrapcp.Solver.SearchDepth" href="#pywrapcp.Solver.SearchDepth">SearchDepth</a></code></li>
<li><code><a title="pywrapcp.Solver.SearchLeftDepth" href="#pywrapcp.Solver.SearchLeftDepth">SearchLeftDepth</a></code></li>
<li><code><a title="pywrapcp.Solver.SearchLog" href="#pywrapcp.Solver.SearchLog">SearchLog</a></code></li>
<li><code><a title="pywrapcp.Solver.SearchLogWithCallback" href="#pywrapcp.Solver.SearchLogWithCallback">SearchLogWithCallback</a></code></li>
<li><code><a title="pywrapcp.Solver.SearchTrace" href="#pywrapcp.Solver.SearchTrace">SearchTrace</a></code></li>
<li><code><a title="pywrapcp.Solver.SemiContinuousExpr" href="#pywrapcp.Solver.SemiContinuousExpr">SemiContinuousExpr</a></code></li>
<li><code><a title="pywrapcp.Solver.ShouldFail" href="#pywrapcp.Solver.ShouldFail">ShouldFail</a></code></li>
<li><code><a title="pywrapcp.Solver.SimulatedAnnealing" href="#pywrapcp.Solver.SimulatedAnnealing">SimulatedAnnealing</a></code></li>
<li><code><a title="pywrapcp.Solver.Solutions" href="#pywrapcp.Solver.Solutions">Solutions</a></code></li>
<li><code><a title="pywrapcp.Solver.SolutionsLimit" href="#pywrapcp.Solver.SolutionsLimit">SolutionsLimit</a></code></li>
<li><code><a title="pywrapcp.Solver.Solve" href="#pywrapcp.Solver.Solve">Solve</a></code></li>
<li><code><a title="pywrapcp.Solver.SolveAndCommit" href="#pywrapcp.Solver.SolveAndCommit">SolveAndCommit</a></code></li>
<li><code><a title="pywrapcp.Solver.SolveDepth" href="#pywrapcp.Solver.SolveDepth">SolveDepth</a></code></li>
<li><code><a title="pywrapcp.Solver.SolveOnce" href="#pywrapcp.Solver.SolveOnce">SolveOnce</a></code></li>
<li><code><a title="pywrapcp.Solver.SortingConstraint" href="#pywrapcp.Solver.SortingConstraint">SortingConstraint</a></code></li>
<li><code><a title="pywrapcp.Solver.SplitVariableDomain" href="#pywrapcp.Solver.SplitVariableDomain">SplitVariableDomain</a></code></li>
<li><code><a title="pywrapcp.Solver.Stamp" href="#pywrapcp.Solver.Stamp">Stamp</a></code></li>
<li><code><a title="pywrapcp.Solver.StatisticsModelVisitor" href="#pywrapcp.Solver.StatisticsModelVisitor">StatisticsModelVisitor</a></code></li>
<li><code><a title="pywrapcp.Solver.StoreAssignment" href="#pywrapcp.Solver.StoreAssignment">StoreAssignment</a></code></li>
<li><code><a title="pywrapcp.Solver.SubCircuit" href="#pywrapcp.Solver.SubCircuit">SubCircuit</a></code></li>
<li><code><a title="pywrapcp.Solver.Sum" href="#pywrapcp.Solver.Sum">Sum</a></code></li>
<li><code><a title="pywrapcp.Solver.SumEquality" href="#pywrapcp.Solver.SumEquality">SumEquality</a></code></li>
<li><code><a title="pywrapcp.Solver.SumGreaterOrEqual" href="#pywrapcp.Solver.SumGreaterOrEqual">SumGreaterOrEqual</a></code></li>
<li><code><a title="pywrapcp.Solver.SumLessOrEqual" href="#pywrapcp.Solver.SumLessOrEqual">SumLessOrEqual</a></code></li>
<li><code><a title="pywrapcp.Solver.SumObjectiveFilter" href="#pywrapcp.Solver.SumObjectiveFilter">SumObjectiveFilter</a></code></li>
<li><code><a title="pywrapcp.Solver.TWOOPT" href="#pywrapcp.Solver.TWOOPT">TWOOPT</a></code></li>
<li><code><a title="pywrapcp.Solver.TabuSearch" href="#pywrapcp.Solver.TabuSearch">TabuSearch</a></code></li>
<li><code><a title="pywrapcp.Solver.TemporalDisjunction" href="#pywrapcp.Solver.TemporalDisjunction">TemporalDisjunction</a></code></li>
<li><code><a title="pywrapcp.Solver.TimeLimit" href="#pywrapcp.Solver.TimeLimit">TimeLimit</a></code></li>
<li><code><a title="pywrapcp.Solver.TransitionConstraint" href="#pywrapcp.Solver.TransitionConstraint">TransitionConstraint</a></code></li>
<li><code><a title="pywrapcp.Solver.TreeNoCycle" href="#pywrapcp.Solver.TreeNoCycle">TreeNoCycle</a></code></li>
<li><code><a title="pywrapcp.Solver.TrueConstraint" href="#pywrapcp.Solver.TrueConstraint">TrueConstraint</a></code></li>
<li><code><a title="pywrapcp.Solver.Try" href="#pywrapcp.Solver.Try">Try</a></code></li>
<li><code><a title="pywrapcp.Solver.UNACTIVELNS" href="#pywrapcp.Solver.UNACTIVELNS">UNACTIVELNS</a></code></li>
<li><code><a title="pywrapcp.Solver.VAR_PRIORITY" href="#pywrapcp.Solver.VAR_PRIORITY">VAR_PRIORITY</a></code></li>
<li><code><a title="pywrapcp.Solver.VarEvalValEvalPhase" href="#pywrapcp.Solver.VarEvalValEvalPhase">VarEvalValEvalPhase</a></code></li>
<li><code><a title="pywrapcp.Solver.VarEvalValEvalTieBreakPhase" href="#pywrapcp.Solver.VarEvalValEvalTieBreakPhase">VarEvalValEvalTieBreakPhase</a></code></li>
<li><code><a title="pywrapcp.Solver.VarEvalValStrPhase" href="#pywrapcp.Solver.VarEvalValStrPhase">VarEvalValStrPhase</a></code></li>
<li><code><a title="pywrapcp.Solver.VarStrValEvalPhase" href="#pywrapcp.Solver.VarStrValEvalPhase">VarStrValEvalPhase</a></code></li>
<li><code><a title="pywrapcp.Solver.VarStrValEvalTieBreakPhase" href="#pywrapcp.Solver.VarStrValEvalTieBreakPhase">VarStrValEvalTieBreakPhase</a></code></li>
<li><code><a title="pywrapcp.Solver.VariableGreaterOrEqualValue" href="#pywrapcp.Solver.VariableGreaterOrEqualValue">VariableGreaterOrEqualValue</a></code></li>
<li><code><a title="pywrapcp.Solver.VariableLessOrEqualValue" href="#pywrapcp.Solver.VariableLessOrEqualValue">VariableLessOrEqualValue</a></code></li>
<li><code><a title="pywrapcp.Solver.WallTime" href="#pywrapcp.Solver.WallTime">WallTime</a></code></li>
<li><code><a title="pywrapcp.Solver.WeightedMaximize" href="#pywrapcp.Solver.WeightedMaximize">WeightedMaximize</a></code></li>
<li><code><a title="pywrapcp.Solver.WeightedMinimize" href="#pywrapcp.Solver.WeightedMinimize">WeightedMinimize</a></code></li>
<li><code><a title="pywrapcp.Solver.WeightedOptimize" href="#pywrapcp.Solver.WeightedOptimize">WeightedOptimize</a></code></li>
<li><code><a title="pywrapcp.Solver.thisown" href="#pywrapcp.Solver.thisown">thisown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.TypeIncompatibilityChecker" href="#pywrapcp.TypeIncompatibilityChecker">TypeIncompatibilityChecker</a></code></h4>
</li>
<li>
<h4><code><a title="pywrapcp.TypeRegulationsChecker" href="#pywrapcp.TypeRegulationsChecker">TypeRegulationsChecker</a></code></h4>
<ul class="">
<li><code><a title="pywrapcp.TypeRegulationsChecker.CheckVehicle" href="#pywrapcp.TypeRegulationsChecker.CheckVehicle">CheckVehicle</a></code></li>
<li><code><a title="pywrapcp.TypeRegulationsChecker.thisown" href="#pywrapcp.TypeRegulationsChecker.thisown">thisown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pywrapcp.TypeRegulationsConstraint" href="#pywrapcp.TypeRegulationsConstraint">TypeRegulationsConstraint</a></code></h4>
</li>
<li>
<h4><code><a title="pywrapcp.TypeRequirementChecker" href="#pywrapcp.TypeRequirementChecker">TypeRequirementChecker</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>