<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>OR-Tools</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="ortools.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">Google OR-Tools 7.7</span>
            </div>
        </div>
        <div id="content" style="width: 100%; overflow: hidden;">
        <div style="margin-left: 15px; margin-top: 5px; float: left; color: #145A32;">
        <h2>C++ Reference</h2>
        <ul>
          <li><a href="../cpp_algorithms/annotated.html">Algorithms</a></li>
          <li><a href="../cpp_sat/annotated.html">CP-SAT</a></li>
          <li><a href="../cpp_graph/annotated.html">Graph</a></li>
          <li><a href="../cpp_routing/annotated.html">Routing</a></li>
          <li><a href="../cpp_linear/annotated.html">Linear solver</a></li>
        </ul>
        </div>
        <div id="content">
            <div align="center">
                <h1 style="color: #145A32;">C++ Reference: Linear solver</h1>
            </div>
<!-- Generated by Doxygen 1.8.18 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceoperations__research.html">operations_research</a></li><li class="navelem"><a class="el" href="classoperations__research_1_1MPSolver.html">MPSolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classoperations__research_1_1MPSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MPSolver</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This mathematical programming (MP) solver class is the main class though which users build and solve problems. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00177">177</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a76c87990aabadd148304b95332a60ff8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8">OptimizationProblemType</a> { <br />
&#160;&#160;<a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8a21a919f23e61f3bdea7509c3887c888f">GLOP_LINEAR_PROGRAMMING</a> = 2, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8a83b85675904f261c34c280b2abdcd9ae">SCIP_MIXED_INTEGER_PROGRAMMING</a> = 3, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8ad183dc62c63346a3b984b93fbda0137a">CBC_MIXED_INTEGER_PROGRAMMING</a> = 5, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8a63c332dd969034f3c3086975a9e23b7e">BOP_INTEGER_PROGRAMMING</a> = 12, 
<br />
&#160;&#160;<a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8aa12b397b225ca43d143085b619706e18">SAT_INTEGER_PROGRAMMING</a> = 14
<br />
 }</td></tr>
<tr class="memdesc:a76c87990aabadd148304b95332a60ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of problems (LP or MIP) that will be solved and the underlying solver (GLOP, GLPK, CLP, CBC or SCIP) that will solve them.  <a href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8">More...</a><br /></td></tr>
<tr class="separator:a76c87990aabadd148304b95332a60ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573d479910e373f5d771d303e440587d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587d">ResultStatus</a> { <br />
&#160;&#160;<a class="el" href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587da2579881e7c83261bc21bafb5a5c92cad">OPTIMAL</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587da03f919221217f95d21a593a7120165e1">FEASIBLE</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587da2884fa43446c0cbc9c7a9b74d41d7483">INFEASIBLE</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587da6c65123d1b5b01632a477661055b01ef">UNBOUNDED</a>, 
<br />
&#160;&#160;<a class="el" href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587dadd7ccc352d727224d39519584ed37cd7">ABNORMAL</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587dae071e79c23f061c9dd00ee09519a0031">MODEL_INVALID</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587da0e6873a155f86a4695f463bf8601d05f">NOT_SOLVED</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:a573d479910e373f5d771d303e440587d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status of solving the problem.  <a href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587d">More...</a><br /></td></tr>
<tr class="separator:a573d479910e373f5d771d303e440587d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd922eb2bef96597c426557a8056f76d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#afd922eb2bef96597c426557a8056f76d">BasisStatus</a> { <br />
&#160;&#160;<a class="el" href="classoperations__research_1_1MPSolver.html#afd922eb2bef96597c426557a8056f76dacc62d1576546f3245237e1b232d838b6">FREE</a> = 0, 
<a class="el" href="classoperations__research_1_1MPSolver.html#afd922eb2bef96597c426557a8056f76da6745b95540b79aaa5ee98f7e128b6033">AT_LOWER_BOUND</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#afd922eb2bef96597c426557a8056f76da0d243399df954cc7c42a62953ca00aa2">AT_UPPER_BOUND</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#afd922eb2bef96597c426557a8056f76daaf36138ad9ba5562db2eaf2f7c6e18d0">FIXED_VALUE</a>, 
<br />
&#160;&#160;<a class="el" href="classoperations__research_1_1MPSolver.html#afd922eb2bef96597c426557a8056f76da13c45196813cb44e6e81e9c48a5ec1b4">BASIC</a>
<br />
 }</td></tr>
<tr class="memdesc:afd922eb2bef96597c426557a8056f76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: possible basis status values for a variable and the slack variable of a linear constraint.  <a href="classoperations__research_1_1MPSolver.html#afd922eb2bef96597c426557a8056f76d">More...</a><br /></td></tr>
<tr class="separator:afd922eb2bef96597c426557a8056f76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acdb0e5753d20e4d3ece49a0451d24c4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#acdb0e5753d20e4d3ece49a0451d24c4f">MPSolver</a> (const std::string &amp;name, <a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8">OptimizationProblemType</a> problem_type)</td></tr>
<tr class="memdesc:acdb0e5753d20e4d3ece49a0451d24c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a solver with the given name and underlying solver backend.  <a href="classoperations__research_1_1MPSolver.html#acdb0e5753d20e4d3ece49a0451d24c4f">More...</a><br /></td></tr>
<tr class="separator:acdb0e5753d20e4d3ece49a0451d24c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c4c6d71bb8379b15a21868e1e2d3fa"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a18c4c6d71bb8379b15a21868e1e2d3fa">~MPSolver</a> ()</td></tr>
<tr class="separator:a18c4c6d71bb8379b15a21868e1e2d3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29500cb9138fb0d96b2ed028d9253881"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a29500cb9138fb0d96b2ed028d9253881">IsMIP</a> () const</td></tr>
<tr class="separator:a29500cb9138fb0d96b2ed028d9253881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191cd9b1ba3e3c01a558a1f6c02a4429"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a191cd9b1ba3e3c01a558a1f6c02a4429">Name</a> () const</td></tr>
<tr class="memdesc:a191cd9b1ba3e3c01a558a1f6c02a4429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the model set at construction.  <a href="classoperations__research_1_1MPSolver.html#a191cd9b1ba3e3c01a558a1f6c02a4429">More...</a><br /></td></tr>
<tr class="separator:a191cd9b1ba3e3c01a558a1f6c02a4429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8250cf90d66d569534338248924469"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8">OptimizationProblemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aee8250cf90d66d569534338248924469">ProblemType</a> () const</td></tr>
<tr class="memdesc:aee8250cf90d66d569534338248924469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the optimization problem type set at construction.  <a href="classoperations__research_1_1MPSolver.html#aee8250cf90d66d569534338248924469">More...</a><br /></td></tr>
<tr class="separator:aee8250cf90d66d569534338248924469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71d36872f416feaa853788a7a7a7ef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aa71d36872f416feaa853788a7a7a7ef8">Clear</a> ()</td></tr>
<tr class="memdesc:aa71d36872f416feaa853788a7a7a7ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the objective (including the optimization direction), all variables and constraints.  <a href="classoperations__research_1_1MPSolver.html#aa71d36872f416feaa853788a7a7a7ef8">More...</a><br /></td></tr>
<tr class="separator:aa71d36872f416feaa853788a7a7a7ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3beb2afe4ae647674b054bf29290e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a9d3beb2afe4ae647674b054bf29290e2">NumVariables</a> () const</td></tr>
<tr class="memdesc:a9d3beb2afe4ae647674b054bf29290e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of variables.  <a href="classoperations__research_1_1MPSolver.html#a9d3beb2afe4ae647674b054bf29290e2">More...</a><br /></td></tr>
<tr class="separator:a9d3beb2afe4ae647674b054bf29290e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34caaebb9e2b365ef0ec449e870f5b5d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a34caaebb9e2b365ef0ec449e870f5b5d">variables</a> () const</td></tr>
<tr class="memdesc:a34caaebb9e2b365ef0ec449e870f5b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the array of variables handled by the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a>.  <a href="classoperations__research_1_1MPSolver.html#a34caaebb9e2b365ef0ec449e870f5b5d">More...</a><br /></td></tr>
<tr class="separator:a34caaebb9e2b365ef0ec449e870f5b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981cdf256aa33e518b8747c96bf1a9c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a981cdf256aa33e518b8747c96bf1a9c7">LookupVariableOrNull</a> (const std::string &amp;var_name) const</td></tr>
<tr class="memdesc:a981cdf256aa33e518b8747c96bf1a9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up a variable by name, and returns nullptr if it does not exist.  <a href="classoperations__research_1_1MPSolver.html#a981cdf256aa33e518b8747c96bf1a9c7">More...</a><br /></td></tr>
<tr class="separator:a981cdf256aa33e518b8747c96bf1a9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728f0121faaa95a451eaef6eb13e2242"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a728f0121faaa95a451eaef6eb13e2242">MakeVar</a> (double lb, double ub, bool integer, const std::string &amp;name)</td></tr>
<tr class="memdesc:a728f0121faaa95a451eaef6eb13e2242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a variable with the given bounds, integrality requirement and name.  <a href="classoperations__research_1_1MPSolver.html#a728f0121faaa95a451eaef6eb13e2242">More...</a><br /></td></tr>
<tr class="separator:a728f0121faaa95a451eaef6eb13e2242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae522890e16fd065100174a819558b461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ae522890e16fd065100174a819558b461">MakeNumVar</a> (double lb, double ub, const std::string &amp;name)</td></tr>
<tr class="memdesc:ae522890e16fd065100174a819558b461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a continuous variable.  <a href="classoperations__research_1_1MPSolver.html#ae522890e16fd065100174a819558b461">More...</a><br /></td></tr>
<tr class="separator:ae522890e16fd065100174a819558b461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b5ede96c77f6cfdd4f54325f384ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a33b5ede96c77f6cfdd4f54325f384ab7">MakeIntVar</a> (double lb, double ub, const std::string &amp;name)</td></tr>
<tr class="memdesc:a33b5ede96c77f6cfdd4f54325f384ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an integer variable.  <a href="classoperations__research_1_1MPSolver.html#a33b5ede96c77f6cfdd4f54325f384ab7">More...</a><br /></td></tr>
<tr class="separator:a33b5ede96c77f6cfdd4f54325f384ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2090dbd973eba8c24c4fa7b2714e4c44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a2090dbd973eba8c24c4fa7b2714e4c44">MakeBoolVar</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2090dbd973eba8c24c4fa7b2714e4c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a boolean variable.  <a href="classoperations__research_1_1MPSolver.html#a2090dbd973eba8c24c4fa7b2714e4c44">More...</a><br /></td></tr>
<tr class="separator:a2090dbd973eba8c24c4fa7b2714e4c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fd302d0082c74e6dea35ac59784847"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a66fd302d0082c74e6dea35ac59784847">MakeVarArray</a> (int nb, double lb, double ub, bool integer, const std::string &amp;name_prefix, std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *vars)</td></tr>
<tr class="memdesc:a66fd302d0082c74e6dea35ac59784847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of variables.  <a href="classoperations__research_1_1MPSolver.html#a66fd302d0082c74e6dea35ac59784847">More...</a><br /></td></tr>
<tr class="separator:a66fd302d0082c74e6dea35ac59784847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648a61e30b62b1c17ab1f49fe6c9ed8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a648a61e30b62b1c17ab1f49fe6c9ed8d">MakeNumVarArray</a> (int nb, double lb, double ub, const std::string &amp;name, std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *vars)</td></tr>
<tr class="memdesc:a648a61e30b62b1c17ab1f49fe6c9ed8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of continuous variables.  <a href="classoperations__research_1_1MPSolver.html#a648a61e30b62b1c17ab1f49fe6c9ed8d">More...</a><br /></td></tr>
<tr class="separator:a648a61e30b62b1c17ab1f49fe6c9ed8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9333144b7d28f68a7537b2ba19a1ba9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a9333144b7d28f68a7537b2ba19a1ba9b">MakeIntVarArray</a> (int nb, double lb, double ub, const std::string &amp;name, std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *vars)</td></tr>
<tr class="memdesc:a9333144b7d28f68a7537b2ba19a1ba9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of integer variables.  <a href="classoperations__research_1_1MPSolver.html#a9333144b7d28f68a7537b2ba19a1ba9b">More...</a><br /></td></tr>
<tr class="separator:a9333144b7d28f68a7537b2ba19a1ba9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200ccd114eb5057856c05501c2d4abe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a200ccd114eb5057856c05501c2d4abe5">MakeBoolVarArray</a> (int nb, const std::string &amp;name, std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *vars)</td></tr>
<tr class="memdesc:a200ccd114eb5057856c05501c2d4abe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of boolean variables.  <a href="classoperations__research_1_1MPSolver.html#a200ccd114eb5057856c05501c2d4abe5">More...</a><br /></td></tr>
<tr class="separator:a200ccd114eb5057856c05501c2d4abe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03666f2e70e42a9560aa9ce7416d2644"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a03666f2e70e42a9560aa9ce7416d2644">NumConstraints</a> () const</td></tr>
<tr class="memdesc:a03666f2e70e42a9560aa9ce7416d2644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraints.  <a href="classoperations__research_1_1MPSolver.html#a03666f2e70e42a9560aa9ce7416d2644">More...</a><br /></td></tr>
<tr class="separator:a03666f2e70e42a9560aa9ce7416d2644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff11cd513c803ba3f75f2f672f1cf6f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a5ff11cd513c803ba3f75f2f672f1cf6f">constraints</a> () const</td></tr>
<tr class="memdesc:a5ff11cd513c803ba3f75f2f672f1cf6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the array of constraints handled by the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a>.  <a href="classoperations__research_1_1MPSolver.html#a5ff11cd513c803ba3f75f2f672f1cf6f">More...</a><br /></td></tr>
<tr class="separator:a5ff11cd513c803ba3f75f2f672f1cf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf4c26107aac610a00471f41740b01e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#abbf4c26107aac610a00471f41740b01e">LookupConstraintOrNull</a> (const std::string &amp;constraint_name) const</td></tr>
<tr class="memdesc:abbf4c26107aac610a00471f41740b01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up a constraint by name, and returns nullptr if it does not exist.  <a href="classoperations__research_1_1MPSolver.html#abbf4c26107aac610a00471f41740b01e">More...</a><br /></td></tr>
<tr class="separator:abbf4c26107aac610a00471f41740b01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f97f44428bff07c2308b45bfb62223b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a0f97f44428bff07c2308b45bfb62223b">MakeRowConstraint</a> (double lb, double ub)</td></tr>
<tr class="memdesc:a0f97f44428bff07c2308b45bfb62223b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a linear constraint with given bounds.  <a href="classoperations__research_1_1MPSolver.html#a0f97f44428bff07c2308b45bfb62223b">More...</a><br /></td></tr>
<tr class="separator:a0f97f44428bff07c2308b45bfb62223b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60f33fbc8132eda10c296885625b7d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ab60f33fbc8132eda10c296885625b7d9">MakeRowConstraint</a> ()</td></tr>
<tr class="memdesc:ab60f33fbc8132eda10c296885625b7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a constraint with -infinity and +infinity bounds.  <a href="classoperations__research_1_1MPSolver.html#ab60f33fbc8132eda10c296885625b7d9">More...</a><br /></td></tr>
<tr class="separator:ab60f33fbc8132eda10c296885625b7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf8f81a46598a4ef20ae7674696c40d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a5cf8f81a46598a4ef20ae7674696c40d">MakeRowConstraint</a> (double lb, double ub, const std::string &amp;name)</td></tr>
<tr class="memdesc:a5cf8f81a46598a4ef20ae7674696c40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a named constraint with given bounds.  <a href="classoperations__research_1_1MPSolver.html#a5cf8f81a46598a4ef20ae7674696c40d">More...</a><br /></td></tr>
<tr class="separator:a5cf8f81a46598a4ef20ae7674696c40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee6dd214598834edf57d950333b11f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a2ee6dd214598834edf57d950333b11f7">MakeRowConstraint</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2ee6dd214598834edf57d950333b11f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a named constraint with -infinity and +infinity bounds.  <a href="classoperations__research_1_1MPSolver.html#a2ee6dd214598834edf57d950333b11f7">More...</a><br /></td></tr>
<tr class="separator:a2ee6dd214598834edf57d950333b11f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cd78bd7a418107a920ca2ee7710aa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a04cd78bd7a418107a920ca2ee7710aa7">MakeRowConstraint</a> (const <a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a> &amp;range)</td></tr>
<tr class="memdesc:a04cd78bd7a418107a920ca2ee7710aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a constraint owned by <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> enforcing: range.lower_bound() &lt;= range.linear_expr() &lt;= range.upper_bound()  <a href="classoperations__research_1_1MPSolver.html#a04cd78bd7a418107a920ca2ee7710aa7">More...</a><br /></td></tr>
<tr class="separator:a04cd78bd7a418107a920ca2ee7710aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5409af80c8d0d848fa354e5c8ea0b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#afc5409af80c8d0d848fa354e5c8ea0b0">MakeRowConstraint</a> (const <a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a> &amp;range, const std::string &amp;name)</td></tr>
<tr class="memdesc:afc5409af80c8d0d848fa354e5c8ea0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but also names the constraint.  <a href="classoperations__research_1_1MPSolver.html#afc5409af80c8d0d848fa354e5c8ea0b0">More...</a><br /></td></tr>
<tr class="separator:afc5409af80c8d0d848fa354e5c8ea0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5004489a36bc1393efa043044a63732f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classoperations__research_1_1MPObjective.html">MPObjective</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a5004489a36bc1393efa043044a63732f">Objective</a> () const</td></tr>
<tr class="memdesc:a5004489a36bc1393efa043044a63732f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the objective object.  <a href="classoperations__research_1_1MPSolver.html#a5004489a36bc1393efa043044a63732f">More...</a><br /></td></tr>
<tr class="separator:a5004489a36bc1393efa043044a63732f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226456dfb15300dd4e59d0bf80d0ce07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPObjective.html">MPObjective</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a226456dfb15300dd4e59d0bf80d0ce07">MutableObjective</a> ()</td></tr>
<tr class="memdesc:a226456dfb15300dd4e59d0bf80d0ce07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mutable objective object.  <a href="classoperations__research_1_1MPSolver.html#a226456dfb15300dd4e59d0bf80d0ce07">More...</a><br /></td></tr>
<tr class="separator:a226456dfb15300dd4e59d0bf80d0ce07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f55f5e7a62b45961982063ebc1e9945"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587d">ResultStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a9f55f5e7a62b45961982063ebc1e9945">Solve</a> ()</td></tr>
<tr class="memdesc:a9f55f5e7a62b45961982063ebc1e9945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the problem using the default parameter values.  <a href="classoperations__research_1_1MPSolver.html#a9f55f5e7a62b45961982063ebc1e9945">More...</a><br /></td></tr>
<tr class="separator:a9f55f5e7a62b45961982063ebc1e9945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2bb34f1712b9d7c36d75b1ec704563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587d">ResultStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aaa2bb34f1712b9d7c36d75b1ec704563">Solve</a> (const <a class="el" href="classoperations__research_1_1MPSolverParameters.html">MPSolverParameters</a> &amp;param)</td></tr>
<tr class="memdesc:aaa2bb34f1712b9d7c36d75b1ec704563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the problem using the specified parameter values.  <a href="classoperations__research_1_1MPSolver.html#aaa2bb34f1712b9d7c36d75b1ec704563">More...</a><br /></td></tr>
<tr class="separator:aaa2bb34f1712b9d7c36d75b1ec704563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa766a9aa802903bf7a6e5b8fb82c70c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aaa766a9aa802903bf7a6e5b8fb82c70c">Write</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:aaa766a9aa802903bf7a6e5b8fb82c70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the model using the solver internal write function.  <a href="classoperations__research_1_1MPSolver.html#aaa766a9aa802903bf7a6e5b8fb82c70c">More...</a><br /></td></tr>
<tr class="separator:aaa766a9aa802903bf7a6e5b8fb82c70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17a7a859c6e429296e55570c06337cf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ab17a7a859c6e429296e55570c06337cf">ComputeConstraintActivities</a> () const</td></tr>
<tr class="memdesc:ab17a7a859c6e429296e55570c06337cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: compute the "activities" of all constraints, which are the sums of their linear terms.  <a href="classoperations__research_1_1MPSolver.html#ab17a7a859c6e429296e55570c06337cf">More...</a><br /></td></tr>
<tr class="separator:ab17a7a859c6e429296e55570c06337cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c50b77c283c82d632f0dc605ceca3c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a2c50b77c283c82d632f0dc605ceca3c3">VerifySolution</a> (double tolerance, bool log_errors) const</td></tr>
<tr class="memdesc:a2c50b77c283c82d632f0dc605ceca3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: Verifies the <em>correctness</em> of the solution.  <a href="classoperations__research_1_1MPSolver.html#a2c50b77c283c82d632f0dc605ceca3c3">More...</a><br /></td></tr>
<tr class="separator:a2c50b77c283c82d632f0dc605ceca3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372de693ad40b3f42839c8ec6ac845f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a372de693ad40b3f42839c8ec6ac845f4">Reset</a> ()</td></tr>
<tr class="memdesc:a372de693ad40b3f42839c8ec6ac845f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: resets extracted model to solve from scratch.  <a href="classoperations__research_1_1MPSolver.html#a372de693ad40b3f42839c8ec6ac845f4">More...</a><br /></td></tr>
<tr class="separator:a372de693ad40b3f42839c8ec6ac845f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75b700ead5ff5d0944b5161e6dac9e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ac75b700ead5ff5d0944b5161e6dac9e8">InterruptSolve</a> ()</td></tr>
<tr class="memdesc:ac75b700ead5ff5d0944b5161e6dac9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupts the <a class="el" href="classoperations__research_1_1MPSolver.html#a9f55f5e7a62b45961982063ebc1e9945" title="Solves the problem using the default parameter values.">Solve()</a> execution to terminate processing if possible.  <a href="classoperations__research_1_1MPSolver.html#ac75b700ead5ff5d0944b5161e6dac9e8">More...</a><br /></td></tr>
<tr class="separator:ac75b700ead5ff5d0944b5161e6dac9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f83070e72cee887e874382ee6d6958"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoperations__research.html#aeaeaf340789f2dd271dcf9204279cb1b">MPSolverResponseStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ab0f83070e72cee887e874382ee6d6958">LoadModelFromProto</a> (const MPModelProto &amp;input_model, std::string *error_message)</td></tr>
<tr class="memdesc:ab0f83070e72cee887e874382ee6d6958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads model from protocol buffer.  <a href="classoperations__research_1_1MPSolver.html#ab0f83070e72cee887e874382ee6d6958">More...</a><br /></td></tr>
<tr class="separator:ab0f83070e72cee887e874382ee6d6958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74ce5ecb0dd3b4bcddb31bd59da7089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoperations__research.html#aeaeaf340789f2dd271dcf9204279cb1b">MPSolverResponseStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ae74ce5ecb0dd3b4bcddb31bd59da7089">LoadModelFromProtoWithUniqueNamesOrDie</a> (const MPModelProto &amp;input_model, std::string *error_message)</td></tr>
<tr class="memdesc:ae74ce5ecb0dd3b4bcddb31bd59da7089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads model from protocol buffer.  <a href="classoperations__research_1_1MPSolver.html#ae74ce5ecb0dd3b4bcddb31bd59da7089">More...</a><br /></td></tr>
<tr class="separator:ae74ce5ecb0dd3b4bcddb31bd59da7089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018794097e44ee8189380eef2b0f267f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a018794097e44ee8189380eef2b0f267f">FillSolutionResponseProto</a> (MPSolutionResponse *response) const</td></tr>
<tr class="memdesc:a018794097e44ee8189380eef2b0f267f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the current solution in a solution response protocol buffer.  <a href="classoperations__research_1_1MPSolver.html#a018794097e44ee8189380eef2b0f267f">More...</a><br /></td></tr>
<tr class="separator:a018794097e44ee8189380eef2b0f267f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880227c1bbe5a1a2a21796a947804615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a880227c1bbe5a1a2a21796a947804615">ExportModelToProto</a> (MPModelProto *output_model) const</td></tr>
<tr class="memdesc:a880227c1bbe5a1a2a21796a947804615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports model to protocol buffer.  <a href="classoperations__research_1_1MPSolver.html#a880227c1bbe5a1a2a21796a947804615">More...</a><br /></td></tr>
<tr class="separator:a880227c1bbe5a1a2a21796a947804615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae233b0f771236fe24ad255830012159f"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ae233b0f771236fe24ad255830012159f">LoadSolutionFromProto</a> (const MPSolutionResponse &amp;response, double tolerance=<a class="el" href="namespaceoperations__research.html#a221d711fbd5a16db9dc92a3c5095cbf5">kDefaultPrimalTolerance</a>)</td></tr>
<tr class="memdesc:ae233b0f771236fe24ad255830012159f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a solution encoded in a protocol buffer onto this solver for easy access via the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> interface.  <a href="classoperations__research_1_1MPSolver.html#ae233b0f771236fe24ad255830012159f">More...</a><br /></td></tr>
<tr class="separator:ae233b0f771236fe24ad255830012159f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df947ed3bb70075e234f8f0f78bc8ee"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a9df947ed3bb70075e234f8f0f78bc8ee">ClampSolutionWithinBounds</a> ()</td></tr>
<tr class="memdesc:a9df947ed3bb70075e234f8f0f78bc8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets values of out of bound variables to the corresponding bound and returns an error if any of the variables have NaN value.  <a href="classoperations__research_1_1MPSolver.html#a9df947ed3bb70075e234f8f0f78bc8ee">More...</a><br /></td></tr>
<tr class="separator:a9df947ed3bb70075e234f8f0f78bc8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a00625dd56e64b32c97b95445a1b9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aa9a00625dd56e64b32c97b95445a1b9c">ExportModelAsLpFormat</a> (bool obfuscate, std::string *model_str) const</td></tr>
<tr class="memdesc:aa9a00625dd56e64b32c97b95445a1b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcuts to the homonymous MPModelProtoExporter methods, via exporting to a MPModelProto with <a class="el" href="classoperations__research_1_1MPSolver.html#a880227c1bbe5a1a2a21796a947804615" title="Exports model to protocol buffer.">ExportModelToProto()</a> (see above).  <a href="classoperations__research_1_1MPSolver.html#aa9a00625dd56e64b32c97b95445a1b9c">More...</a><br /></td></tr>
<tr class="separator:aa9a00625dd56e64b32c97b95445a1b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3669577a3f7b00eaf00bbcb0f13da31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ab3669577a3f7b00eaf00bbcb0f13da31">ExportModelAsMpsFormat</a> (bool fixed_format, bool obfuscate, std::string *model_str) const</td></tr>
<tr class="separator:ab3669577a3f7b00eaf00bbcb0f13da31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849bf49baad56df58c018e8ab09456fb"><td class="memItemLeft" align="right" valign="top">absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a849bf49baad56df58c018e8ab09456fb">SetNumThreads</a> (int num_threads)</td></tr>
<tr class="memdesc:a849bf49baad56df58c018e8ab09456fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of threads to use by the underlying solver.  <a href="classoperations__research_1_1MPSolver.html#a849bf49baad56df58c018e8ab09456fb">More...</a><br /></td></tr>
<tr class="separator:a849bf49baad56df58c018e8ab09456fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb213aafa3773dfb6a05d184e61bb8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a8eb213aafa3773dfb6a05d184e61bb8a">GetNumThreads</a> () const</td></tr>
<tr class="memdesc:a8eb213aafa3773dfb6a05d184e61bb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of threads to be used during solve.  <a href="classoperations__research_1_1MPSolver.html#a8eb213aafa3773dfb6a05d184e61bb8a">More...</a><br /></td></tr>
<tr class="separator:a8eb213aafa3773dfb6a05d184e61bb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77083241e8bdb93b619c7b9feaf82dec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a77083241e8bdb93b619c7b9feaf82dec">SetSolverSpecificParametersAsString</a> (const std::string &amp;parameters)</td></tr>
<tr class="memdesc:a77083241e8bdb93b619c7b9feaf82dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: pass solver specific parameters in text format.  <a href="classoperations__research_1_1MPSolver.html#a77083241e8bdb93b619c7b9feaf82dec">More...</a><br /></td></tr>
<tr class="separator:a77083241e8bdb93b619c7b9feaf82dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9658c1e6f69bfd3d938e1b8d3f85ba40"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a9658c1e6f69bfd3d938e1b8d3f85ba40">GetSolverSpecificParametersAsString</a> () const</td></tr>
<tr class="separator:a9658c1e6f69bfd3d938e1b8d3f85ba40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf4b01cb836a567c90aeeea374ca2a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a4bf4b01cb836a567c90aeeea374ca2a2">SetHint</a> (std::vector&lt; std::pair&lt; const <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *, double &gt; &gt; hint)</td></tr>
<tr class="memdesc:a4bf4b01cb836a567c90aeeea374ca2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a hint for solution.  <a href="classoperations__research_1_1MPSolver.html#a4bf4b01cb836a567c90aeeea374ca2a2">More...</a><br /></td></tr>
<tr class="separator:a4bf4b01cb836a567c90aeeea374ca2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bc1eaf78615ea6084d975e892c33f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a43bc1eaf78615ea6084d975e892c33f1">SetStartingLpBasis</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1MPSolver.html#afd922eb2bef96597c426557a8056f76d">MPSolver::BasisStatus</a> &gt; &amp;variable_statuses, const std::vector&lt; <a class="el" href="classoperations__research_1_1MPSolver.html#afd922eb2bef96597c426557a8056f76d">MPSolver::BasisStatus</a> &gt; &amp;constraint_statuses)</td></tr>
<tr class="memdesc:a43bc1eaf78615ea6084d975e892c33f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: Incrementality.  <a href="classoperations__research_1_1MPSolver.html#a43bc1eaf78615ea6084d975e892c33f1">More...</a><br /></td></tr>
<tr class="separator:a43bc1eaf78615ea6084d975e892c33f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32654406932f9a6afcf44c4d5a143d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ab32654406932f9a6afcf44c4d5a143d2">OutputIsEnabled</a> () const</td></tr>
<tr class="memdesc:ab32654406932f9a6afcf44c4d5a143d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls (or queries) the amount of output produced by the underlying solver.  <a href="classoperations__research_1_1MPSolver.html#ab32654406932f9a6afcf44c4d5a143d2">More...</a><br /></td></tr>
<tr class="separator:ab32654406932f9a6afcf44c4d5a143d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79f6dc56d90d220de25c15f367b888f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ad79f6dc56d90d220de25c15f367b888f">EnableOutput</a> ()</td></tr>
<tr class="memdesc:ad79f6dc56d90d220de25c15f367b888f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables solver logging.  <a href="classoperations__research_1_1MPSolver.html#ad79f6dc56d90d220de25c15f367b888f">More...</a><br /></td></tr>
<tr class="separator:ad79f6dc56d90d220de25c15f367b888f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1df08a9aabad59b5d620930126e6d91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ae1df08a9aabad59b5d620930126e6d91">SuppressOutput</a> ()</td></tr>
<tr class="memdesc:ae1df08a9aabad59b5d620930126e6d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppresses solver logging.  <a href="classoperations__research_1_1MPSolver.html#ae1df08a9aabad59b5d620930126e6d91">More...</a><br /></td></tr>
<tr class="separator:ae1df08a9aabad59b5d620930126e6d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f5aac5b77ce69f53a130b8a779e0b7"><td class="memItemLeft" align="right" valign="top">absl::Duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#af3f5aac5b77ce69f53a130b8a779e0b7">TimeLimit</a> () const</td></tr>
<tr class="separator:af3f5aac5b77ce69f53a130b8a779e0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1d83614c47aa9934d4f9312e6056d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aff1d83614c47aa9934d4f9312e6056d4">SetTimeLimit</a> (absl::Duration <a class="el" href="classoperations__research_1_1MPSolver.html#aa42a63e7d72e799085af5a421b58b3ba">time_limit</a>)</td></tr>
<tr class="separator:aff1d83614c47aa9934d4f9312e6056d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35603553a6e2fa78a217ca1a4e7e6c18"><td class="memItemLeft" align="right" valign="top">absl::Duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a35603553a6e2fa78a217ca1a4e7e6c18">DurationSinceConstruction</a> () const</td></tr>
<tr class="separator:a35603553a6e2fa78a217ca1a4e7e6c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f94769e8f7f3e051ba504be9ed1fa6f"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a8f94769e8f7f3e051ba504be9ed1fa6f">iterations</a> () const</td></tr>
<tr class="memdesc:a8f94769e8f7f3e051ba504be9ed1fa6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of simplex iterations.  <a href="classoperations__research_1_1MPSolver.html#a8f94769e8f7f3e051ba504be9ed1fa6f">More...</a><br /></td></tr>
<tr class="separator:a8f94769e8f7f3e051ba504be9ed1fa6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ae17fc48ac80f494d7ed2202d61f29"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a51ae17fc48ac80f494d7ed2202d61f29">nodes</a> () const</td></tr>
<tr class="memdesc:a51ae17fc48ac80f494d7ed2202d61f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of branch-and-bound nodes evaluated during the solve.  <a href="classoperations__research_1_1MPSolver.html#a51ae17fc48ac80f494d7ed2202d61f29">More...</a><br /></td></tr>
<tr class="separator:a51ae17fc48ac80f494d7ed2202d61f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858f72e8c0c03339c8d797d41a6fd4b8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a858f72e8c0c03339c8d797d41a6fd4b8">SolverVersion</a> () const</td></tr>
<tr class="memdesc:a858f72e8c0c03339c8d797d41a6fd4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string describing the underlying solver and its version.  <a href="classoperations__research_1_1MPSolver.html#a858f72e8c0c03339c8d797d41a6fd4b8">More...</a><br /></td></tr>
<tr class="separator:a858f72e8c0c03339c8d797d41a6fd4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1269e748520719b9d11f6ef2d1c28c42"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a1269e748520719b9d11f6ef2d1c28c42">underlying_solver</a> ()</td></tr>
<tr class="memdesc:a1269e748520719b9d11f6ef2d1c28c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: returns the underlying solver.  <a href="classoperations__research_1_1MPSolver.html#a1269e748520719b9d11f6ef2d1c28c42">More...</a><br /></td></tr>
<tr class="separator:a1269e748520719b9d11f6ef2d1c28c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eef77bb51bde41e69bed87ea44b86e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a4eef77bb51bde41e69bed87ea44b86e1">ComputeExactConditionNumber</a> () const</td></tr>
<tr class="memdesc:a4eef77bb51bde41e69bed87ea44b86e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: computes the exact condition number of the current scaled basis: L1norm(B) * L1norm(inverse(B)), where B is the scaled basis.  <a href="classoperations__research_1_1MPSolver.html#a4eef77bb51bde41e69bed87ea44b86e1">More...</a><br /></td></tr>
<tr class="separator:a4eef77bb51bde41e69bed87ea44b86e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18daa488abaa904f23c8f74158290883"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a18daa488abaa904f23c8f74158290883">NextSolution</a> ()</td></tr>
<tr class="memdesc:a18daa488abaa904f23c8f74158290883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some solvers (MIP only, not LP) can produce multiple solutions to the problem.  <a href="classoperations__research_1_1MPSolver.html#a18daa488abaa904f23c8f74158290883">More...</a><br /></td></tr>
<tr class="separator:a18daa488abaa904f23c8f74158290883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee44c64a12654b08dff20b74702ac6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aaee44c64a12654b08dff20b74702ac6f">SetCallback</a> (MPCallback *mp_callback)</td></tr>
<tr class="separator:aaee44c64a12654b08dff20b74702ac6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8618b250f62af1c96b2f9f7ebbdaa8b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a8618b250f62af1c96b2f9f7ebbdaa8b6">SupportsCallbacks</a> () const</td></tr>
<tr class="separator:a8618b250f62af1c96b2f9f7ebbdaa8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42a63e7d72e799085af5a421b58b3ba"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aa42a63e7d72e799085af5a421b58b3ba">time_limit</a> () const</td></tr>
<tr class="separator:aa42a63e7d72e799085af5a421b58b3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76284cc2e7493610853f6e8ff1746d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ac76284cc2e7493610853f6e8ff1746d2">set_time_limit</a> (int64 time_limit_milliseconds)</td></tr>
<tr class="separator:ac76284cc2e7493610853f6e8ff1746d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58dd106d6ce5869923cc448621066d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ad58dd106d6ce5869923cc448621066d6">time_limit_in_secs</a> () const</td></tr>
<tr class="separator:ad58dd106d6ce5869923cc448621066d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80533bb150275c3c1c46e7ee3f31a822"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a80533bb150275c3c1c46e7ee3f31a822">wall_time</a> () const</td></tr>
<tr class="separator:a80533bb150275c3c1c46e7ee3f31a822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cb7bd4cf46dda371f91184d6232a44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aa2cb7bd4cf46dda371f91184d6232a44">OwnsVariable</a> (const <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *var) const</td></tr>
<tr class="separator:aa2cb7bd4cf46dda371f91184d6232a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af63f7de45a05eb7439a7a1c9ca594fd8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#af63f7de45a05eb7439a7a1c9ca594fd8">SupportsProblemType</a> (<a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8">OptimizationProblemType</a> problem_type)</td></tr>
<tr class="memdesc:af63f7de45a05eb7439a7a1c9ca594fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the given problem type is supported (this will depend on the targets that you linked).  <a href="classoperations__research_1_1MPSolver.html#af63f7de45a05eb7439a7a1c9ca594fd8">More...</a><br /></td></tr>
<tr class="separator:af63f7de45a05eb7439a7a1c9ca594fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13350b0e0b8b4b2571b6088895f08ab1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a13350b0e0b8b4b2571b6088895f08ab1">ParseSolverType</a> (absl::string_view solver, <a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8">OptimizationProblemType</a> *type)</td></tr>
<tr class="memdesc:a13350b0e0b8b4b2571b6088895f08ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the name of the solver.  <a href="classoperations__research_1_1MPSolver.html#a13350b0e0b8b4b2571b6088895f08ab1">More...</a><br /></td></tr>
<tr class="separator:a13350b0e0b8b4b2571b6088895f08ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ad12b13903108544b594819a65b793"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a99ad12b13903108544b594819a65b793">SolveWithProto</a> (const MPModelRequest &amp;model_request, MPSolutionResponse *response)</td></tr>
<tr class="memdesc:a99ad12b13903108544b594819a65b793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the model encoded by a MPModelRequest protocol buffer and fills the solution encoded as a MPSolutionResponse.  <a href="classoperations__research_1_1MPSolver.html#a99ad12b13903108544b594819a65b793">More...</a><br /></td></tr>
<tr class="separator:a99ad12b13903108544b594819a65b793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9655632a7a05d89fc1562459b26d7955"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a9655632a7a05d89fc1562459b26d7955">infinity</a> ()</td></tr>
<tr class="memdesc:a9655632a7a05d89fc1562459b26d7955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infinity.  <a href="classoperations__research_1_1MPSolver.html#a9655632a7a05d89fc1562459b26d7955">More...</a><br /></td></tr>
<tr class="separator:a9655632a7a05d89fc1562459b26d7955"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="afd922eb2bef96597c426557a8056f76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd922eb2bef96597c426557a8056f76d">&#9670;&nbsp;</a></span>BasisStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classoperations__research_1_1MPSolver.html#afd922eb2bef96597c426557a8056f76d">BasisStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: possible basis status values for a variable and the slack variable of a linear constraint. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afd922eb2bef96597c426557a8056f76dacc62d1576546f3245237e1b232d838b6"></a>FREE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afd922eb2bef96597c426557a8056f76da6745b95540b79aaa5ee98f7e128b6033"></a>AT_LOWER_BOUND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afd922eb2bef96597c426557a8056f76da0d243399df954cc7c42a62953ca00aa2"></a>AT_UPPER_BOUND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afd922eb2bef96597c426557a8056f76daaf36138ad9ba5562db2eaf2f7c6e18d0"></a>FIXED_VALUE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afd922eb2bef96597c426557a8056f76da13c45196813cb44e6e81e9c48a5ec1b4"></a>BASIC&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00615">615</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a76c87990aabadd148304b95332a60ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c87990aabadd148304b95332a60ff8">&#9670;&nbsp;</a></span>OptimizationProblemType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8">OptimizationProblemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of problems (LP or MIP) that will be solved and the underlying solver (GLOP, GLPK, CLP, CBC or SCIP) that will solve them. </p>
<p>This must remain consistent with MPModelRequest::OptimizationProblemType (take particular care of the open-source version). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a76c87990aabadd148304b95332a60ff8a21a919f23e61f3bdea7509c3887c888f"></a>GLOP_LINEAR_PROGRAMMING&#160;</td><td class="fielddoc"><p>Linear Programming solver using GLOP (Recommended solver). </p>
</td></tr>
<tr><td class="fieldname"><a id="a76c87990aabadd148304b95332a60ff8a83b85675904f261c34c280b2abdcd9ae"></a>SCIP_MIXED_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"><p>Mixed integer Programming Solver using SCIP. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76c87990aabadd148304b95332a60ff8ad183dc62c63346a3b984b93fbda0137a"></a>CBC_MIXED_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"><p>Mixed integer Programming Solver using Coin CBC. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76c87990aabadd148304b95332a60ff8a63c332dd969034f3c3086975a9e23b7e"></a>BOP_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"><p>Linear Boolean Programming Solver. </p>
</td></tr>
<tr><td class="fieldname"><a id="a76c87990aabadd148304b95332a60ff8aa12b397b225ca43d143085b619706e18"></a>SAT_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"><p>SAT based solver (requires only integer and Boolean variables). </p>
<p>If you pass it mixed integer problems, it will scale coefficients to integer values, and solve continuous variables as integral variables. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00185">185</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a573d479910e373f5d771d303e440587d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573d479910e373f5d771d303e440587d">&#9670;&nbsp;</a></span>ResultStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587d">ResultStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The status of solving the problem. </p>
<p>The straightforward translation to homonymous enum values of MPSolverResponseStatus (see ./linear_solver.proto) is guaranteed by ./enum_consistency_test.cc, you may rely on it. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a573d479910e373f5d771d303e440587da2579881e7c83261bc21bafb5a5c92cad"></a>OPTIMAL&#160;</td><td class="fielddoc"><p>optimal. </p>
</td></tr>
<tr><td class="fieldname"><a id="a573d479910e373f5d771d303e440587da03f919221217f95d21a593a7120165e1"></a>FEASIBLE&#160;</td><td class="fielddoc"><p>feasible, or stopped by limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="a573d479910e373f5d771d303e440587da2884fa43446c0cbc9c7a9b74d41d7483"></a>INFEASIBLE&#160;</td><td class="fielddoc"><p>proven infeasible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a573d479910e373f5d771d303e440587da6c65123d1b5b01632a477661055b01ef"></a>UNBOUNDED&#160;</td><td class="fielddoc"><p>proven unbounded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a573d479910e373f5d771d303e440587dadd7ccc352d727224d39519584ed37cd7"></a>ABNORMAL&#160;</td><td class="fielddoc"><p>abnormal, i.e., error of some kind. </p>
</td></tr>
<tr><td class="fieldname"><a id="a573d479910e373f5d771d303e440587dae071e79c23f061c9dd00ee09519a0031"></a>MODEL_INVALID&#160;</td><td class="fielddoc"><p>the model is trivially invalid (NaN coefficients, etc). </p>
</td></tr>
<tr><td class="fieldname"><a id="a573d479910e373f5d771d303e440587da0e6873a155f86a4695f463bf8601d05f"></a>NOT_SOLVED&#160;</td><td class="fielddoc"><p>not been solved yet. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00406">406</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acdb0e5753d20e4d3ece49a0451d24c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb0e5753d20e4d3ece49a0451d24c4f">&#9670;&nbsp;</a></span>MPSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPSolver.html">MPSolver</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8">OptimizationProblemType</a>&#160;</td>
          <td class="paramname"><em>problem_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a solver with the given name and underlying solver backend. </p>

</div>
</div>
<a id="a18c4c6d71bb8379b15a21868e1e2d3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c4c6d71bb8379b15a21868e1e2d3fa">&#9670;&nbsp;</a></span>~MPSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classoperations__research_1_1MPSolver.html">MPSolver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9df947ed3bb70075e234f8f0f78bc8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df947ed3bb70075e234f8f0f78bc8ee">&#9670;&nbsp;</a></span>ClampSolutionWithinBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status ClampSolutionWithinBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets values of out of bound variables to the corresponding bound and returns an error if any of the variables have NaN value. </p>

</div>
</div>
<a id="aa71d36872f416feaa853788a7a7a7ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71d36872f416feaa853788a7a7a7ef8">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the objective (including the optimization direction), all variables and constraints. </p>
<p>All the other properties of the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> (like the time limit) are kept untouched. </p>

</div>
</div>
<a id="ab17a7a859c6e429296e55570c06337cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17a7a859c6e429296e55570c06337cf">&#9670;&nbsp;</a></span>ComputeConstraintActivities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; ComputeConstraintActivities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: compute the "activities" of all constraints, which are the sums of their linear terms. </p>
<p>The activities are returned in the same order as <a class="el" href="classoperations__research_1_1MPSolver.html#a5ff11cd513c803ba3f75f2f672f1cf6f" title="Returns the array of constraints handled by the MPSolver.">constraints()</a>, which is the order in which constraints were added; but you can also use <a class="el" href="classoperations__research_1_1MPConstraint.html#acca41811e8aaab0112b987749c0ecb93" title="Returns the index of the constraint in the MPSolver::constraints_.">MPConstraint::index()</a> to get a constraint's index. </p>

</div>
</div>
<a id="a4eef77bb51bde41e69bed87ea44b86e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eef77bb51bde41e69bed87ea44b86e1">&#9670;&nbsp;</a></span>ComputeExactConditionNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ComputeExactConditionNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: computes the exact condition number of the current scaled basis: L1norm(B) * L1norm(inverse(B)), where B is the scaled basis. </p>
<p>This method requires that a basis exists: it should be called after Solve. It is only available for continuous problems. It is implemented for GLPK but not CLP because CLP does not provide the API for doing it.</p>
<p>The condition number measures how well the constraint matrix is conditioned and can be used to predict whether numerical issues will arise during the solve: the model is declared infeasible whereas it is feasible (or vice-versa), the solution obtained is not optimal or violates some constraints, the resolution is slow because of repeated singularities.</p>
<p>The rule of thumb to interpret the condition number kappa is:</p><ul>
<li>o kappa &lt;= 1e7: virtually no chance of numerical issues</li>
<li>o 1e7 &lt; kappa &lt;= 1e10: small chance of numerical issues</li>
<li>o 1e10 &lt; kappa &lt;= 1e13: medium chance of numerical issues</li>
<li>o kappa &gt; 1e13: high chance of numerical issues</li>
</ul>
<p>The computation of the condition number depends on the quality of the LU decomposition, so it is not very accurate when the matrix is ill conditioned. </p>

</div>
</div>
<a id="a5ff11cd513c803ba3f75f2f672f1cf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff11cd513c803ba3f75f2f672f1cf6f">&#9670;&nbsp;</a></span>constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>*&gt;&amp; constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the array of constraints handled by the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a>. </p>
<p>They are listed in the order in which they were created. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00347">347</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a35603553a6e2fa78a217ca1a4e7e6c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35603553a6e2fa78a217ca1a4e7e6c18">&#9670;&nbsp;</a></span>DurationSinceConstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">absl::Duration DurationSinceConstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00667">667</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="ad79f6dc56d90d220de25c15f367b888f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79f6dc56d90d220de25c15f367b888f">&#9670;&nbsp;</a></span>EnableOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnableOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables solver logging. </p>

</div>
</div>
<a id="aa9a00625dd56e64b32c97b95445a1b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a00625dd56e64b32c97b95445a1b9c">&#9670;&nbsp;</a></span>ExportModelAsLpFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ExportModelAsLpFormat </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>obfuscate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>model_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcuts to the homonymous MPModelProtoExporter methods, via exporting to a MPModelProto with <a class="el" href="classoperations__research_1_1MPSolver.html#a880227c1bbe5a1a2a21796a947804615" title="Exports model to protocol buffer.">ExportModelToProto()</a> (see above). </p>
<p>Produces empty std::string on portable platforms (e.g. android, ios). </p>

</div>
</div>
<a id="ab3669577a3f7b00eaf00bbcb0f13da31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3669577a3f7b00eaf00bbcb0f13da31">&#9670;&nbsp;</a></span>ExportModelAsMpsFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ExportModelAsMpsFormat </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fixed_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>obfuscate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>model_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a880227c1bbe5a1a2a21796a947804615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880227c1bbe5a1a2a21796a947804615">&#9670;&nbsp;</a></span>ExportModelToProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ExportModelToProto </td>
          <td>(</td>
          <td class="paramtype">MPModelProto *&#160;</td>
          <td class="paramname"><em>output_model</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports model to protocol buffer. </p>

</div>
</div>
<a id="a018794097e44ee8189380eef2b0f267f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018794097e44ee8189380eef2b0f267f">&#9670;&nbsp;</a></span>FillSolutionResponseProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FillSolutionResponseProto </td>
          <td>(</td>
          <td class="paramtype">MPSolutionResponse *&#160;</td>
          <td class="paramname"><em>response</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the current solution in a solution response protocol buffer. </p>

</div>
</div>
<a id="a8eb213aafa3773dfb6a05d184e61bb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb213aafa3773dfb6a05d184e61bb8a">&#9670;&nbsp;</a></span>GetNumThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int GetNumThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of threads to be used during solve. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00583">583</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a9658c1e6f69bfd3d938e1b8d3f85ba40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9658c1e6f69bfd3d938e1b8d3f85ba40">&#9670;&nbsp;</a></span>GetSolverSpecificParametersAsString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetSolverSpecificParametersAsString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00592">592</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a9655632a7a05d89fc1562459b26d7955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9655632a7a05d89fc1562459b26d7955">&#9670;&nbsp;</a></span>infinity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double infinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Infinity. </p>
<p>You can use -<a class="el" href="classoperations__research_1_1MPSolver.html#a9655632a7a05d89fc1562459b26d7955" title="Infinity.">MPSolver::infinity()</a> for negative infinity. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00643">643</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="ac75b700ead5ff5d0944b5161e6dac9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75b700ead5ff5d0944b5161e6dac9e8">&#9670;&nbsp;</a></span>InterruptSolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool InterruptSolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupts the <a class="el" href="classoperations__research_1_1MPSolver.html#a9f55f5e7a62b45961982063ebc1e9945" title="Solves the problem using the default parameter values.">Solve()</a> execution to terminate processing if possible. </p>
<p>If the underlying interface supports interruption; it does that and returns true regardless of whether there's an ongoing <a class="el" href="classoperations__research_1_1MPSolver.html#a9f55f5e7a62b45961982063ebc1e9945" title="Solves the problem using the default parameter values.">Solve()</a> or not. The <a class="el" href="classoperations__research_1_1MPSolver.html#a9f55f5e7a62b45961982063ebc1e9945" title="Solves the problem using the default parameter values.">Solve()</a> call may still linger for a while depending on the conditions. If interruption is not supported; returns false and does nothing. </p>

</div>
</div>
<a id="a29500cb9138fb0d96b2ed028d9253881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29500cb9138fb0d96b2ed028d9253881">&#9670;&nbsp;</a></span>IsMIP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsMIP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f94769e8f7f3e051ba504be9ed1fa6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f94769e8f7f3e051ba504be9ed1fa6f">&#9670;&nbsp;</a></span>iterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 iterations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of simplex iterations. </p>

</div>
</div>
<a id="ab0f83070e72cee887e874382ee6d6958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f83070e72cee887e874382ee6d6958">&#9670;&nbsp;</a></span>LoadModelFromProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoperations__research.html#aeaeaf340789f2dd271dcf9204279cb1b">MPSolverResponseStatus</a> LoadModelFromProto </td>
          <td>(</td>
          <td class="paramtype">const MPModelProto &amp;&#160;</td>
          <td class="paramname"><em>input_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>error_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads model from protocol buffer. </p>
<p>Returns MPSOLVER_MODEL_IS_VALID if the model is valid, and another status otherwise (currently only MPSOLVER_MODEL_INVALID and MPSOLVER_INFEASIBLE). If the model isn't valid, populates "error_message". </p>

</div>
</div>
<a id="ae74ce5ecb0dd3b4bcddb31bd59da7089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74ce5ecb0dd3b4bcddb31bd59da7089">&#9670;&nbsp;</a></span>LoadModelFromProtoWithUniqueNamesOrDie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoperations__research.html#aeaeaf340789f2dd271dcf9204279cb1b">MPSolverResponseStatus</a> LoadModelFromProtoWithUniqueNamesOrDie </td>
          <td>(</td>
          <td class="paramtype">const MPModelProto &amp;&#160;</td>
          <td class="paramname"><em>input_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>error_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads model from protocol buffer. </p>
<p>The same as above, except that the loading keeps original variable and constraint names. Caller should make sure that all variable names and constraint names are unique, respectively. </p>

</div>
</div>
<a id="ae233b0f771236fe24ad255830012159f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae233b0f771236fe24ad255830012159f">&#9670;&nbsp;</a></span>LoadSolutionFromProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status LoadSolutionFromProto </td>
          <td>(</td>
          <td class="paramtype">const MPSolutionResponse &amp;&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespaceoperations__research.html#a221d711fbd5a16db9dc92a3c5095cbf5">kDefaultPrimalTolerance</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a solution encoded in a protocol buffer onto this solver for easy access via the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> interface. </p>
<p>IMPORTANT: This may only be used in conjunction with ExportModel(), following this example:</p>
<div class="fragment"><div class="line"><a class="code" href="classoperations__research_1_1MPSolver.html#acdb0e5753d20e4d3ece49a0451d24c4f">MPSolver</a> my_solver;</div>
<div class="line">... add <a class="code" href="classoperations__research_1_1MPSolver.html#a34caaebb9e2b365ef0ec449e870f5b5d">variables</a> and <a class="code" href="classoperations__research_1_1MPSolver.html#a5ff11cd513c803ba3f75f2f672f1cf6f">constraints</a> ...</div>
<div class="line">MPModelProto model_proto;</div>
<div class="line">my_solver.ExportModelToProto(&amp;model_proto);</div>
<div class="line">MPSolutionResponse solver_response;</div>
<div class="line"><a class="code" href="classoperations__research_1_1MPSolver.html#a99ad12b13903108544b594819a65b793">MPSolver::SolveWithProto</a>(model_proto, &amp;solver_response);</div>
<div class="line"><span class="keywordflow">if</span> (solver_response.result_status() == MPSolutionResponse::OPTIMAL) {</div>
<div class="line">  CHECK_OK(my_solver.LoadSolutionFromProto(solver_response));</div>
<div class="line">  ... inspect the solution <span class="keyword">using</span> the usual API: solution_value(), etc...</div>
<div class="line">}</div>
</div><!-- fragment --><p>The response must be in OPTIMAL or FEASIBLE status.</p>
<p>Returns a non-OK status if a problem arised (typically, if it wasn't used like it should be):</p><ul>
<li>loading a solution whose variables don't correspond to the solver's current variables</li>
<li>loading a solution with a status other than OPTIMAL / FEASIBLE.</li>
</ul>
<p>Note: the objective value isn't checked. You can use <a class="el" href="classoperations__research_1_1MPSolver.html#a2c50b77c283c82d632f0dc605ceca3c3" title="Advanced usage: Verifies the correctness of the solution.">VerifySolution()</a> for that. </p>

</div>
</div>
<a id="abbf4c26107aac610a00471f41740b01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf4c26107aac610a00471f41740b01e">&#9670;&nbsp;</a></span>LookupConstraintOrNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* LookupConstraintOrNull </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>constraint_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up a constraint by name, and returns nullptr if it does not exist. </p>
<p>The first call has a O(n) complexity, as the constraint name index is lazily created upon first use. Will crash if constraint names are not unique. </p>

</div>
</div>
<a id="a981cdf256aa33e518b8747c96bf1a9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981cdf256aa33e518b8747c96bf1a9c7">&#9670;&nbsp;</a></span>LookupVariableOrNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a>* LookupVariableOrNull </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up a variable by name, and returns nullptr if it does not exist. </p>
<p>The first call has a O(n) complexity, as the variable name index is lazily created upon first use. Will crash if variable names are not unique. </p>

</div>
</div>
<a id="a2090dbd973eba8c24c4fa7b2714e4c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2090dbd973eba8c24c4fa7b2714e4c44">&#9670;&nbsp;</a></span>MakeBoolVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a>* MakeBoolVar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a boolean variable. </p>

</div>
</div>
<a id="a200ccd114eb5057856c05501c2d4abe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200ccd114eb5057856c05501c2d4abe5">&#9670;&nbsp;</a></span>MakeBoolVarArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MakeBoolVarArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array of boolean variables. </p>

</div>
</div>
<a id="a33b5ede96c77f6cfdd4f54325f384ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b5ede96c77f6cfdd4f54325f384ab7">&#9670;&nbsp;</a></span>MakeIntVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a>* MakeIntVar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an integer variable. </p>

</div>
</div>
<a id="a9333144b7d28f68a7537b2ba19a1ba9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9333144b7d28f68a7537b2ba19a1ba9b">&#9670;&nbsp;</a></span>MakeIntVarArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MakeIntVarArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array of integer variables. </p>

</div>
</div>
<a id="ae522890e16fd065100174a819558b461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae522890e16fd065100174a819558b461">&#9670;&nbsp;</a></span>MakeNumVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a>* MakeNumVar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a continuous variable. </p>

</div>
</div>
<a id="a648a61e30b62b1c17ab1f49fe6c9ed8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648a61e30b62b1c17ab1f49fe6c9ed8d">&#9670;&nbsp;</a></span>MakeNumVarArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MakeNumVarArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array of continuous variables. </p>

</div>
</div>
<a id="ab60f33fbc8132eda10c296885625b7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60f33fbc8132eda10c296885625b7d9">&#9670;&nbsp;</a></span>MakeRowConstraint() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* MakeRowConstraint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a constraint with -infinity and +infinity bounds. </p>

</div>
</div>
<a id="a04cd78bd7a418107a920ca2ee7710aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cd78bd7a418107a920ca2ee7710aa7">&#9670;&nbsp;</a></span>MakeRowConstraint() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* MakeRowConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a constraint owned by <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> enforcing: range.lower_bound() &lt;= range.linear_expr() &lt;= range.upper_bound() </p>

</div>
</div>
<a id="afc5409af80c8d0d848fa354e5c8ea0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5409af80c8d0d848fa354e5c8ea0b0">&#9670;&nbsp;</a></span>MakeRowConstraint() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* MakeRowConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As above, but also names the constraint. </p>

</div>
</div>
<a id="a2ee6dd214598834edf57d950333b11f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee6dd214598834edf57d950333b11f7">&#9670;&nbsp;</a></span>MakeRowConstraint() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* MakeRowConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a named constraint with -infinity and +infinity bounds. </p>

</div>
</div>
<a id="a0f97f44428bff07c2308b45bfb62223b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f97f44428bff07c2308b45bfb62223b">&#9670;&nbsp;</a></span>MakeRowConstraint() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* MakeRowConstraint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a linear constraint with given bounds. </p>
<p>Bounds can be finite or +/- <a class="el" href="classoperations__research_1_1MPSolver.html#a9655632a7a05d89fc1562459b26d7955" title="Infinity.">MPSolver::infinity()</a>. The <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> class assumes ownership of the constraint.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created constraint. </dd></dl>

</div>
</div>
<a id="a5cf8f81a46598a4ef20ae7674696c40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf8f81a46598a4ef20ae7674696c40d">&#9670;&nbsp;</a></span>MakeRowConstraint() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* MakeRowConstraint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a named constraint with given bounds. </p>

</div>
</div>
<a id="a728f0121faaa95a451eaef6eb13e2242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728f0121faaa95a451eaef6eb13e2242">&#9670;&nbsp;</a></span>MakeVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a>* MakeVar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>integer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a variable with the given bounds, integrality requirement and name. </p>
<p>Bounds can be finite or +/- <a class="el" href="classoperations__research_1_1MPSolver.html#a9655632a7a05d89fc1562459b26d7955" title="Infinity.">MPSolver::infinity()</a>. The <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> owns the variable (i.e. the returned pointer is borrowed). Variable names are optional. If you give an empty name, name() will auto-generate one for you upon request. </p>

</div>
</div>
<a id="a66fd302d0082c74e6dea35ac59784847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fd302d0082c74e6dea35ac59784847">&#9670;&nbsp;</a></span>MakeVarArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MakeVarArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>integer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array of variables. </p>
<p>All variables created have the same bounds and integrality requirement. If nb &lt;= 0, no variables are created, the function crashes in non-opt mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">nb</td><td>the number of variables to create. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lb</td><td>the lower bound of created variables </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ub</td><td>the upper bound of created variables </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">integer</td><td>controls whether the created variables are continuous or integral. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name_prefix</td><td>the prefix of the variable names. Variables are named name_prefix0, name_prefix1, ... </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vars</td><td>the vector of variables to fill with variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a226456dfb15300dd4e59d0bf80d0ce07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226456dfb15300dd4e59d0bf80d0ce07">&#9670;&nbsp;</a></span>MutableObjective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPObjective.html">MPObjective</a>* MutableObjective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mutable objective object. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00398">398</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a191cd9b1ba3e3c01a558a1f6c02a4429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191cd9b1ba3e3c01a558a1f6c02a4429">&#9670;&nbsp;</a></span>Name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; Name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the model set at construction. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00258">258</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a18daa488abaa904f23c8f74158290883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18daa488abaa904f23c8f74158290883">&#9670;&nbsp;</a></span>NextSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool NextSolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some solvers (MIP only, not LP) can produce multiple solutions to the problem. </p>
<p>Returns true when another solution is available, and updates the MPVariable* objects to make the new solution queryable. Call only after calling solve.</p>
<p>The optimality properties of the additional solutions found, and whether or not the solver computes them ahead of time or when <a class="el" href="classoperations__research_1_1MPSolver.html#a18daa488abaa904f23c8f74158290883" title="Some solvers (MIP only, not LP) can produce multiple solutions to the problem.">NextSolution()</a> is called is solver specific.</p>
<p>As of 2020-02-10, only Gurobi and SCIP support <a class="el" href="classoperations__research_1_1MPSolver.html#a18daa488abaa904f23c8f74158290883" title="Some solvers (MIP only, not LP) can produce multiple solutions to the problem.">NextSolution()</a>, see linear_solver_interfaces_test for an example of how to configure these solvers for multiple solutions. Other solvers return false unconditionally. </p>

</div>
</div>
<a id="a51ae17fc48ac80f494d7ed2202d61f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ae17fc48ac80f494d7ed2202d61f29">&#9670;&nbsp;</a></span>nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of branch-and-bound nodes evaluated during the solve. </p>
<p>Only available for discrete problems. </p>

</div>
</div>
<a id="a03666f2e70e42a9560aa9ce7416d2644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03666f2e70e42a9560aa9ce7416d2644">&#9670;&nbsp;</a></span>NumConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NumConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of constraints. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00340">340</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a9d3beb2afe4ae647674b054bf29290e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3beb2afe4ae647674b054bf29290e2">&#9670;&nbsp;</a></span>NumVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NumVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of variables. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00275">275</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a5004489a36bc1393efa043044a63732f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5004489a36bc1393efa043044a63732f">&#9670;&nbsp;</a></span>Objective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classoperations__research_1_1MPObjective.html">MPObjective</a>&amp; Objective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the objective object. </p>
<p>Note that the objective is owned by the solver, and is initialized to its default value (see the <a class="el" href="classoperations__research_1_1MPObjective.html" title="A class to express a linear objective.">MPObjective</a> class below) at construction. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00395">395</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="ab32654406932f9a6afcf44c4d5a143d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32654406932f9a6afcf44c4d5a143d2">&#9670;&nbsp;</a></span>OutputIsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OutputIsEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls (or queries) the amount of output produced by the underlying solver. </p>
<p>The output can surface to LOGs, or to stdout or stderr, depending on the implementation. The amount of output will greatly vary with each implementation and each problem.</p>
<p>Output is suppressed by default. </p>

</div>
</div>
<a id="aa2cb7bd4cf46dda371f91184d6232a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cb7bd4cf46dda371f91184d6232a44">&#9670;&nbsp;</a></span>OwnsVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OwnsVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13350b0e0b8b4b2571b6088895f08ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13350b0e0b8b4b2571b6088895f08ab1">&#9670;&nbsp;</a></span>ParseSolverType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ParseSolverType </td>
          <td>(</td>
          <td class="paramtype">absl::string_view&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8">OptimizationProblemType</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the name of the solver. </p>
<p>Returns true if the solver type is successfully parsed as one of the OptimizationProblemType. </p>

</div>
</div>
<a id="aee8250cf90d66d569534338248924469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8250cf90d66d569534338248924469">&#9670;&nbsp;</a></span>ProblemType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8">OptimizationProblemType</a> ProblemType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the optimization problem type set at construction. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00263">263</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a372de693ad40b3f42839c8ec6ac845f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372de693ad40b3f42839c8ec6ac845f4">&#9670;&nbsp;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: resets extracted model to solve from scratch. </p>
<p>This won't reset the parameters that were set with <a class="el" href="classoperations__research_1_1MPSolver.html#a77083241e8bdb93b619c7b9feaf82dec" title="Advanced usage: pass solver specific parameters in text format.">SetSolverSpecificParametersAsString()</a> or <a class="el" href="classoperations__research_1_1MPSolver.html#ac76284cc2e7493610853f6e8ff1746d2">set_time_limit()</a> or even clear the linear program. It will just make sure that next <a class="el" href="classoperations__research_1_1MPSolver.html#a9f55f5e7a62b45961982063ebc1e9945" title="Solves the problem using the default parameter values.">Solve()</a> will be as if everything was reconstructed from scratch. </p>

</div>
</div>
<a id="ac76284cc2e7493610853f6e8ff1746d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76284cc2e7493610853f6e8ff1746d2">&#9670;&nbsp;</a></span>set_time_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_time_limit </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>time_limit_milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00757">757</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="aaee44c64a12654b08dff20b74702ac6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee44c64a12654b08dff20b74702ac6f">&#9670;&nbsp;</a></span>SetCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetCallback </td>
          <td>(</td>
          <td class="paramtype">MPCallback *&#160;</td>
          <td class="paramname"><em>mp_callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bf4b01cb836a567c90aeeea374ca2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf4b01cb836a567c90aeeea374ca2a2">&#9670;&nbsp;</a></span>SetHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetHint </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; const <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *, double &gt; &gt;&#160;</td>
          <td class="paramname"><em>hint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a hint for solution. </p>
<p>If a feasible or almost-feasible solution to the problem is already known, it may be helpful to pass it to the solver so that it can be used. A solver that supports this feature will try to use this information to create its initial feasible solution.</p>
<p>Note: It may not always be faster to give a hint like this to the solver. There is also no guarantee that the solver will use this hint or try to return a solution "close" to this assignment in case of multiple optimal solutions. </p>

</div>
</div>
<a id="a849bf49baad56df58c018e8ab09456fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849bf49baad56df58c018e8ab09456fb">&#9670;&nbsp;</a></span>SetNumThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::Status SetNumThreads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of threads to use by the underlying solver. </p>
<p>Returns OkStatus if the operation was successful. num_threads must be equal to or greater than 1. Note that the behaviour of this call depends on the underlying solver. E.g., it may set the exact number of threads or the max number of threads (check the solver's interface implementation for details). Also, some solvers may not (yet) support this function, but still enable multi-threading via <a class="el" href="classoperations__research_1_1MPSolver.html#a77083241e8bdb93b619c7b9feaf82dec" title="Advanced usage: pass solver specific parameters in text format.">SetSolverSpecificParametersAsString()</a>. </p>

</div>
</div>
<a id="a77083241e8bdb93b619c7b9feaf82dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77083241e8bdb93b619c7b9feaf82dec">&#9670;&nbsp;</a></span>SetSolverSpecificParametersAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SetSolverSpecificParametersAsString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: pass solver specific parameters in text format. </p>
<p>The format is solver-specific and is the same as the corresponding solver configuration file format. Returns true if the operation was successful. </p>

</div>
</div>
<a id="a43bc1eaf78615ea6084d975e892c33f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bc1eaf78615ea6084d975e892c33f1">&#9670;&nbsp;</a></span>SetStartingLpBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetStartingLpBasis </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1MPSolver.html#afd922eb2bef96597c426557a8056f76d">MPSolver::BasisStatus</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variable_statuses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1MPSolver.html#afd922eb2bef96597c426557a8056f76d">MPSolver::BasisStatus</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_statuses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: Incrementality. </p>
<p>This function takes a starting basis to be used in the next LP <a class="el" href="classoperations__research_1_1MPSolver.html#a9f55f5e7a62b45961982063ebc1e9945" title="Solves the problem using the default parameter values.">Solve()</a> call. The statuses of a current solution can be retrieved via the basis_status() function of a <a class="el" href="classoperations__research_1_1MPVariable.html" title="The class for variables of a Mathematical Programming (MP) model.">MPVariable</a> or a <a class="el" href="classoperations__research_1_1MPConstraint.html" title="The class for constraints of a Mathematical Programming (MP) model.">MPConstraint</a>.</p>
<p>WARNING: With Glop, you should disable presolve when using this because this information will not be modified in sync with the presolve and will likely not mean much on the presolved problem. </p>

</div>
</div>
<a id="aff1d83614c47aa9934d4f9312e6056d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1d83614c47aa9934d4f9312e6056d4">&#9670;&nbsp;</a></span>SetTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetTimeLimit </td>
          <td>(</td>
          <td class="paramtype">absl::Duration&#160;</td>
          <td class="paramname"><em>time_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00662">662</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a9f55f5e7a62b45961982063ebc1e9945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f55f5e7a62b45961982063ebc1e9945">&#9670;&nbsp;</a></span>Solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587d">ResultStatus</a> Solve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the problem using the default parameter values. </p>

</div>
</div>
<a id="aaa2bb34f1712b9d7c36d75b1ec704563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2bb34f1712b9d7c36d75b1ec704563">&#9670;&nbsp;</a></span>Solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPSolver.html#a573d479910e373f5d771d303e440587d">ResultStatus</a> Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPSolverParameters.html">MPSolverParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the problem using the specified parameter values. </p>

</div>
</div>
<a id="a858f72e8c0c03339c8d797d41a6fd4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858f72e8c0c03339c8d797d41a6fd4b8">&#9670;&nbsp;</a></span>SolverVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SolverVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string describing the underlying solver and its version. </p>

</div>
</div>
<a id="a99ad12b13903108544b594819a65b793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ad12b13903108544b594819a65b793">&#9670;&nbsp;</a></span>SolveWithProto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SolveWithProto </td>
          <td>(</td>
          <td class="paramtype">const MPModelRequest &amp;&#160;</td>
          <td class="paramname"><em>model_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPSolutionResponse *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the model encoded by a MPModelRequest protocol buffer and fills the solution encoded as a MPSolutionResponse. </p>
<p>Note(user): This creates a temporary <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> and destroys it at the end. If you want to keep the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> alive (for debugging, or for incremental solving), you should write another version of this function that creates the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> object on the heap and returns it. </p>

</div>
</div>
<a id="a8618b250f62af1c96b2f9f7ebbdaa8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8618b250f62af1c96b2f9f7ebbdaa8b6">&#9670;&nbsp;</a></span>SupportsCallbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SupportsCallbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af63f7de45a05eb7439a7a1c9ca594fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63f7de45a05eb7439a7a1c9ca594fd8">&#9670;&nbsp;</a></span>SupportsProblemType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SupportsProblemType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1MPSolver.html#a76c87990aabadd148304b95332a60ff8">OptimizationProblemType</a>&#160;</td>
          <td class="paramname"><em>problem_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the given problem type is supported (this will depend on the targets that you linked). </p>

</div>
</div>
<a id="ae1df08a9aabad59b5d620930126e6d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1df08a9aabad59b5d620930126e6d91">&#9670;&nbsp;</a></span>SuppressOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SuppressOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suppresses solver logging. </p>

</div>
</div>
<a id="aa42a63e7d72e799085af5a421b58b3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42a63e7d72e799085af5a421b58b3ba">&#9670;&nbsp;</a></span>time_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64 time_limit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00752">752</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="ad58dd106d6ce5869923cc448621066d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58dd106d6ce5869923cc448621066d6">&#9670;&nbsp;</a></span>time_limit_in_secs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double time_limit_in_secs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00762">762</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="af3f5aac5b77ce69f53a130b8a779e0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f5aac5b77ce69f53a130b8a779e0b7">&#9670;&nbsp;</a></span>TimeLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">absl::Duration TimeLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00661">661</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a1269e748520719b9d11f6ef2d1c28c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1269e748520719b9d11f6ef2d1c28c42">&#9670;&nbsp;</a></span>underlying_solver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* underlying_solver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: returns the underlying solver. </p>
<p>Returns the underlying solver so that the user can use solver-specific features or features that are not exposed in the simple API of <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a>. This method is for advanced users, use at your own risk! In particular, if you modify the model or the solution by accessing the underlying solver directly, then the underlying solver will be out of sync with the information kept in the wrapper (<a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a>, <a class="el" href="classoperations__research_1_1MPVariable.html" title="The class for variables of a Mathematical Programming (MP) model.">MPVariable</a>, <a class="el" href="classoperations__research_1_1MPConstraint.html" title="The class for constraints of a Mathematical Programming (MP) model.">MPConstraint</a>, <a class="el" href="classoperations__research_1_1MPObjective.html" title="A class to express a linear objective.">MPObjective</a>). You need to cast the void* returned back to its original type that depends on the interface (CBC: OsiClpSolverInterface*, CLP: ClpSimplex*, GLPK: glp_prob*, SCIP: SCIP*). </p>

</div>
</div>
<a id="a34caaebb9e2b365ef0ec449e870f5b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34caaebb9e2b365ef0ec449e870f5b5d">&#9670;&nbsp;</a></span>variables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a>*&gt;&amp; variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the array of variables handled by the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a>. </p>
<p>(They are listed in the order in which they were created.) </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00281">281</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a2c50b77c283c82d632f0dc605ceca3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c50b77c283c82d632f0dc605ceca3c3">&#9670;&nbsp;</a></span>VerifySolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VerifySolution </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>log_errors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: Verifies the <em>correctness</em> of the solution. </p>
<p>It verifies that all variables must be within their domains, all constraints must be satisfied, and the reported objective value must be accurate.</p>
<p>Usage:</p><ul>
<li>This can only be called after <a class="el" href="classoperations__research_1_1MPSolver.html#a9f55f5e7a62b45961982063ebc1e9945" title="Solves the problem using the default parameter values.">Solve()</a> was called.</li>
<li>"tolerance" is interpreted as an absolute error threshold.</li>
<li>For the objective value only, if the absolute error is too large, the tolerance is interpreted as a relative error threshold instead.</li>
<li>If "log_errors" is true, every single violation will be logged.</li>
<li>If "tolerance" is negative, it will be set to <a class="el" href="classoperations__research_1_1MPSolver.html#a9655632a7a05d89fc1562459b26d7955" title="Infinity.">infinity()</a>.</li>
</ul>
<p>Most users should just set the &ndash;verify_solution flag and not bother using this method directly. </p>

</div>
</div>
<a id="a80533bb150275c3c1c46e7ee3f31a822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80533bb150275c3c1c46e7ee3f31a822">&#9670;&nbsp;</a></span>wall_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64 wall_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00767">767</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="aaa766a9aa802903bf7a6e5b8fb82c70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa766a9aa802903bf7a6e5b8fb82c70c">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Write </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the model using the solver internal write function. </p>
<p>Currently only available for Gurobi. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="linear__solver_8h_source.html">linear_solver.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassoperations__research_1_1MPSolver_html_a5ff11cd513c803ba3f75f2f672f1cf6f"><div class="ttname"><a href="classoperations__research_1_1MPSolver.html#a5ff11cd513c803ba3f75f2f672f1cf6f">operations_research::MPSolver::constraints</a></div><div class="ttdeci">const std::vector&lt; MPConstraint * &gt; &amp; constraints() const</div><div class="ttdoc">Returns the array of constraints handled by the MPSolver.</div><div class="ttdef"><b>Definition:</b> <a href="linear__solver_8h_source.html#l00347">linear_solver.h:347</a></div></div>
<div class="ttc" id="aclassoperations__research_1_1MPSolver_html_acdb0e5753d20e4d3ece49a0451d24c4f"><div class="ttname"><a href="classoperations__research_1_1MPSolver.html#acdb0e5753d20e4d3ece49a0451d24c4f">operations_research::MPSolver::MPSolver</a></div><div class="ttdeci">MPSolver(const std::string &amp;name, OptimizationProblemType problem_type)</div><div class="ttdoc">Create a solver with the given name and underlying solver backend.</div></div>
<div class="ttc" id="aclassoperations__research_1_1MPSolver_html_a34caaebb9e2b365ef0ec449e870f5b5d"><div class="ttname"><a href="classoperations__research_1_1MPSolver.html#a34caaebb9e2b365ef0ec449e870f5b5d">operations_research::MPSolver::variables</a></div><div class="ttdeci">const std::vector&lt; MPVariable * &gt; &amp; variables() const</div><div class="ttdoc">Returns the array of variables handled by the MPSolver.</div><div class="ttdef"><b>Definition:</b> <a href="linear__solver_8h_source.html#l00281">linear_solver.h:281</a></div></div>
<div class="ttc" id="aclassoperations__research_1_1MPSolver_html_a99ad12b13903108544b594819a65b793"><div class="ttname"><a href="classoperations__research_1_1MPSolver.html#a99ad12b13903108544b594819a65b793">operations_research::MPSolver::SolveWithProto</a></div><div class="ttdeci">static void SolveWithProto(const MPModelRequest &amp;model_request, MPSolutionResponse *response)</div><div class="ttdoc">Solves the model encoded by a MPModelRequest protocol buffer and fills the solution encoded as a MPSo...</div></div>
        </div>
        </div>
        <div id="footer-container">
            <div id="footer">
            </div>
        </div>
    </body>
</html>
